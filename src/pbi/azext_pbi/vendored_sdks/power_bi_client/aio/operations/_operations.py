# pylint: disable=too-many-lines
# coding=utf-8
# --------------------------------------------------------------------------
# Code generated by Microsoft (R) AutoRest Code Generator (autorest: 3.9.4, generator: @autorest/python@6.9.7)
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
import datetime
from io import IOBase
import sys
from typing import Any, AsyncIterator, Callable, Dict, IO, List, Optional, TypeVar, Union, cast, overload

from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    ResourceNotModifiedError,
    map_error,
)
from azure.core.pipeline import PipelineResponse
from azure.core.rest import AsyncHttpResponse, HttpRequest
from azure.core.tracing.decorator_async import distributed_trace_async
from azure.core.utils import case_insensitive_dict

from ...operations._operations import (
    build_admin_add_power_bi_encryption_key_request,
    build_admin_get_activity_events_request,
    build_admin_get_capacities_as_admin_request,
    build_admin_get_power_bi_encryption_keys_request,
    build_admin_get_refreshable_for_capacity_request,
    build_admin_get_refreshables_for_capacity_request,
    build_admin_get_refreshables_request,
    build_admin_patch_capacity_as_admin_request,
    build_admin_rotate_power_bi_encryption_key_request,
    build_apps_get_app_request,
    build_apps_get_app_users_as_admin_request,
    build_apps_get_apps_as_admin_request,
    build_apps_get_apps_request,
    build_apps_get_dashboard_request,
    build_apps_get_dashboards_request,
    build_apps_get_report_request,
    build_apps_get_reports_request,
    build_apps_get_tile_request,
    build_apps_get_tiles_request,
    build_available_features_get_available_feature_by_name_request,
    build_available_features_get_available_features_request,
    build_capacities_assign_workspaces_to_capacity_request,
    build_capacities_get_capacities_request,
    build_capacities_get_capacity_users_as_admin_request,
    build_capacities_get_refreshable_for_capacity_request,
    build_capacities_get_refreshables_for_capacity_request,
    build_capacities_get_refreshables_request,
    build_capacities_get_workload_request,
    build_capacities_get_workloads_request,
    build_capacities_patch_workload_request,
    build_capacities_unassign_workspaces_from_capacity_request,
    build_dashboards_add_dashboard_in_group_request,
    build_dashboards_add_dashboard_request,
    build_dashboards_clone_tile_in_group_request,
    build_dashboards_clone_tile_request,
    build_dashboards_delete_dashboard_in_group_request,
    build_dashboards_delete_dashboard_request,
    build_dashboards_generate_token_in_group_request,
    build_dashboards_get_dashboard_in_group_request,
    build_dashboards_get_dashboard_request,
    build_dashboards_get_dashboard_subscriptions_as_admin_request,
    build_dashboards_get_dashboard_users_as_admin_request,
    build_dashboards_get_dashboards_as_admin_request,
    build_dashboards_get_dashboards_in_group_as_admin_request,
    build_dashboards_get_dashboards_in_group_request,
    build_dashboards_get_dashboards_request,
    build_dashboards_get_tile_in_group_request,
    build_dashboards_get_tile_request,
    build_dashboards_get_tiles_as_admin_request,
    build_dashboards_get_tiles_in_group_request,
    build_dashboards_get_tiles_request,
    build_dataflow_storage_accounts_get_dataflow_storage_accounts_request,
    build_dataflows_cancel_dataflow_transaction_request,
    build_dataflows_delete_dataflow_request,
    build_dataflows_export_dataflow_as_admin_request,
    build_dataflows_get_dataflow_data_sources_request,
    build_dataflows_get_dataflow_datasources_as_admin_request,
    build_dataflows_get_dataflow_request,
    build_dataflows_get_dataflow_transactions_request,
    build_dataflows_get_dataflow_users_as_admin_request,
    build_dataflows_get_dataflows_as_admin_request,
    build_dataflows_get_dataflows_in_group_as_admin_request,
    build_dataflows_get_dataflows_request,
    build_dataflows_get_upstream_dataflows_in_group_as_admin_request,
    build_dataflows_get_upstream_dataflows_in_group_request,
    build_dataflows_refresh_dataflow_request,
    build_dataflows_update_dataflow_request,
    build_dataflows_update_refresh_schedule_request,
    build_datasets_bind_to_gateway_in_group_request,
    build_datasets_bind_to_gateway_request,
    build_datasets_cancel_refresh_in_group_request,
    build_datasets_cancel_refresh_request,
    build_datasets_delete_dataset_in_group_request,
    build_datasets_delete_dataset_request,
    build_datasets_delete_rows_in_group_request,
    build_datasets_delete_rows_request,
    build_datasets_discover_gateways_in_group_request,
    build_datasets_discover_gateways_request,
    build_datasets_execute_queries_in_group_request,
    build_datasets_execute_queries_request,
    build_datasets_generate_token_in_group_request,
    build_datasets_get_dataset_in_group_request,
    build_datasets_get_dataset_request,
    build_datasets_get_dataset_to_dataflows_links_in_group_as_admin_request,
    build_datasets_get_dataset_to_dataflows_links_in_group_request,
    build_datasets_get_dataset_users_as_admin_request,
    build_datasets_get_dataset_users_in_group_request,
    build_datasets_get_dataset_users_request,
    build_datasets_get_datasets_as_admin_request,
    build_datasets_get_datasets_in_group_as_admin_request,
    build_datasets_get_datasets_in_group_request,
    build_datasets_get_datasets_request,
    build_datasets_get_datasources_as_admin_request,
    build_datasets_get_datasources_in_group_request,
    build_datasets_get_datasources_request,
    build_datasets_get_direct_query_refresh_schedule_in_group_request,
    build_datasets_get_direct_query_refresh_schedule_request,
    build_datasets_get_gateway_datasources_in_group_request,
    build_datasets_get_gateway_datasources_request,
    build_datasets_get_parameters_in_group_request,
    build_datasets_get_parameters_request,
    build_datasets_get_query_scale_out_sync_status_in_group_request,
    build_datasets_get_query_scale_out_sync_status_request,
    build_datasets_get_refresh_execution_details_in_group_request,
    build_datasets_get_refresh_execution_details_request,
    build_datasets_get_refresh_history_in_group_request,
    build_datasets_get_refresh_history_request,
    build_datasets_get_refresh_schedule_in_group_request,
    build_datasets_get_refresh_schedule_request,
    build_datasets_get_tables_in_group_request,
    build_datasets_get_tables_request,
    build_datasets_post_dataset_in_group_request,
    build_datasets_post_dataset_request,
    build_datasets_post_dataset_user_in_group_request,
    build_datasets_post_dataset_user_request,
    build_datasets_post_rows_in_group_request,
    build_datasets_post_rows_request,
    build_datasets_put_dataset_user_in_group_request,
    build_datasets_put_dataset_user_request,
    build_datasets_put_table_in_group_request,
    build_datasets_put_table_request,
    build_datasets_refresh_dataset_in_group_request,
    build_datasets_refresh_dataset_request,
    build_datasets_set_all_dataset_connections_in_group_request,
    build_datasets_set_all_dataset_connections_request,
    build_datasets_take_over_in_group_request,
    build_datasets_trigger_query_scale_out_sync_in_group_request,
    build_datasets_trigger_query_scale_out_sync_request,
    build_datasets_update_dataset_in_group_request,
    build_datasets_update_dataset_request,
    build_datasets_update_datasources_in_group_request,
    build_datasets_update_datasources_request,
    build_datasets_update_direct_query_refresh_schedule_in_group_request,
    build_datasets_update_direct_query_refresh_schedule_request,
    build_datasets_update_parameters_in_group_request,
    build_datasets_update_parameters_request,
    build_datasets_update_refresh_schedule_in_group_request,
    build_datasets_update_refresh_schedule_request,
    build_embed_token_generate_token_request,
    build_gateways_add_datasource_user_request,
    build_gateways_create_datasource_request,
    build_gateways_delete_datasource_request,
    build_gateways_delete_datasource_user_request,
    build_gateways_get_datasource_request,
    build_gateways_get_datasource_status_request,
    build_gateways_get_datasource_users_request,
    build_gateways_get_datasources_request,
    build_gateways_get_gateway_request,
    build_gateways_get_gateways_request,
    build_gateways_update_datasource_request,
    build_goal_notes_preview_delete_by_id_request,
    build_goal_notes_preview_patch_by_id_request,
    build_goal_notes_preview_post_request,
    build_goal_values_preview_delete_by_id_request,
    build_goal_values_preview_get_by_id_request,
    build_goal_values_preview_get_request,
    build_goal_values_preview_patch_by_id_request,
    build_goal_values_preview_post_request,
    build_goals_preview_delete_by_id_request,
    build_goals_preview_delete_goal_current_value_connection_request,
    build_goals_preview_delete_goal_target_value_connection_request,
    build_goals_preview_get_by_id_request,
    build_goals_preview_get_refresh_history_request,
    build_goals_preview_get_request,
    build_goals_preview_patch_by_id_request,
    build_goals_preview_post_request,
    build_goals_preview_refresh_goal_current_value_request,
    build_goals_preview_refresh_goal_target_value_request,
    build_goals_status_rules_preview_delete_request,
    build_goals_status_rules_preview_get_request,
    build_goals_status_rules_preview_post_request,
    build_groups_add_group_user_request,
    build_groups_add_user_as_admin_request,
    build_groups_assign_my_workspace_to_capacity_request,
    build_groups_assign_to_capacity_request,
    build_groups_assign_to_dataflow_storage_request,
    build_groups_capacity_assignment_status_my_workspace_request,
    build_groups_capacity_assignment_status_request,
    build_groups_create_group_request,
    build_groups_delete_group_request,
    build_groups_delete_user_as_admin_request,
    build_groups_delete_user_in_group_request,
    build_groups_get_group_as_admin_request,
    build_groups_get_group_users_as_admin_request,
    build_groups_get_group_users_request,
    build_groups_get_groups_as_admin_request,
    build_groups_get_groups_request,
    build_groups_get_unused_artifacts_as_admin_request,
    build_groups_restore_deleted_group_as_admin_request,
    build_groups_update_group_as_admin_request,
    build_groups_update_group_user_request,
    build_imports_create_temporary_upload_location_in_group_request,
    build_imports_create_temporary_upload_location_request,
    build_imports_get_import_in_group_request,
    build_imports_get_import_request,
    build_imports_get_imports_as_admin_request,
    build_imports_get_imports_in_group_request,
    build_imports_get_imports_request,
    build_imports_post_import_in_group_request,
    build_imports_post_import_request,
    build_information_protection_remove_labels_as_admin_request,
    build_information_protection_set_labels_as_admin_request,
    build_pipelines_assign_workspace_request,
    build_pipelines_create_pipeline_request,
    build_pipelines_delete_pipeline_request,
    build_pipelines_delete_pipeline_user_request,
    build_pipelines_delete_user_as_admin_request,
    build_pipelines_deploy_all_request,
    build_pipelines_get_pipeline_operation_request,
    build_pipelines_get_pipeline_operations_request,
    build_pipelines_get_pipeline_request,
    build_pipelines_get_pipeline_stage_artifacts_request,
    build_pipelines_get_pipeline_stages_request,
    build_pipelines_get_pipeline_users_as_admin_request,
    build_pipelines_get_pipeline_users_request,
    build_pipelines_get_pipelines_as_admin_request,
    build_pipelines_get_pipelines_request,
    build_pipelines_selective_deploy_request,
    build_pipelines_unassign_workspace_request,
    build_pipelines_update_pipeline_request,
    build_pipelines_update_pipeline_user_request,
    build_pipelines_update_user_as_admin_request,
    build_profiles_create_profile_request,
    build_profiles_delete_profile_as_admin_request,
    build_profiles_delete_profile_request,
    build_profiles_get_profile_request,
    build_profiles_get_profiles_as_admin_request,
    build_profiles_get_profiles_request,
    build_profiles_update_profile_request,
    build_reports_clone_report_in_group_request,
    build_reports_clone_report_request,
    build_reports_delete_report_in_group_request,
    build_reports_delete_report_request,
    build_reports_export_report_in_group_request,
    build_reports_export_report_request,
    build_reports_export_to_file_in_group_request,
    build_reports_export_to_file_request,
    build_reports_generate_token_for_create_in_group_request,
    build_reports_generate_token_in_group_request,
    build_reports_get_datasources_in_group_request,
    build_reports_get_datasources_request,
    build_reports_get_export_to_file_status_in_group_request,
    build_reports_get_export_to_file_status_request,
    build_reports_get_file_of_export_to_file_in_group_request,
    build_reports_get_file_of_export_to_file_request,
    build_reports_get_page_in_group_request,
    build_reports_get_page_request,
    build_reports_get_pages_in_group_request,
    build_reports_get_pages_request,
    build_reports_get_report_in_group_request,
    build_reports_get_report_request,
    build_reports_get_report_subscriptions_as_admin_request,
    build_reports_get_report_users_as_admin_request,
    build_reports_get_reports_as_admin_request,
    build_reports_get_reports_in_group_as_admin_request,
    build_reports_get_reports_in_group_request,
    build_reports_get_reports_request,
    build_reports_rebind_report_in_group_request,
    build_reports_rebind_report_request,
    build_reports_take_over_in_group_request,
    build_reports_update_datasources_in_group_request,
    build_reports_update_datasources_request,
    build_reports_update_report_content_in_group_request,
    build_reports_update_report_content_request,
    build_scorecards_preview_delete_by_id_request,
    build_scorecards_preview_get_by_id_request,
    build_scorecards_preview_get_request,
    build_scorecards_preview_get_scorecard_by_report_id_request,
    build_scorecards_preview_move_goals_request,
    build_scorecards_preview_patch_by_id_request,
    build_scorecards_preview_post_request,
    build_template_apps_create_install_ticket_request,
    build_tiles_generate_token_in_group_request,
    build_users_get_user_artifact_access_as_admin_request,
    build_users_get_user_subscriptions_as_admin_request,
    build_users_refresh_user_permissions_request,
    build_widely_shared_artifacts_links_shared_to_whole_organization_request,
    build_widely_shared_artifacts_published_to_web_request,
    build_workspace_info_get_modified_workspaces_request,
    build_workspace_info_get_scan_result_request,
    build_workspace_info_get_scan_status_request,
    build_workspace_info_post_workspace_info_request,
)

if sys.version_info >= (3, 9):
    from collections.abc import MutableMapping
else:
    from typing import MutableMapping  # type: ignore  # pylint: disable=ungrouped-imports
JSON = MutableMapping[str, Any]  # pylint: disable=unsubscriptable-object
T = TypeVar("T")
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]


class DatasetsOperations:  # pylint: disable=too-many-public-methods
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~power_bi_client.aio.PowerBIClient`'s
        :attr:`datasets` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get_datasets(self, **kwargs: Any) -> JSON:
        """Returns a list of datasets from **My workspace**.

        Required Scope
        --------------

        Dataset.ReadWrite.All or Dataset.Read.All
        :code:`<br>`:code:`<br>`.

        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional. OData context.
                    "value": [
                        {
                            "id": "str",  # The dataset ID. Required.
                            "ContentProviderType": "str",  # Optional. The content
                              provider type for the dataset.
                            "CreateReportEmbedURL": "str",  # Optional. The dataset
                              create report embed URL.
                            "CreatedDate": "2020-02-20 00:00:00",  # Optional. The
                              dataset creation date and time.
                            "Encryption": {
                                "EncryptionStatus": "str"  # Optional. Dataset
                                  encryption status. Known values are: "Unknown", "NotSupported",
                                  "InSyncWithWorkspace", and "NotInSyncWithWorkspace".
                            },
                            "IsEffectiveIdentityRequired": bool,  # Optional. Whether the
                              dataset requires an effective identity, which you must send in a
                              `GenerateToken </rest/api/power-bi/embed-token/generate-token>`_ API
                              call.
                            "IsEffectiveIdentityRolesRequired": bool,  # Optional.
                              Whether row-level security is defined inside the Power BI .pbix file. If
                              so, you must specify a role.
                            "IsInPlaceSharingEnabled": bool,  # Optional. Whether the
                              dataset can be shared with external users to be consumed in their own
                              tenant.
                            "IsOnPremGatewayRequired": bool,  # Optional. Whether the
                              dataset requires an on-premises data gateway.
                            "IsRefreshable": bool,  # Optional. Whether the dataset is
                              refreshable or not. A Power BI refreshable dataset is a dataset that has
                              been refreshed at least once, or for which a valid refresh schedule
                              exists.
                            "QnaEmbedURL": "str",  # Optional. The dataset Q&A embed URL.
                            "addRowsAPIEnabled": bool,  # Optional. Whether the dataset
                              allows adding new rows.
                            "configuredBy": "str",  # Optional. The dataset owner.
                            "description": "str",  # Optional. The dataset description.
                            "name": "str",  # Optional. The dataset name.
                            "queryScaleOutSettings": {
                                "autoSyncReadOnlyReplicas": bool,  # Optional.
                                  Whether the dataset automatically syncs read-only replicas.
                                "maxReadOnlyReplicas": 0  # Optional. Maximum number
                                  of read-only replicas for the dataset (0-64, -1 for automatic number
                                  of replicas).
                            },
                            "targetStorageMode": "str",  # Optional. The dataset storage
                              mode.
                            "upstreamDataflows": [
                                {
                                    "groupId": "str",  # Optional. The target
                                      group ID.
                                    "targetDataflowId": "str"  # Optional. The
                                      target dataflow ID.
                                }
                            ],
                            "users": [
                                {
                                    "datasetUserAccessRight": "str",  # The
                                      access right that the user has for the dataset (permission
                                      level). Required. Known values are: "None", "Read", "ReadWrite",
                                      "ReadReshare", "ReadWriteReshare", "ReadExplore",
                                      "ReadReshareExplore", "ReadWriteExplore", and
                                      "ReadWriteReshareExplore".
                                    "identifier": "str",  # Identifier of the
                                      principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "displayName": "str",  # Optional. Display
                                      name of the principal.
                                    "emailAddress": "str",  # Optional. Email
                                      address of the user.
                                    "graphId": "str",  # Optional. Identifier of
                                      the principal in Microsoft Graph. Only available for admin APIs.
                                    "profile": {
                                        "id": "str",  # The service principal
                                          profile ID. Required.
                                        "displayName": "str"  # Optional. The
                                          service principal profile name.
                                    },
                                    "userType": "str"  # Optional. Type of the
                                      user.
                                }
                            ],
                            "webUrl": "str"  # Optional. The web URL of the dataset.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_datasets_get_datasets_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def post_dataset(
        self,
        dataset: JSON,
        *,
        default_retention_policy: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Creates a new dataset on **My workspace**.

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------

        This API call only supports **push datasets**. For a complete list of limitations, see `Push
        datasets limitations </power-bi/developer/embedded/push-datasets-limitations>`_.
        :code:`<br>`:code:`<br>`.

        :param dataset: Dataset definition to create. Required.
        :type dataset: JSON
        :keyword default_retention_policy: The default retention policy. Known values are: "None" and
         "basicFIFO". Default value is None.
        :paramtype default_retention_policy: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                dataset = {
                    "name": "str",  # The dataset name. Required.
                    "tables": [
                        {
                            "columns": [
                                {
                                    "dataType": "str",  # The column data type.
                                      Required.
                                    "name": "str",  # The column name. Required.
                                    "dataCategory": "str",  # Optional. Optional.
                                      The string value to be used for the data category which describes
                                      the data within this column.
                                    "formatString": "str",  # Optional. Optional.
                                      The format of the column as specified in `FORMAT_STRING
                                      <https://docs.microsoft.com/analysis-services/multidimensional-models/mdx/mdx-cell-properties-format-string-contents>`_.
                                    "isHidden": bool,  # Optional. Optional.
                                      Whether the column is hidden. The default is ``false``.
                                    "sortByColumn": "str",  # Optional. Optional.
                                      String name of a column in the same table to be used to order the
                                      current column.
                                    "summarizeBy": "str"  # Optional. Optional.
                                      The aggregate function to use for summarizing this column.
                                }
                            ],
                            "name": "str",  # The table name. Required.
                            "description": "str",  # Optional. The table description.
                            "isHidden": bool,  # Optional. Optional. Whether this dataset
                              table is hidden.
                            "measures": [
                                {
                                    "expression": "str",  # A valid DAX
                                      expression. Required.
                                    "name": "str",  # The measure name. Required.
                                    "description": "str",  # Optional. Optional.
                                      The measure description.
                                    "formatString": "str",  # Optional. Optional.
                                      A string describing how the value should be formatted when it's
                                      displayed as specified in `FORMAT_STRING
                                      <https://docs.microsoft.com/analysis-services/multidimensional-models/mdx/mdx-cell-properties-format-string-contents>`_.
                                    "isHidden": bool  # Optional. Optional.
                                      Whether the measure is hidden.
                                }
                            ],
                            "rows": [
                                {
                                    "id": "str"  # Optional. The unique row ID.
                                }
                            ],
                            "source": [
                                {
                                    "expression": "str"  # The source expression.
                                      Required.
                                }
                            ]
                        }
                    ],
                    "datasources": [
                        {
                            "connectionDetails": {
                                "account": "str",  # Optional. The connection
                                  account.
                                "classInfo": "str",  # Optional. The connection class
                                  information.
                                "database": "str",  # Optional. The connection
                                  database.
                                "domain": "str",  # Optional. The connection domain.
                                "emailAddress": "str",  # Optional. The connection
                                  email address.
                                "kind": "str",  # Optional. The connection kind.
                                "loginServer": "str",  # Optional. The connection
                                  login server.
                                "path": "str",  # Optional. The connection path.
                                "server": "str",  # Optional. The connection server.
                                "url": "str"  # Optional. The connection URL.
                            },
                            "connectionString": "str",  # Optional. (Deprecated) The data
                              source connection string. Available only for DirectQuery.
                            "datasourceId": "str",  # Optional. The bound data source ID,
                              which is empty when not bound to a gateway.
                            "datasourceType": "str",  # Optional. The data source type.
                            "gatewayId": "str",  # Optional. The bound gateway ID, which
                              is empty when not bound to a gateway. When using a gateway cluster, the
                              gateway ID refers to the primary (first) gateway in the cluster and is
                              similar to the gateway cluster ID.
                            "name": "str"  # Optional. (Deprecated) The data source name.
                              Available only for DirectQuery.
                        }
                    ],
                    "defaultMode": "str",  # Optional. The dataset mode or type. Known values
                      are: "AsAzure", "AsOnPrem", "Push", "Streaming", and "PushStreaming".
                    "relationships": [
                        {
                            "fromColumn": "str",  # The name of the foreign key column.
                              Required.
                            "fromTable": "str",  # The name of the foreign key table.
                              Required.
                            "name": "str",  # The relationship name and identifier.
                              Required.
                            "toColumn": "str",  # The name of the primary key column.
                              Required.
                            "toTable": "str",  # The name of the primary key table.
                              Required.
                            "crossFilteringBehavior": "OneDirection"  # Optional. Default
                              value is "OneDirection". The filter direction of the relationship. Known
                              values are: "OneDirection", "BothDirections", and "Automatic".
                        }
                    ]
                }

                # response body for status code(s): 201, 202
                response == {
                    "id": "str",  # The dataset ID. Required.
                    "ContentProviderType": "str",  # Optional. The content provider type for the
                      dataset.
                    "CreateReportEmbedURL": "str",  # Optional. The dataset create report embed
                      URL.
                    "CreatedDate": "2020-02-20 00:00:00",  # Optional. The dataset creation date
                      and time.
                    "Encryption": {
                        "EncryptionStatus": "str"  # Optional. Dataset encryption status.
                          Known values are: "Unknown", "NotSupported", "InSyncWithWorkspace", and
                          "NotInSyncWithWorkspace".
                    },
                    "IsEffectiveIdentityRequired": bool,  # Optional. Whether the dataset
                      requires an effective identity, which you must send in a `GenerateToken
                      </rest/api/power-bi/embed-token/generate-token>`_ API call.
                    "IsEffectiveIdentityRolesRequired": bool,  # Optional. Whether row-level
                      security is defined inside the Power BI .pbix file. If so, you must specify a
                      role.
                    "IsInPlaceSharingEnabled": bool,  # Optional. Whether the dataset can be
                      shared with external users to be consumed in their own tenant.
                    "IsOnPremGatewayRequired": bool,  # Optional. Whether the dataset requires an
                      on-premises data gateway.
                    "IsRefreshable": bool,  # Optional. Whether the dataset is refreshable or
                      not. A Power BI refreshable dataset is a dataset that has been refreshed at least
                      once, or for which a valid refresh schedule exists.
                    "QnaEmbedURL": "str",  # Optional. The dataset Q&A embed URL.
                    "addRowsAPIEnabled": bool,  # Optional. Whether the dataset allows adding new
                      rows.
                    "configuredBy": "str",  # Optional. The dataset owner.
                    "description": "str",  # Optional. The dataset description.
                    "name": "str",  # Optional. The dataset name.
                    "queryScaleOutSettings": {
                        "autoSyncReadOnlyReplicas": bool,  # Optional. Whether the dataset
                          automatically syncs read-only replicas.
                        "maxReadOnlyReplicas": 0  # Optional. Maximum number of read-only
                          replicas for the dataset (0-64, -1 for automatic number of replicas).
                    },
                    "targetStorageMode": "str",  # Optional. The dataset storage mode.
                    "upstreamDataflows": [
                        {
                            "groupId": "str",  # Optional. The target group ID.
                            "targetDataflowId": "str"  # Optional. The target dataflow
                              ID.
                        }
                    ],
                    "users": [
                        {
                            "datasetUserAccessRight": "str",  # The access right that the
                              user has for the dataset (permission level). Required. Known values are:
                              "None", "Read", "ReadWrite", "ReadReshare", "ReadWriteReshare",
                              "ReadExplore", "ReadReshareExplore", "ReadWriteExplore", and
                              "ReadWriteReshareExplore".
                            "identifier": "str",  # Identifier of the principal.
                              Required.
                            "principalType": "str",  # The principal type. Required.
                              Known values are: "None", "User", "Group", and "App".
                            "displayName": "str",  # Optional. Display name of the
                              principal.
                            "emailAddress": "str",  # Optional. Email address of the
                              user.
                            "graphId": "str",  # Optional. Identifier of the principal in
                              Microsoft Graph. Only available for admin APIs.
                            "profile": {
                                "id": "str",  # The service principal profile ID.
                                  Required.
                                "displayName": "str"  # Optional. The service
                                  principal profile name.
                            },
                            "userType": "str"  # Optional. Type of the user.
                        }
                    ],
                    "webUrl": "str"  # Optional. The web URL of the dataset.
                }
        """

    @overload
    async def post_dataset(
        self,
        dataset: IO,
        *,
        default_retention_policy: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Creates a new dataset on **My workspace**.

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------

        This API call only supports **push datasets**. For a complete list of limitations, see `Push
        datasets limitations </power-bi/developer/embedded/push-datasets-limitations>`_.
        :code:`<br>`:code:`<br>`.

        :param dataset: Dataset definition to create. Required.
        :type dataset: IO
        :keyword default_retention_policy: The default retention policy. Known values are: "None" and
         "basicFIFO". Default value is None.
        :paramtype default_retention_policy: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201, 202
                response == {
                    "id": "str",  # The dataset ID. Required.
                    "ContentProviderType": "str",  # Optional. The content provider type for the
                      dataset.
                    "CreateReportEmbedURL": "str",  # Optional. The dataset create report embed
                      URL.
                    "CreatedDate": "2020-02-20 00:00:00",  # Optional. The dataset creation date
                      and time.
                    "Encryption": {
                        "EncryptionStatus": "str"  # Optional. Dataset encryption status.
                          Known values are: "Unknown", "NotSupported", "InSyncWithWorkspace", and
                          "NotInSyncWithWorkspace".
                    },
                    "IsEffectiveIdentityRequired": bool,  # Optional. Whether the dataset
                      requires an effective identity, which you must send in a `GenerateToken
                      </rest/api/power-bi/embed-token/generate-token>`_ API call.
                    "IsEffectiveIdentityRolesRequired": bool,  # Optional. Whether row-level
                      security is defined inside the Power BI .pbix file. If so, you must specify a
                      role.
                    "IsInPlaceSharingEnabled": bool,  # Optional. Whether the dataset can be
                      shared with external users to be consumed in their own tenant.
                    "IsOnPremGatewayRequired": bool,  # Optional. Whether the dataset requires an
                      on-premises data gateway.
                    "IsRefreshable": bool,  # Optional. Whether the dataset is refreshable or
                      not. A Power BI refreshable dataset is a dataset that has been refreshed at least
                      once, or for which a valid refresh schedule exists.
                    "QnaEmbedURL": "str",  # Optional. The dataset Q&A embed URL.
                    "addRowsAPIEnabled": bool,  # Optional. Whether the dataset allows adding new
                      rows.
                    "configuredBy": "str",  # Optional. The dataset owner.
                    "description": "str",  # Optional. The dataset description.
                    "name": "str",  # Optional. The dataset name.
                    "queryScaleOutSettings": {
                        "autoSyncReadOnlyReplicas": bool,  # Optional. Whether the dataset
                          automatically syncs read-only replicas.
                        "maxReadOnlyReplicas": 0  # Optional. Maximum number of read-only
                          replicas for the dataset (0-64, -1 for automatic number of replicas).
                    },
                    "targetStorageMode": "str",  # Optional. The dataset storage mode.
                    "upstreamDataflows": [
                        {
                            "groupId": "str",  # Optional. The target group ID.
                            "targetDataflowId": "str"  # Optional. The target dataflow
                              ID.
                        }
                    ],
                    "users": [
                        {
                            "datasetUserAccessRight": "str",  # The access right that the
                              user has for the dataset (permission level). Required. Known values are:
                              "None", "Read", "ReadWrite", "ReadReshare", "ReadWriteReshare",
                              "ReadExplore", "ReadReshareExplore", "ReadWriteExplore", and
                              "ReadWriteReshareExplore".
                            "identifier": "str",  # Identifier of the principal.
                              Required.
                            "principalType": "str",  # The principal type. Required.
                              Known values are: "None", "User", "Group", and "App".
                            "displayName": "str",  # Optional. Display name of the
                              principal.
                            "emailAddress": "str",  # Optional. Email address of the
                              user.
                            "graphId": "str",  # Optional. Identifier of the principal in
                              Microsoft Graph. Only available for admin APIs.
                            "profile": {
                                "id": "str",  # The service principal profile ID.
                                  Required.
                                "displayName": "str"  # Optional. The service
                                  principal profile name.
                            },
                            "userType": "str"  # Optional. Type of the user.
                        }
                    ],
                    "webUrl": "str"  # Optional. The web URL of the dataset.
                }
        """

    @distributed_trace_async
    async def post_dataset(
        self, dataset: Union[JSON, IO], *, default_retention_policy: Optional[str] = None, **kwargs: Any
    ) -> JSON:
        """Creates a new dataset on **My workspace**.

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------

        This API call only supports **push datasets**. For a complete list of limitations, see `Push
        datasets limitations </power-bi/developer/embedded/push-datasets-limitations>`_.
        :code:`<br>`:code:`<br>`.

        :param dataset: Dataset definition to create. Is either a JSON type or a IO type. Required.
        :type dataset: JSON or IO
        :keyword default_retention_policy: The default retention policy. Known values are: "None" and
         "basicFIFO". Default value is None.
        :paramtype default_retention_policy: str
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                dataset = {
                    "name": "str",  # The dataset name. Required.
                    "tables": [
                        {
                            "columns": [
                                {
                                    "dataType": "str",  # The column data type.
                                      Required.
                                    "name": "str",  # The column name. Required.
                                    "dataCategory": "str",  # Optional. Optional.
                                      The string value to be used for the data category which describes
                                      the data within this column.
                                    "formatString": "str",  # Optional. Optional.
                                      The format of the column as specified in `FORMAT_STRING
                                      <https://docs.microsoft.com/analysis-services/multidimensional-models/mdx/mdx-cell-properties-format-string-contents>`_.
                                    "isHidden": bool,  # Optional. Optional.
                                      Whether the column is hidden. The default is ``false``.
                                    "sortByColumn": "str",  # Optional. Optional.
                                      String name of a column in the same table to be used to order the
                                      current column.
                                    "summarizeBy": "str"  # Optional. Optional.
                                      The aggregate function to use for summarizing this column.
                                }
                            ],
                            "name": "str",  # The table name. Required.
                            "description": "str",  # Optional. The table description.
                            "isHidden": bool,  # Optional. Optional. Whether this dataset
                              table is hidden.
                            "measures": [
                                {
                                    "expression": "str",  # A valid DAX
                                      expression. Required.
                                    "name": "str",  # The measure name. Required.
                                    "description": "str",  # Optional. Optional.
                                      The measure description.
                                    "formatString": "str",  # Optional. Optional.
                                      A string describing how the value should be formatted when it's
                                      displayed as specified in `FORMAT_STRING
                                      <https://docs.microsoft.com/analysis-services/multidimensional-models/mdx/mdx-cell-properties-format-string-contents>`_.
                                    "isHidden": bool  # Optional. Optional.
                                      Whether the measure is hidden.
                                }
                            ],
                            "rows": [
                                {
                                    "id": "str"  # Optional. The unique row ID.
                                }
                            ],
                            "source": [
                                {
                                    "expression": "str"  # The source expression.
                                      Required.
                                }
                            ]
                        }
                    ],
                    "datasources": [
                        {
                            "connectionDetails": {
                                "account": "str",  # Optional. The connection
                                  account.
                                "classInfo": "str",  # Optional. The connection class
                                  information.
                                "database": "str",  # Optional. The connection
                                  database.
                                "domain": "str",  # Optional. The connection domain.
                                "emailAddress": "str",  # Optional. The connection
                                  email address.
                                "kind": "str",  # Optional. The connection kind.
                                "loginServer": "str",  # Optional. The connection
                                  login server.
                                "path": "str",  # Optional. The connection path.
                                "server": "str",  # Optional. The connection server.
                                "url": "str"  # Optional. The connection URL.
                            },
                            "connectionString": "str",  # Optional. (Deprecated) The data
                              source connection string. Available only for DirectQuery.
                            "datasourceId": "str",  # Optional. The bound data source ID,
                              which is empty when not bound to a gateway.
                            "datasourceType": "str",  # Optional. The data source type.
                            "gatewayId": "str",  # Optional. The bound gateway ID, which
                              is empty when not bound to a gateway. When using a gateway cluster, the
                              gateway ID refers to the primary (first) gateway in the cluster and is
                              similar to the gateway cluster ID.
                            "name": "str"  # Optional. (Deprecated) The data source name.
                              Available only for DirectQuery.
                        }
                    ],
                    "defaultMode": "str",  # Optional. The dataset mode or type. Known values
                      are: "AsAzure", "AsOnPrem", "Push", "Streaming", and "PushStreaming".
                    "relationships": [
                        {
                            "fromColumn": "str",  # The name of the foreign key column.
                              Required.
                            "fromTable": "str",  # The name of the foreign key table.
                              Required.
                            "name": "str",  # The relationship name and identifier.
                              Required.
                            "toColumn": "str",  # The name of the primary key column.
                              Required.
                            "toTable": "str",  # The name of the primary key table.
                              Required.
                            "crossFilteringBehavior": "OneDirection"  # Optional. Default
                              value is "OneDirection". The filter direction of the relationship. Known
                              values are: "OneDirection", "BothDirections", and "Automatic".
                        }
                    ]
                }

                # response body for status code(s): 201, 202
                response == {
                    "id": "str",  # The dataset ID. Required.
                    "ContentProviderType": "str",  # Optional. The content provider type for the
                      dataset.
                    "CreateReportEmbedURL": "str",  # Optional. The dataset create report embed
                      URL.
                    "CreatedDate": "2020-02-20 00:00:00",  # Optional. The dataset creation date
                      and time.
                    "Encryption": {
                        "EncryptionStatus": "str"  # Optional. Dataset encryption status.
                          Known values are: "Unknown", "NotSupported", "InSyncWithWorkspace", and
                          "NotInSyncWithWorkspace".
                    },
                    "IsEffectiveIdentityRequired": bool,  # Optional. Whether the dataset
                      requires an effective identity, which you must send in a `GenerateToken
                      </rest/api/power-bi/embed-token/generate-token>`_ API call.
                    "IsEffectiveIdentityRolesRequired": bool,  # Optional. Whether row-level
                      security is defined inside the Power BI .pbix file. If so, you must specify a
                      role.
                    "IsInPlaceSharingEnabled": bool,  # Optional. Whether the dataset can be
                      shared with external users to be consumed in their own tenant.
                    "IsOnPremGatewayRequired": bool,  # Optional. Whether the dataset requires an
                      on-premises data gateway.
                    "IsRefreshable": bool,  # Optional. Whether the dataset is refreshable or
                      not. A Power BI refreshable dataset is a dataset that has been refreshed at least
                      once, or for which a valid refresh schedule exists.
                    "QnaEmbedURL": "str",  # Optional. The dataset Q&A embed URL.
                    "addRowsAPIEnabled": bool,  # Optional. Whether the dataset allows adding new
                      rows.
                    "configuredBy": "str",  # Optional. The dataset owner.
                    "description": "str",  # Optional. The dataset description.
                    "name": "str",  # Optional. The dataset name.
                    "queryScaleOutSettings": {
                        "autoSyncReadOnlyReplicas": bool,  # Optional. Whether the dataset
                          automatically syncs read-only replicas.
                        "maxReadOnlyReplicas": 0  # Optional. Maximum number of read-only
                          replicas for the dataset (0-64, -1 for automatic number of replicas).
                    },
                    "targetStorageMode": "str",  # Optional. The dataset storage mode.
                    "upstreamDataflows": [
                        {
                            "groupId": "str",  # Optional. The target group ID.
                            "targetDataflowId": "str"  # Optional. The target dataflow
                              ID.
                        }
                    ],
                    "users": [
                        {
                            "datasetUserAccessRight": "str",  # The access right that the
                              user has for the dataset (permission level). Required. Known values are:
                              "None", "Read", "ReadWrite", "ReadReshare", "ReadWriteReshare",
                              "ReadExplore", "ReadReshareExplore", "ReadWriteExplore", and
                              "ReadWriteReshareExplore".
                            "identifier": "str",  # Identifier of the principal.
                              Required.
                            "principalType": "str",  # The principal type. Required.
                              Known values are: "None", "User", "Group", and "App".
                            "displayName": "str",  # Optional. Display name of the
                              principal.
                            "emailAddress": "str",  # Optional. Email address of the
                              user.
                            "graphId": "str",  # Optional. Identifier of the principal in
                              Microsoft Graph. Only available for admin APIs.
                            "profile": {
                                "id": "str",  # The service principal profile ID.
                                  Required.
                                "displayName": "str"  # Optional. The service
                                  principal profile name.
                            },
                            "userType": "str"  # Optional. Type of the user.
                        }
                    ],
                    "webUrl": "str"  # Optional. The web URL of the dataset.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(dataset, (IOBase, bytes)):
            _content = dataset
        else:
            _json = dataset

        _request = build_datasets_post_dataset_request(
            default_retention_policy=default_retention_policy,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 202]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 202:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_dataset(self, dataset_id: str, **kwargs: Any) -> JSON:
        """Returns the specified dataset from **My workspace**.

        Required Scope
        --------------

        Dataset.ReadWrite.All or Dataset.Read.All
        :code:`<br>`:code:`<br>`.

        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # The dataset ID. Required.
                    "ContentProviderType": "str",  # Optional. The content provider type for the
                      dataset.
                    "CreateReportEmbedURL": "str",  # Optional. The dataset create report embed
                      URL.
                    "CreatedDate": "2020-02-20 00:00:00",  # Optional. The dataset creation date
                      and time.
                    "Encryption": {
                        "EncryptionStatus": "str"  # Optional. Dataset encryption status.
                          Known values are: "Unknown", "NotSupported", "InSyncWithWorkspace", and
                          "NotInSyncWithWorkspace".
                    },
                    "IsEffectiveIdentityRequired": bool,  # Optional. Whether the dataset
                      requires an effective identity, which you must send in a `GenerateToken
                      </rest/api/power-bi/embed-token/generate-token>`_ API call.
                    "IsEffectiveIdentityRolesRequired": bool,  # Optional. Whether row-level
                      security is defined inside the Power BI .pbix file. If so, you must specify a
                      role.
                    "IsInPlaceSharingEnabled": bool,  # Optional. Whether the dataset can be
                      shared with external users to be consumed in their own tenant.
                    "IsOnPremGatewayRequired": bool,  # Optional. Whether the dataset requires an
                      on-premises data gateway.
                    "IsRefreshable": bool,  # Optional. Whether the dataset is refreshable or
                      not. A Power BI refreshable dataset is a dataset that has been refreshed at least
                      once, or for which a valid refresh schedule exists.
                    "QnaEmbedURL": "str",  # Optional. The dataset Q&A embed URL.
                    "addRowsAPIEnabled": bool,  # Optional. Whether the dataset allows adding new
                      rows.
                    "configuredBy": "str",  # Optional. The dataset owner.
                    "description": "str",  # Optional. The dataset description.
                    "name": "str",  # Optional. The dataset name.
                    "queryScaleOutSettings": {
                        "autoSyncReadOnlyReplicas": bool,  # Optional. Whether the dataset
                          automatically syncs read-only replicas.
                        "maxReadOnlyReplicas": 0  # Optional. Maximum number of read-only
                          replicas for the dataset (0-64, -1 for automatic number of replicas).
                    },
                    "targetStorageMode": "str",  # Optional. The dataset storage mode.
                    "upstreamDataflows": [
                        {
                            "groupId": "str",  # Optional. The target group ID.
                            "targetDataflowId": "str"  # Optional. The target dataflow
                              ID.
                        }
                    ],
                    "users": [
                        {
                            "datasetUserAccessRight": "str",  # The access right that the
                              user has for the dataset (permission level). Required. Known values are:
                              "None", "Read", "ReadWrite", "ReadReshare", "ReadWriteReshare",
                              "ReadExplore", "ReadReshareExplore", "ReadWriteExplore", and
                              "ReadWriteReshareExplore".
                            "identifier": "str",  # Identifier of the principal.
                              Required.
                            "principalType": "str",  # The principal type. Required.
                              Known values are: "None", "User", "Group", and "App".
                            "displayName": "str",  # Optional. Display name of the
                              principal.
                            "emailAddress": "str",  # Optional. Email address of the
                              user.
                            "graphId": "str",  # Optional. Identifier of the principal in
                              Microsoft Graph. Only available for admin APIs.
                            "profile": {
                                "id": "str",  # The service principal profile ID.
                                  Required.
                                "displayName": "str"  # Optional. The service
                                  principal profile name.
                            },
                            "userType": "str"  # Optional. Type of the user.
                        }
                    ],
                    "webUrl": "str"  # Optional. The web URL of the dataset.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_datasets_get_dataset_request(
            dataset_id=dataset_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def update_dataset(  # pylint: disable=inconsistent-return-statements
        self, dataset_id: str, update_dataset_request: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Updates the properties for the specified dataset from **My workspace**.

        Permissions
        -----------

        The user must be the dataset owner.

        Required Scope
        --------------

        Dataset.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param update_dataset_request: Update dataset request parameters. Required.
        :type update_dataset_request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                update_dataset_request = {
                    "queryScaleOutSettings": {
                        "autoSyncReadOnlyReplicas": bool,  # Optional. Whether the dataset
                          automatically syncs read-only replicas.
                        "maxReadOnlyReplicas": 0  # Optional. Maximum number of read-only
                          replicas for the dataset (0-64, -1 for automatic number of replicas).
                    },
                    "targetStorageMode": "str"  # Optional. The dataset storage mode.
                }
        """

    @overload
    async def update_dataset(  # pylint: disable=inconsistent-return-statements
        self, dataset_id: str, update_dataset_request: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Updates the properties for the specified dataset from **My workspace**.

        Permissions
        -----------

        The user must be the dataset owner.

        Required Scope
        --------------

        Dataset.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param update_dataset_request: Update dataset request parameters. Required.
        :type update_dataset_request: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_dataset(  # pylint: disable=inconsistent-return-statements
        self, dataset_id: str, update_dataset_request: Union[JSON, IO], **kwargs: Any
    ) -> None:
        """Updates the properties for the specified dataset from **My workspace**.

        Permissions
        -----------

        The user must be the dataset owner.

        Required Scope
        --------------

        Dataset.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param update_dataset_request: Update dataset request parameters. Is either a JSON type or a IO
         type. Required.
        :type update_dataset_request: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                update_dataset_request = {
                    "queryScaleOutSettings": {
                        "autoSyncReadOnlyReplicas": bool,  # Optional. Whether the dataset
                          automatically syncs read-only replicas.
                        "maxReadOnlyReplicas": 0  # Optional. Maximum number of read-only
                          replicas for the dataset (0-64, -1 for automatic number of replicas).
                    },
                    "targetStorageMode": "str"  # Optional. The dataset storage mode.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(update_dataset_request, (IOBase, bytes)):
            _content = update_dataset_request
        else:
            _json = update_dataset_request

        _request = build_datasets_update_dataset_request(
            dataset_id=dataset_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def delete_dataset(  # pylint: disable=inconsistent-return-statements
        self, dataset_id: str, **kwargs: Any
    ) -> None:
        """Deletes the specified dataset from **My workspace**.

        Required Scope
        --------------

        Dataset.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_datasets_delete_dataset_request(
            dataset_id=dataset_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def execute_queries(
        self, dataset_id: str, request_message: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Executes Data Analysis Expressions (DAX) queries against the provided dataset. The dataset must
        reside in **My workspace** or another workspace.

        DAX query errors will result in:


        * A response error, such as ``DAX query failure``.
        * A failure HTTP status code (400).

        A query that requests more than one table, or more than the allowed number of table rows, will
        result in:


        * Limited data being returned.
        * A response error, such as ``More than one result table in a query`` or ``More than {allowed
        number} rows in a query result``.
        * A successful HTTP status code (200).

        Columns that are fully qualified in the query will be returned with a fully qualified name, for
        example, ``MyTable[MyColumn]``. Columns that are renamed or created in the query will be
        returned within square bracket, for example, ``[MyNewColumn]``.

        Permissions
        -----------

        The user must have `Manage dataset access permissions
        </power-bi/connect-data/service-datasets-manage-access-permissions>`_.

        Required Scope
        --------------

        Dataset.ReadWrite.All or Dataset.Read.All

        Limitations
        -----------


        * Datasets that are hosted in Azure Analysis Services or that have a live connection to an
        on-premises Azure Analysis Services model aren't supported.
        * The tenant setting **Dataset Execute Queries REST API**\ , found under **Integration
        settings**\ , must be enabled.
        * One query per API call.
        * One table request per query.
        * Maximum of 100,000 rows or 1,000,000 values per query (whichever is hit first). For example
        if you query for 5 columns, you can get back max 100,000 rows. If you query for 20 columns, you
        can get back max 50,000 rows (1 million divided by 20).
        * Maximum of 15MB of data per query. Once 15MB is exceeded, the current row will be completed
        but no additional rows will be written.
        * Maximum of 120 requests per user per minute. Target dataset does not impact this rate limit.
        * Service Principals aren't supported for datasets with RLS per `RLS limitations
        </power-bi/admin/service-admin-rls#considerations-and-limitations>`_ or with SSO enabled. To
        use Service Principals, make sure the admin tenant setting `\ *Allow service principals to use
        Power BI APIs*
        </power-bi/admin/service-admin-portal-developer#allow-service-principals-to-use-power-bi-apis>`_
        under *Developer settings* is enabled.
        * Only DAX queries are supported at this time. MDX and DMV queries are not supported.
          :code:`<br>`:code:`<br>`.

        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param request_message: The request message. Required.
        :type request_message: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                request_message = {
                    "queries": [
                        {
                            "query": "str"  # The DAX query to be executed. Required.
                        }
                    ],
                    "impersonatedUserName": "str",  # Optional. The UPN of a user to be
                      impersonated. If the model is not RLS enabled, this will be ignored.
                    "serializerSettings": {
                        "includeNulls": bool  # Optional. Whether null (blank) values should
                          be included in the result set. If unspecified, the default value is
                          ``false``.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "error": {
                        "code": "str",  # Optional. The code associated with the error.
                        "message": "str"  # Optional. The message of the error. If not
                          present here, this information my also be found in details object nested
                          under the error object.
                    },
                    "informationProtectionLabel": {
                        "id": "str",  # Optional. The identifier (guid) of the information
                          protection label.
                        "name": "str"  # Optional. The display name of the information
                          protection label.
                    },
                    "results": [
                        {
                            "error": {
                                "code": "str",  # Optional. The code associated with
                                  the error.
                                "message": "str"  # Optional. The message of the
                                  error. If not present here, this information my also be found in
                                  details object nested under the error object.
                            },
                            "tables": [
                                {
                                    "error": {
                                        "code": "str",  # Optional. The code
                                          associated with the error.
                                        "message": "str"  # Optional. The
                                          message of the error. If not present here, this information
                                          my also be found in details object nested under the error
                                          object.
                                    },
                                    "rows": [
                                        {}  # Optional. A list of rows.
                                    ]
                                }
                            ]
                        }
                    ]
                }
        """

    @overload
    async def execute_queries(
        self, dataset_id: str, request_message: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Executes Data Analysis Expressions (DAX) queries against the provided dataset. The dataset must
        reside in **My workspace** or another workspace.

        DAX query errors will result in:


        * A response error, such as ``DAX query failure``.
        * A failure HTTP status code (400).

        A query that requests more than one table, or more than the allowed number of table rows, will
        result in:


        * Limited data being returned.
        * A response error, such as ``More than one result table in a query`` or ``More than {allowed
        number} rows in a query result``.
        * A successful HTTP status code (200).

        Columns that are fully qualified in the query will be returned with a fully qualified name, for
        example, ``MyTable[MyColumn]``. Columns that are renamed or created in the query will be
        returned within square bracket, for example, ``[MyNewColumn]``.

        Permissions
        -----------

        The user must have `Manage dataset access permissions
        </power-bi/connect-data/service-datasets-manage-access-permissions>`_.

        Required Scope
        --------------

        Dataset.ReadWrite.All or Dataset.Read.All

        Limitations
        -----------


        * Datasets that are hosted in Azure Analysis Services or that have a live connection to an
        on-premises Azure Analysis Services model aren't supported.
        * The tenant setting **Dataset Execute Queries REST API**\ , found under **Integration
        settings**\ , must be enabled.
        * One query per API call.
        * One table request per query.
        * Maximum of 100,000 rows or 1,000,000 values per query (whichever is hit first). For example
        if you query for 5 columns, you can get back max 100,000 rows. If you query for 20 columns, you
        can get back max 50,000 rows (1 million divided by 20).
        * Maximum of 15MB of data per query. Once 15MB is exceeded, the current row will be completed
        but no additional rows will be written.
        * Maximum of 120 requests per user per minute. Target dataset does not impact this rate limit.
        * Service Principals aren't supported for datasets with RLS per `RLS limitations
        </power-bi/admin/service-admin-rls#considerations-and-limitations>`_ or with SSO enabled. To
        use Service Principals, make sure the admin tenant setting `\ *Allow service principals to use
        Power BI APIs*
        </power-bi/admin/service-admin-portal-developer#allow-service-principals-to-use-power-bi-apis>`_
        under *Developer settings* is enabled.
        * Only DAX queries are supported at this time. MDX and DMV queries are not supported.
          :code:`<br>`:code:`<br>`.

        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param request_message: The request message. Required.
        :type request_message: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "error": {
                        "code": "str",  # Optional. The code associated with the error.
                        "message": "str"  # Optional. The message of the error. If not
                          present here, this information my also be found in details object nested
                          under the error object.
                    },
                    "informationProtectionLabel": {
                        "id": "str",  # Optional. The identifier (guid) of the information
                          protection label.
                        "name": "str"  # Optional. The display name of the information
                          protection label.
                    },
                    "results": [
                        {
                            "error": {
                                "code": "str",  # Optional. The code associated with
                                  the error.
                                "message": "str"  # Optional. The message of the
                                  error. If not present here, this information my also be found in
                                  details object nested under the error object.
                            },
                            "tables": [
                                {
                                    "error": {
                                        "code": "str",  # Optional. The code
                                          associated with the error.
                                        "message": "str"  # Optional. The
                                          message of the error. If not present here, this information
                                          my also be found in details object nested under the error
                                          object.
                                    },
                                    "rows": [
                                        {}  # Optional. A list of rows.
                                    ]
                                }
                            ]
                        }
                    ]
                }
        """

    @distributed_trace_async
    async def execute_queries(self, dataset_id: str, request_message: Union[JSON, IO], **kwargs: Any) -> JSON:
        """Executes Data Analysis Expressions (DAX) queries against the provided dataset. The dataset must
        reside in **My workspace** or another workspace.

        DAX query errors will result in:


        * A response error, such as ``DAX query failure``.
        * A failure HTTP status code (400).

        A query that requests more than one table, or more than the allowed number of table rows, will
        result in:


        * Limited data being returned.
        * A response error, such as ``More than one result table in a query`` or ``More than {allowed
        number} rows in a query result``.
        * A successful HTTP status code (200).

        Columns that are fully qualified in the query will be returned with a fully qualified name, for
        example, ``MyTable[MyColumn]``. Columns that are renamed or created in the query will be
        returned within square bracket, for example, ``[MyNewColumn]``.

        Permissions
        -----------

        The user must have `Manage dataset access permissions
        </power-bi/connect-data/service-datasets-manage-access-permissions>`_.

        Required Scope
        --------------

        Dataset.ReadWrite.All or Dataset.Read.All

        Limitations
        -----------


        * Datasets that are hosted in Azure Analysis Services or that have a live connection to an
        on-premises Azure Analysis Services model aren't supported.
        * The tenant setting **Dataset Execute Queries REST API**\ , found under **Integration
        settings**\ , must be enabled.
        * One query per API call.
        * One table request per query.
        * Maximum of 100,000 rows or 1,000,000 values per query (whichever is hit first). For example
        if you query for 5 columns, you can get back max 100,000 rows. If you query for 20 columns, you
        can get back max 50,000 rows (1 million divided by 20).
        * Maximum of 15MB of data per query. Once 15MB is exceeded, the current row will be completed
        but no additional rows will be written.
        * Maximum of 120 requests per user per minute. Target dataset does not impact this rate limit.
        * Service Principals aren't supported for datasets with RLS per `RLS limitations
        </power-bi/admin/service-admin-rls#considerations-and-limitations>`_ or with SSO enabled. To
        use Service Principals, make sure the admin tenant setting `\ *Allow service principals to use
        Power BI APIs*
        </power-bi/admin/service-admin-portal-developer#allow-service-principals-to-use-power-bi-apis>`_
        under *Developer settings* is enabled.
        * Only DAX queries are supported at this time. MDX and DMV queries are not supported.
          :code:`<br>`:code:`<br>`.

        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param request_message: The request message. Is either a JSON type or a IO type. Required.
        :type request_message: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                request_message = {
                    "queries": [
                        {
                            "query": "str"  # The DAX query to be executed. Required.
                        }
                    ],
                    "impersonatedUserName": "str",  # Optional. The UPN of a user to be
                      impersonated. If the model is not RLS enabled, this will be ignored.
                    "serializerSettings": {
                        "includeNulls": bool  # Optional. Whether null (blank) values should
                          be included in the result set. If unspecified, the default value is
                          ``false``.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "error": {
                        "code": "str",  # Optional. The code associated with the error.
                        "message": "str"  # Optional. The message of the error. If not
                          present here, this information my also be found in details object nested
                          under the error object.
                    },
                    "informationProtectionLabel": {
                        "id": "str",  # Optional. The identifier (guid) of the information
                          protection label.
                        "name": "str"  # Optional. The display name of the information
                          protection label.
                    },
                    "results": [
                        {
                            "error": {
                                "code": "str",  # Optional. The code associated with
                                  the error.
                                "message": "str"  # Optional. The message of the
                                  error. If not present here, this information my also be found in
                                  details object nested under the error object.
                            },
                            "tables": [
                                {
                                    "error": {
                                        "code": "str",  # Optional. The code
                                          associated with the error.
                                        "message": "str"  # Optional. The
                                          message of the error. If not present here, this information
                                          my also be found in details object nested under the error
                                          object.
                                    },
                                    "rows": [
                                        {}  # Optional. A list of rows.
                                    ]
                                }
                            ]
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(request_message, (IOBase, bytes)):
            _content = request_message
        else:
            _json = request_message

        _request = build_datasets_execute_queries_request(
            dataset_id=dataset_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_tables(self, dataset_id: str, **kwargs: Any) -> JSON:
        """Returns a list of tables within the specified dataset from **My workspace**.

        Required Scope
        --------------

        Dataset.ReadWrite.All or Dataset.Read.All

        Limitations
        -----------

        This API call only supports **push datasets**. For a complete list of limitations, see `Push
        datasets limitations </power-bi/developer/embedded/push-datasets-limitations>`_.
        :code:`<br>`:code:`<br>`.

        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional. OData context.
                    "value": [
                        {
                            "columns": [
                                {
                                    "dataType": "str",  # The column data type.
                                      Required.
                                    "name": "str",  # The column name. Required.
                                    "dataCategory": "str",  # Optional. Optional.
                                      The string value to be used for the data category which describes
                                      the data within this column.
                                    "formatString": "str",  # Optional. Optional.
                                      The format of the column as specified in `FORMAT_STRING
                                      <https://docs.microsoft.com/analysis-services/multidimensional-models/mdx/mdx-cell-properties-format-string-contents>`_.
                                    "isHidden": bool,  # Optional. Optional.
                                      Whether the column is hidden. The default is ``false``.
                                    "sortByColumn": "str",  # Optional. Optional.
                                      String name of a column in the same table to be used to order the
                                      current column.
                                    "summarizeBy": "str"  # Optional. Optional.
                                      The aggregate function to use for summarizing this column.
                                }
                            ],
                            "name": "str",  # The table name. Required.
                            "description": "str",  # Optional. The table description.
                            "isHidden": bool,  # Optional. Optional. Whether this dataset
                              table is hidden.
                            "measures": [
                                {
                                    "expression": "str",  # A valid DAX
                                      expression. Required.
                                    "name": "str",  # The measure name. Required.
                                    "description": "str",  # Optional. Optional.
                                      The measure description.
                                    "formatString": "str",  # Optional. Optional.
                                      A string describing how the value should be formatted when it's
                                      displayed as specified in `FORMAT_STRING
                                      <https://docs.microsoft.com/analysis-services/multidimensional-models/mdx/mdx-cell-properties-format-string-contents>`_.
                                    "isHidden": bool  # Optional. Optional.
                                      Whether the measure is hidden.
                                }
                            ],
                            "rows": [
                                {
                                    "id": "str"  # Optional. The unique row ID.
                                }
                            ],
                            "source": [
                                {
                                    "expression": "str"  # The source expression.
                                      Required.
                                }
                            ]
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_datasets_get_tables_request(
            dataset_id=dataset_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def put_table(
        self,
        dataset_id: str,
        table_name: str,
        request_message: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Updates the metadata and schema for the specified table within the specified dataset from **My
        workspace**.

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------

        This API call only supports **push datasets**.
        :code:`<br>`:code:`<br>`.

        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param table_name: The table name. Required.
        :type table_name: str
        :param request_message: Table name and columns to update existing table. Required.
        :type request_message: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                request_message = {
                    "columns": [
                        {
                            "dataType": "str",  # The column data type. Required.
                            "name": "str",  # The column name. Required.
                            "dataCategory": "str",  # Optional. Optional. The string
                              value to be used for the data category which describes the data within
                              this column.
                            "formatString": "str",  # Optional. Optional. The format of
                              the column as specified in `FORMAT_STRING
                              <https://docs.microsoft.com/analysis-services/multidimensional-models/mdx/mdx-cell-properties-format-string-contents>`_.
                            "isHidden": bool,  # Optional. Optional. Whether the column
                              is hidden. The default is ``false``.
                            "sortByColumn": "str",  # Optional. Optional. String name of
                              a column in the same table to be used to order the current column.
                            "summarizeBy": "str"  # Optional. Optional. The aggregate
                              function to use for summarizing this column.
                        }
                    ],
                    "name": "str",  # The table name. Required.
                    "description": "str",  # Optional. The table description.
                    "isHidden": bool,  # Optional. Optional. Whether this dataset table is
                      hidden.
                    "measures": [
                        {
                            "expression": "str",  # A valid DAX expression. Required.
                            "name": "str",  # The measure name. Required.
                            "description": "str",  # Optional. Optional. The measure
                              description.
                            "formatString": "str",  # Optional. Optional. A string
                              describing how the value should be formatted when it's displayed as
                              specified in `FORMAT_STRING
                              <https://docs.microsoft.com/analysis-services/multidimensional-models/mdx/mdx-cell-properties-format-string-contents>`_.
                            "isHidden": bool  # Optional. Optional. Whether the measure
                              is hidden.
                        }
                    ],
                    "rows": [
                        {
                            "id": "str"  # Optional. The unique row ID.
                        }
                    ],
                    "source": [
                        {
                            "expression": "str"  # The source expression. Required.
                        }
                    ]
                }

                # response body for status code(s): 200
                response == {
                    "columns": [
                        {
                            "dataType": "str",  # The column data type. Required.
                            "name": "str",  # The column name. Required.
                            "dataCategory": "str",  # Optional. Optional. The string
                              value to be used for the data category which describes the data within
                              this column.
                            "formatString": "str",  # Optional. Optional. The format of
                              the column as specified in `FORMAT_STRING
                              <https://docs.microsoft.com/analysis-services/multidimensional-models/mdx/mdx-cell-properties-format-string-contents>`_.
                            "isHidden": bool,  # Optional. Optional. Whether the column
                              is hidden. The default is ``false``.
                            "sortByColumn": "str",  # Optional. Optional. String name of
                              a column in the same table to be used to order the current column.
                            "summarizeBy": "str"  # Optional. Optional. The aggregate
                              function to use for summarizing this column.
                        }
                    ],
                    "name": "str",  # The table name. Required.
                    "description": "str",  # Optional. The table description.
                    "isHidden": bool,  # Optional. Optional. Whether this dataset table is
                      hidden.
                    "measures": [
                        {
                            "expression": "str",  # A valid DAX expression. Required.
                            "name": "str",  # The measure name. Required.
                            "description": "str",  # Optional. Optional. The measure
                              description.
                            "formatString": "str",  # Optional. Optional. A string
                              describing how the value should be formatted when it's displayed as
                              specified in `FORMAT_STRING
                              <https://docs.microsoft.com/analysis-services/multidimensional-models/mdx/mdx-cell-properties-format-string-contents>`_.
                            "isHidden": bool  # Optional. Optional. Whether the measure
                              is hidden.
                        }
                    ],
                    "rows": [
                        {
                            "id": "str"  # Optional. The unique row ID.
                        }
                    ],
                    "source": [
                        {
                            "expression": "str"  # The source expression. Required.
                        }
                    ]
                }
        """

    @overload
    async def put_table(
        self,
        dataset_id: str,
        table_name: str,
        request_message: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Updates the metadata and schema for the specified table within the specified dataset from **My
        workspace**.

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------

        This API call only supports **push datasets**.
        :code:`<br>`:code:`<br>`.

        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param table_name: The table name. Required.
        :type table_name: str
        :param request_message: Table name and columns to update existing table. Required.
        :type request_message: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "columns": [
                        {
                            "dataType": "str",  # The column data type. Required.
                            "name": "str",  # The column name. Required.
                            "dataCategory": "str",  # Optional. Optional. The string
                              value to be used for the data category which describes the data within
                              this column.
                            "formatString": "str",  # Optional. Optional. The format of
                              the column as specified in `FORMAT_STRING
                              <https://docs.microsoft.com/analysis-services/multidimensional-models/mdx/mdx-cell-properties-format-string-contents>`_.
                            "isHidden": bool,  # Optional. Optional. Whether the column
                              is hidden. The default is ``false``.
                            "sortByColumn": "str",  # Optional. Optional. String name of
                              a column in the same table to be used to order the current column.
                            "summarizeBy": "str"  # Optional. Optional. The aggregate
                              function to use for summarizing this column.
                        }
                    ],
                    "name": "str",  # The table name. Required.
                    "description": "str",  # Optional. The table description.
                    "isHidden": bool,  # Optional. Optional. Whether this dataset table is
                      hidden.
                    "measures": [
                        {
                            "expression": "str",  # A valid DAX expression. Required.
                            "name": "str",  # The measure name. Required.
                            "description": "str",  # Optional. Optional. The measure
                              description.
                            "formatString": "str",  # Optional. Optional. A string
                              describing how the value should be formatted when it's displayed as
                              specified in `FORMAT_STRING
                              <https://docs.microsoft.com/analysis-services/multidimensional-models/mdx/mdx-cell-properties-format-string-contents>`_.
                            "isHidden": bool  # Optional. Optional. Whether the measure
                              is hidden.
                        }
                    ],
                    "rows": [
                        {
                            "id": "str"  # Optional. The unique row ID.
                        }
                    ],
                    "source": [
                        {
                            "expression": "str"  # The source expression. Required.
                        }
                    ]
                }
        """

    @distributed_trace_async
    async def put_table(
        self, dataset_id: str, table_name: str, request_message: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Updates the metadata and schema for the specified table within the specified dataset from **My
        workspace**.

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------

        This API call only supports **push datasets**.
        :code:`<br>`:code:`<br>`.

        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param table_name: The table name. Required.
        :type table_name: str
        :param request_message: Table name and columns to update existing table. Is either a JSON type
         or a IO type. Required.
        :type request_message: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                request_message = {
                    "columns": [
                        {
                            "dataType": "str",  # The column data type. Required.
                            "name": "str",  # The column name. Required.
                            "dataCategory": "str",  # Optional. Optional. The string
                              value to be used for the data category which describes the data within
                              this column.
                            "formatString": "str",  # Optional. Optional. The format of
                              the column as specified in `FORMAT_STRING
                              <https://docs.microsoft.com/analysis-services/multidimensional-models/mdx/mdx-cell-properties-format-string-contents>`_.
                            "isHidden": bool,  # Optional. Optional. Whether the column
                              is hidden. The default is ``false``.
                            "sortByColumn": "str",  # Optional. Optional. String name of
                              a column in the same table to be used to order the current column.
                            "summarizeBy": "str"  # Optional. Optional. The aggregate
                              function to use for summarizing this column.
                        }
                    ],
                    "name": "str",  # The table name. Required.
                    "description": "str",  # Optional. The table description.
                    "isHidden": bool,  # Optional. Optional. Whether this dataset table is
                      hidden.
                    "measures": [
                        {
                            "expression": "str",  # A valid DAX expression. Required.
                            "name": "str",  # The measure name. Required.
                            "description": "str",  # Optional. Optional. The measure
                              description.
                            "formatString": "str",  # Optional. Optional. A string
                              describing how the value should be formatted when it's displayed as
                              specified in `FORMAT_STRING
                              <https://docs.microsoft.com/analysis-services/multidimensional-models/mdx/mdx-cell-properties-format-string-contents>`_.
                            "isHidden": bool  # Optional. Optional. Whether the measure
                              is hidden.
                        }
                    ],
                    "rows": [
                        {
                            "id": "str"  # Optional. The unique row ID.
                        }
                    ],
                    "source": [
                        {
                            "expression": "str"  # The source expression. Required.
                        }
                    ]
                }

                # response body for status code(s): 200
                response == {
                    "columns": [
                        {
                            "dataType": "str",  # The column data type. Required.
                            "name": "str",  # The column name. Required.
                            "dataCategory": "str",  # Optional. Optional. The string
                              value to be used for the data category which describes the data within
                              this column.
                            "formatString": "str",  # Optional. Optional. The format of
                              the column as specified in `FORMAT_STRING
                              <https://docs.microsoft.com/analysis-services/multidimensional-models/mdx/mdx-cell-properties-format-string-contents>`_.
                            "isHidden": bool,  # Optional. Optional. Whether the column
                              is hidden. The default is ``false``.
                            "sortByColumn": "str",  # Optional. Optional. String name of
                              a column in the same table to be used to order the current column.
                            "summarizeBy": "str"  # Optional. Optional. The aggregate
                              function to use for summarizing this column.
                        }
                    ],
                    "name": "str",  # The table name. Required.
                    "description": "str",  # Optional. The table description.
                    "isHidden": bool,  # Optional. Optional. Whether this dataset table is
                      hidden.
                    "measures": [
                        {
                            "expression": "str",  # A valid DAX expression. Required.
                            "name": "str",  # The measure name. Required.
                            "description": "str",  # Optional. Optional. The measure
                              description.
                            "formatString": "str",  # Optional. Optional. A string
                              describing how the value should be formatted when it's displayed as
                              specified in `FORMAT_STRING
                              <https://docs.microsoft.com/analysis-services/multidimensional-models/mdx/mdx-cell-properties-format-string-contents>`_.
                            "isHidden": bool  # Optional. Optional. Whether the measure
                              is hidden.
                        }
                    ],
                    "rows": [
                        {
                            "id": "str"  # Optional. The unique row ID.
                        }
                    ],
                    "source": [
                        {
                            "expression": "str"  # The source expression. Required.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(request_message, (IOBase, bytes)):
            _content = request_message
        else:
            _json = request_message

        _request = build_datasets_put_table_request(
            dataset_id=dataset_id,
            table_name=table_name,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def post_rows(  # pylint: disable=inconsistent-return-statements
        self,
        dataset_id: str,
        table_name: str,
        request_message: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Adds new data rows to the specified table within the specified dataset from **My workspace**.

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------


        * This API call only supports **push datasets**.
        * See `Power BI REST API limitations
        </power-bi/developer/automation/api-rest-api-limitations>`_.
          :code:`<br>`:code:`<br>`.

        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param table_name: The table name. Required.
        :type table_name: str
        :param request_message: The request message. Required.
        :type request_message: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                request_message = {
                    "rows": [
                        {}  # Optional. An array of data rows pushed to a dataset table. Each
                          element is a collection of properties represented using key-value format.
                    ]
                }
        """

    @overload
    async def post_rows(  # pylint: disable=inconsistent-return-statements
        self,
        dataset_id: str,
        table_name: str,
        request_message: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Adds new data rows to the specified table within the specified dataset from **My workspace**.

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------


        * This API call only supports **push datasets**.
        * See `Power BI REST API limitations
        </power-bi/developer/automation/api-rest-api-limitations>`_.
          :code:`<br>`:code:`<br>`.

        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param table_name: The table name. Required.
        :type table_name: str
        :param request_message: The request message. Required.
        :type request_message: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def post_rows(  # pylint: disable=inconsistent-return-statements
        self, dataset_id: str, table_name: str, request_message: Union[JSON, IO], **kwargs: Any
    ) -> None:
        """Adds new data rows to the specified table within the specified dataset from **My workspace**.

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------


        * This API call only supports **push datasets**.
        * See `Power BI REST API limitations
        </power-bi/developer/automation/api-rest-api-limitations>`_.
          :code:`<br>`:code:`<br>`.

        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param table_name: The table name. Required.
        :type table_name: str
        :param request_message: The request message. Is either a JSON type or a IO type. Required.
        :type request_message: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                request_message = {
                    "rows": [
                        {}  # Optional. An array of data rows pushed to a dataset table. Each
                          element is a collection of properties represented using key-value format.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(request_message, (IOBase, bytes)):
            _content = request_message
        else:
            _json = request_message

        _request = build_datasets_post_rows_request(
            dataset_id=dataset_id,
            table_name=table_name,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def delete_rows(  # pylint: disable=inconsistent-return-statements
        self, dataset_id: str, table_name: str, **kwargs: Any
    ) -> None:
        """Deletes all rows from the specified table within the specified dataset from **My workspace**.

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------

        This API call only supports **push datasets**. For a complete list of limitations, see `Push
        datasets limitations </power-bi/developer/embedded/push-datasets-limitations>`_.
        :code:`<br>`:code:`<br>`.

        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param table_name: The table name. Required.
        :type table_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_datasets_delete_rows_request(
            dataset_id=dataset_id,
            table_name=table_name,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get_refresh_history(self, dataset_id: str, *, top: Optional[int] = None, **kwargs: Any) -> JSON:
        """Returns the refresh history for the specified dataset from **My workspace**.

        Required Scope
        --------------

        Dataset.ReadWrite.All or Dataset.Read.All

        Limitations
        -----------

        OneDrive refresh history isn't returned.
        :code:`<br>`:code:`<br>`.

        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :keyword top: The requested number of entries in the refresh history. If not provided, the
         default is the last available 60 entries. Default value is None.
        :paramtype top: int
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional.
                    "value": [
                        {
                            "endTime": "2020-02-20 00:00:00",  # Optional. The end date
                              and time of the refresh (may be empty if a refresh is in progress).
                            "refreshType": "str",  # Optional. The type of refresh
                              request. Known values are: "Scheduled", "OnDemand", "ViaApi",
                              "ViaXmlaEndpoint", "ViaEnhancedApi", and "OnDemandTraining".
                            "requestId": "str",  # Optional. The identifier of the
                              refresh request. Provide this identifier in all service requests.
                            "serviceExceptionJson": "str",  # Optional. Failure error
                              code in JSON format (empty if no error).
                            "startTime": "2020-02-20 00:00:00",  # Optional. The start
                              date and time of the refresh.
                            "status": "str"  # Optional. * ``Unknown`` if the completion
                              state is unknown or a refresh is in progress. * ``Completed`` for a
                              successfully completed refresh. * ``Failed`` for an unsuccessful refresh
                              ("" ``serviceExceptionJson`` will contain the error code). * ``Disabled``
                              if the refresh is disabled by a selective refresh.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_datasets_get_refresh_history_request(
            dataset_id=dataset_id,
            top=top,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def refresh_dataset(  # pylint: disable=inconsistent-return-statements
        self,
        dataset_id: str,
        dataset_refresh_request: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Triggers a refresh for the specified dataset from **My workspace**. An `enhanced refresh
        </power-bi/connect-data/asynchronous-refresh>`_ is triggered only if a request payload other
        than ``notifyOption`` is set.

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------


        * For Shared capacities, a maximum of eight requests per day, including refreshes executed by
        using scheduled refresh, can be initiated.
        * For Shared capacities, only ``notifyOption`` can be specified in the request body.
        * Enhanced refresh is not supported for shared capacities.
        * For enhanced refresh, ``notifyOption`` is not required and must be excluded from the request
        body. However, one or more parameters other than ``notifyOption`` are required.
        * For Premium capacities, the maximum requests per day is only limited by the available
        resources in the capacity. If available resources are overloaded, refreshes are throttled until
        the load is reduced. The refresh will fail if throttling exceeds 1 hour.
          :code:`<br>`:code:`<br>`.

        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param dataset_refresh_request: Default value is None.
        :type dataset_refresh_request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                dataset_refresh_request = {
                    "notifyOption": "str",  # Mail notification options. This parameter is not
                      applicable to enhanced refreshes or API operations with a service principal.
                      Required. Known values are: "NoNotification", "MailOnFailure", and
                      "MailOnCompletion".
                    "applyRefreshPolicy": bool,  # Optional. Determine if the policy is applied
                      or not.
                    "commitMode": "str",  # Optional. Determines if objects will be committed in
                      batches or only when complete. Known values are: "Transactional" and
                      "PartialBatch".
                    "effectiveDate": "2020-02-20 00:00:00",  # Optional. If an incremental
                      refresh policy is applied, the ``effectiveDate`` parameter overrides the current
                      date.
                    "maxParallelism": 0,  # Optional. The maximum number of threads on which to
                      run parallel processing commands.
                    "objects": [
                        {
                            "partition": "str",  # Optional. Partition to refresh.
                            "table": "str"  # Optional. Table to refresh.
                        }
                    ],
                    "retryCount": 0,  # Optional. Number of times the operation will retry before
                      failing.
                    "type": "str"  # Optional. The type of processing to perform. Known values
                      are: "Full", "ClearValues", "Calculate", "DataOnly", "Automatic", and
                      "Defragment".
                }
        """

    @overload
    async def refresh_dataset(  # pylint: disable=inconsistent-return-statements
        self,
        dataset_id: str,
        dataset_refresh_request: Optional[IO] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Triggers a refresh for the specified dataset from **My workspace**. An `enhanced refresh
        </power-bi/connect-data/asynchronous-refresh>`_ is triggered only if a request payload other
        than ``notifyOption`` is set.

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------


        * For Shared capacities, a maximum of eight requests per day, including refreshes executed by
        using scheduled refresh, can be initiated.
        * For Shared capacities, only ``notifyOption`` can be specified in the request body.
        * Enhanced refresh is not supported for shared capacities.
        * For enhanced refresh, ``notifyOption`` is not required and must be excluded from the request
        body. However, one or more parameters other than ``notifyOption`` are required.
        * For Premium capacities, the maximum requests per day is only limited by the available
        resources in the capacity. If available resources are overloaded, refreshes are throttled until
        the load is reduced. The refresh will fail if throttling exceeds 1 hour.
          :code:`<br>`:code:`<br>`.

        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param dataset_refresh_request: Default value is None.
        :type dataset_refresh_request: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def refresh_dataset(  # pylint: disable=inconsistent-return-statements
        self, dataset_id: str, dataset_refresh_request: Optional[Union[JSON, IO]] = None, **kwargs: Any
    ) -> None:
        """Triggers a refresh for the specified dataset from **My workspace**. An `enhanced refresh
        </power-bi/connect-data/asynchronous-refresh>`_ is triggered only if a request payload other
        than ``notifyOption`` is set.

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------


        * For Shared capacities, a maximum of eight requests per day, including refreshes executed by
        using scheduled refresh, can be initiated.
        * For Shared capacities, only ``notifyOption`` can be specified in the request body.
        * Enhanced refresh is not supported for shared capacities.
        * For enhanced refresh, ``notifyOption`` is not required and must be excluded from the request
        body. However, one or more parameters other than ``notifyOption`` are required.
        * For Premium capacities, the maximum requests per day is only limited by the available
        resources in the capacity. If available resources are overloaded, refreshes are throttled until
        the load is reduced. The refresh will fail if throttling exceeds 1 hour.
          :code:`<br>`:code:`<br>`.

        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param dataset_refresh_request: Is either a JSON type or a IO type. Default value is None.
        :type dataset_refresh_request: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                dataset_refresh_request = {
                    "notifyOption": "str",  # Mail notification options. This parameter is not
                      applicable to enhanced refreshes or API operations with a service principal.
                      Required. Known values are: "NoNotification", "MailOnFailure", and
                      "MailOnCompletion".
                    "applyRefreshPolicy": bool,  # Optional. Determine if the policy is applied
                      or not.
                    "commitMode": "str",  # Optional. Determines if objects will be committed in
                      batches or only when complete. Known values are: "Transactional" and
                      "PartialBatch".
                    "effectiveDate": "2020-02-20 00:00:00",  # Optional. If an incremental
                      refresh policy is applied, the ``effectiveDate`` parameter overrides the current
                      date.
                    "maxParallelism": 0,  # Optional. The maximum number of threads on which to
                      run parallel processing commands.
                    "objects": [
                        {
                            "partition": "str",  # Optional. Partition to refresh.
                            "table": "str"  # Optional. Table to refresh.
                        }
                    ],
                    "retryCount": 0,  # Optional. Number of times the operation will retry before
                      failing.
                    "type": "str"  # Optional. The type of processing to perform. Known values
                      are: "Full", "ClearValues", "Calculate", "DataOnly", "Automatic", and
                      "Defragment".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(dataset_refresh_request, (IOBase, bytes)):
            _content = dataset_refresh_request
        else:
            if dataset_refresh_request is not None:
                _json = dataset_refresh_request
            else:
                _json = None

        _request = build_datasets_refresh_dataset_request(
            dataset_id=dataset_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace_async
    async def get_refresh_execution_details(self, dataset_id: str, refresh_id: str, **kwargs: Any) -> JSON:
        """Returns execution details of an `enhanced refresh operation
        </power-bi/connect-data/asynchronous-refresh>`_ for the specified dataset from **My
        workspace**.

        Required Scope
        --------------

        Dataset.ReadWrite.All or Dataset.Read.All
        :code:`<br>`:code:`<br>`.

        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param refresh_id: The refresh ID. Required.
        :type refresh_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 202
                response == {
                    "commitMode": "str",  # Optional. Determines if objects will be committed in
                      batches or only when complete. Known values are: "Transactional" and
                      "PartialBatch".
                    "currentRefreshType": "str",  # Optional. The type of processing for the
                      current iteration. This is useful when ``commitMode`` is set to ``PartialBatch``.
                      Known values are: "Full", "ClearValues", "Calculate", "DataOnly", "Automatic",
                      and "Defragment".
                    "endTime": "2020-02-20 00:00:00",  # Optional. The end date and time of the
                      refresh (may be empty if a refresh is in progress).
                    "extendedStatus": "str",  # Optional. Dataset operation detailed status.
                      Known values are: "Unknown", "NotStarted", "InProgress", "Completed", "TimedOut",
                      "Failed", "Disabled", and "Cancelled".
                    "messages": [
                        {
                            "code": "str",  # Optional. The error code in hex format.
                            "message": "str",  # Optional. The text of error or warning
                              message.
                            "type": "str"  # Optional. The type of the error. Known
                              values are: "Error" and "Warning".
                        }
                    ],
                    "numberOfAttempts": 0,  # Optional. The number of attempts for the refresh
                      request.
                    "objects": [
                        {
                            "partition": "str",  # Optional. Partition to refresh.
                            "table": "str"  # Optional. Table to refresh.
                        }
                    ],
                    "startTime": "2020-02-20 00:00:00",  # Optional. The start date and time of
                      the refresh.
                    "status": "str",  # Optional. Dataset operation general status. Known values
                      are: "Unknown", "Completed", "Failed", and "Disabled".
                    "type": "str"  # Optional. The type of processing to perform. Known values
                      are: "Full", "ClearValues", "Calculate", "DataOnly", "Automatic", and
                      "Defragment".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_datasets_get_refresh_execution_details_request(
            dataset_id=dataset_id,
            refresh_id=refresh_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 202:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def cancel_refresh(  # pylint: disable=inconsistent-return-statements
        self, dataset_id: str, refresh_id: str, **kwargs: Any
    ) -> None:
        """Cancels the specified refresh operation for the specified dataset from **My workspace**.

        Required Scope
        --------------

        Dataset.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param refresh_id: The refresh ID. Required.
        :type refresh_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_datasets_cancel_refresh_request(
            dataset_id=dataset_id,
            refresh_id=refresh_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get_refresh_schedule(self, dataset_id: str, **kwargs: Any) -> JSON:
        """Returns the refresh schedule for the specified dataset from **My workspace**.

        Required Scope
        --------------

        Dataset.ReadWrite.All or Dataset.Read.All
        :code:`<br>`:code:`<br>`.

        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "NotifyOption": "str",  # Optional. The notification option on termination of
                      a scheduled refresh. Service principals only support the ``NoNotification``
                      value. Known values are: "NoNotification" and "MailOnFailure".
                    "days": [
                        "str"  # Optional. The days on which to execute the refresh.
                    ],
                    "enabled": bool,  # Optional. Whether the refresh is enabled.
                    "localTimeZoneId": "str",  # Optional. The ID of the time zone to use. For
                      more information, see `Time zone info </dotnet/api/system.timezoneinfo.id>`_.
                    "times": [
                        "str"  # Optional. The times of day to execute the refresh.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_datasets_get_refresh_schedule_request(
            dataset_id=dataset_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def update_refresh_schedule(  # pylint: disable=inconsistent-return-statements
        self,
        dataset_id: str,
        dataset_model_refresh_schedule_request: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Updates the refresh schedule for the specified dataset from **My workspace**.

        A request that disables the refresh schedule should contain no other changes.

        At least one day must be specified. If no times are specified, then Power BI will use a default
        single time per day.

        Permissions
        -----------

        The user must be the dataset owner.

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------

        The limit on the number of time slots per day depends on whether a `Premium
        </power-bi/admin/service-premium-what-is>`_ or Shared capacity is used.
        :code:`<br>`:code:`<br>`.

        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param dataset_model_refresh_schedule_request: Update Refresh Schedule parameters, by
         specifying all or some of the parameters. Required.
        :type dataset_model_refresh_schedule_request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                dataset_model_refresh_schedule_request = {
                    "value": {
                        "NotifyOption": "str",  # Optional. The notification option on
                          termination of a scheduled refresh. Service principals only support the
                          ``NoNotification`` value. Known values are: "NoNotification" and
                          "MailOnFailure".
                        "days": [
                            "str"  # Optional. The days on which to execute the refresh.
                        ],
                        "enabled": bool,  # Optional. Whether the refresh is enabled.
                        "localTimeZoneId": "str",  # Optional. The ID of the time zone to
                          use. For more information, see `Time zone info
                          </dotnet/api/system.timezoneinfo.id>`_.
                        "times": [
                            "str"  # Optional. The times of day to execute the refresh.
                        ]
                    }
                }
        """

    @overload
    async def update_refresh_schedule(  # pylint: disable=inconsistent-return-statements
        self,
        dataset_id: str,
        dataset_model_refresh_schedule_request: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Updates the refresh schedule for the specified dataset from **My workspace**.

        A request that disables the refresh schedule should contain no other changes.

        At least one day must be specified. If no times are specified, then Power BI will use a default
        single time per day.

        Permissions
        -----------

        The user must be the dataset owner.

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------

        The limit on the number of time slots per day depends on whether a `Premium
        </power-bi/admin/service-premium-what-is>`_ or Shared capacity is used.
        :code:`<br>`:code:`<br>`.

        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param dataset_model_refresh_schedule_request: Update Refresh Schedule parameters, by
         specifying all or some of the parameters. Required.
        :type dataset_model_refresh_schedule_request: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_refresh_schedule(  # pylint: disable=inconsistent-return-statements
        self, dataset_id: str, dataset_model_refresh_schedule_request: Union[JSON, IO], **kwargs: Any
    ) -> None:
        """Updates the refresh schedule for the specified dataset from **My workspace**.

        A request that disables the refresh schedule should contain no other changes.

        At least one day must be specified. If no times are specified, then Power BI will use a default
        single time per day.

        Permissions
        -----------

        The user must be the dataset owner.

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------

        The limit on the number of time slots per day depends on whether a `Premium
        </power-bi/admin/service-premium-what-is>`_ or Shared capacity is used.
        :code:`<br>`:code:`<br>`.

        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param dataset_model_refresh_schedule_request: Update Refresh Schedule parameters, by
         specifying all or some of the parameters. Is either a JSON type or a IO type. Required.
        :type dataset_model_refresh_schedule_request: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                dataset_model_refresh_schedule_request = {
                    "value": {
                        "NotifyOption": "str",  # Optional. The notification option on
                          termination of a scheduled refresh. Service principals only support the
                          ``NoNotification`` value. Known values are: "NoNotification" and
                          "MailOnFailure".
                        "days": [
                            "str"  # Optional. The days on which to execute the refresh.
                        ],
                        "enabled": bool,  # Optional. Whether the refresh is enabled.
                        "localTimeZoneId": "str",  # Optional. The ID of the time zone to
                          use. For more information, see `Time zone info
                          </dotnet/api/system.timezoneinfo.id>`_.
                        "times": [
                            "str"  # Optional. The times of day to execute the refresh.
                        ]
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(dataset_model_refresh_schedule_request, (IOBase, bytes)):
            _content = dataset_model_refresh_schedule_request
        else:
            _json = dataset_model_refresh_schedule_request

        _request = build_datasets_update_refresh_schedule_request(
            dataset_id=dataset_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get_direct_query_refresh_schedule(self, dataset_id: str, **kwargs: Any) -> JSON:
        """Returns the refresh schedule for a specified `DirectQuery
        </power-bi/connect-data/desktop-directquery-about>`_ or `LiveConnection
        </power-bi/connect-data/desktop-directquery-about#live-connections>`_ dataset from **My
        workspace**.

        Required Scope
        --------------

        Dataset.ReadWrite.All or Dataset.Read.All
        :code:`<br>`:code:`<br>`.

        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "days": [
                        "str"  # Optional. The days on which to execute the refresh.
                    ],
                    "frequency": 0,  # Optional. The interval in minutes between successive
                      refreshes. Supported values are *15*"" , *30*"" , *60*"" , *120*"" , and *180*.
                    "localTimeZoneId": "str",  # Optional. The ID of the time zone to use. For
                      more information, see `Time zone info </dotnet/api/system.timezoneinfo.id>`_.
                    "times": [
                        "str"  # Optional. The times of day to execute the refresh.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_datasets_get_direct_query_refresh_schedule_request(
            dataset_id=dataset_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def update_direct_query_refresh_schedule(  # pylint: disable=inconsistent-return-statements
        self,
        dataset_id: str,
        dataset_dq_refresh_schedule_request: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Updates the refresh schedule for a specified `DirectQuery
        </power-bi/connect-data/desktop-directquery-about>`_ or `LiveConnection
        </power-bi/connect-data/desktop-directquery-about#live-connections>`_ dataset from **My
        workspace**.

        A request should contain either a set of days and times *or* a valid frequency, but not both.
        If you choose a set of days without specifying any times, then Power BI will use a default
        single time per day. Setting the frequency will automatically overwrite the days and times
        setting.

        Permissions
        -----------

        The user must be the dataset owner.

        Required Scope
        --------------

        Dataset.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param dataset_dq_refresh_schedule_request: Patch DirectQuery or LiveConnection Refresh
         Schedule parameters, by specifying all or some of the parameters. Required.
        :type dataset_dq_refresh_schedule_request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                dataset_dq_refresh_schedule_request = {
                    "value": {
                        "days": [
                            "str"  # Optional. The days on which to execute the refresh.
                        ],
                        "frequency": 0,  # Optional. The interval in minutes between
                          successive refreshes. Supported values are *15*"" , *30*"" , *60*"" , *120*""
                          , and *180*.
                        "localTimeZoneId": "str",  # Optional. The ID of the time zone to
                          use. For more information, see `Time zone info
                          </dotnet/api/system.timezoneinfo.id>`_.
                        "times": [
                            "str"  # Optional. The times of day to execute the refresh.
                        ]
                    }
                }
        """

    @overload
    async def update_direct_query_refresh_schedule(  # pylint: disable=inconsistent-return-statements
        self,
        dataset_id: str,
        dataset_dq_refresh_schedule_request: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Updates the refresh schedule for a specified `DirectQuery
        </power-bi/connect-data/desktop-directquery-about>`_ or `LiveConnection
        </power-bi/connect-data/desktop-directquery-about#live-connections>`_ dataset from **My
        workspace**.

        A request should contain either a set of days and times *or* a valid frequency, but not both.
        If you choose a set of days without specifying any times, then Power BI will use a default
        single time per day. Setting the frequency will automatically overwrite the days and times
        setting.

        Permissions
        -----------

        The user must be the dataset owner.

        Required Scope
        --------------

        Dataset.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param dataset_dq_refresh_schedule_request: Patch DirectQuery or LiveConnection Refresh
         Schedule parameters, by specifying all or some of the parameters. Required.
        :type dataset_dq_refresh_schedule_request: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_direct_query_refresh_schedule(  # pylint: disable=inconsistent-return-statements
        self, dataset_id: str, dataset_dq_refresh_schedule_request: Union[JSON, IO], **kwargs: Any
    ) -> None:
        """Updates the refresh schedule for a specified `DirectQuery
        </power-bi/connect-data/desktop-directquery-about>`_ or `LiveConnection
        </power-bi/connect-data/desktop-directquery-about#live-connections>`_ dataset from **My
        workspace**.

        A request should contain either a set of days and times *or* a valid frequency, but not both.
        If you choose a set of days without specifying any times, then Power BI will use a default
        single time per day. Setting the frequency will automatically overwrite the days and times
        setting.

        Permissions
        -----------

        The user must be the dataset owner.

        Required Scope
        --------------

        Dataset.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param dataset_dq_refresh_schedule_request: Patch DirectQuery or LiveConnection Refresh
         Schedule parameters, by specifying all or some of the parameters. Is either a JSON type or a IO
         type. Required.
        :type dataset_dq_refresh_schedule_request: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                dataset_dq_refresh_schedule_request = {
                    "value": {
                        "days": [
                            "str"  # Optional. The days on which to execute the refresh.
                        ],
                        "frequency": 0,  # Optional. The interval in minutes between
                          successive refreshes. Supported values are *15*"" , *30*"" , *60*"" , *120*""
                          , and *180*.
                        "localTimeZoneId": "str",  # Optional. The ID of the time zone to
                          use. For more information, see `Time zone info
                          </dotnet/api/system.timezoneinfo.id>`_.
                        "times": [
                            "str"  # Optional. The times of day to execute the refresh.
                        ]
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(dataset_dq_refresh_schedule_request, (IOBase, bytes)):
            _content = dataset_dq_refresh_schedule_request
        else:
            _json = dataset_dq_refresh_schedule_request

        _request = build_datasets_update_direct_query_refresh_schedule_request(
            dataset_id=dataset_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get_parameters(self, dataset_id: str, **kwargs: Any) -> JSON:
        """Returns a list of parameters for the specified dataset from **My workspace**.

        Required Scope
        --------------

        Dataset.Read.All or Dataset.ReadWrite.All

        Limitations
        -----------

        Datasets with SQL, Oracle, Teradata, and SAP HANA `DirectQuery
        </power-bi/connect-data/desktop-directquery-about>`_ connections aren't supported.
        :code:`<br>`:code:`<br>`.

        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional.
                    "value": [
                        {
                            "isRequired": bool,  # Whether the dataset parameter is
                              required. Required.
                            "name": "str",  # The parameter name. Required.
                            "type": "str",  # The parameter type. Required.
                            "currentValue": "str",  # Optional. The current value of the
                              parameter.
                            "suggestedValues": [
                                "str"  # Optional. A list of suggested parameter
                                  values.
                            ]
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_datasets_get_parameters_request(
            dataset_id=dataset_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def update_parameters(  # pylint: disable=inconsistent-return-statements
        self,
        dataset_id: str,
        update_mashup_parameters_request: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Updates the parameters values for the specified dataset from **My workspace**.

        ..

           [!NOTE]
           We recommend using `enhanced dataset metadata
        </power-bi/connect-data/desktop-enhanced-dataset-metadata>`_ with this API call.

           [!IMPORTANT]


           * If you're using **enhanced dataset metadata**\ , refresh the dataset to apply the new
        parameter values.
           * If you're not using **enhanced dataset metadata**\ , wait 30 minutes for the update data
        sources operation to complete, and then refresh the dataset.


        Permissions
        -----------

        The user must be the dataset owner.

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------


        * Datasets created using the public `XMLA endpoint
        </power-bi/admin/service-premium-connect-tools>`_ aren't supported. To make changes to those
        data sources, the admin must use the Azure Analysis Services client library for Tabular Object
        Model.
        * `DirectQuery </power-bi/connect-data/desktop-directquery-about>`_ connections are only
        supported with `enhanced dataset metadata
        </power-bi/connect-data/desktop-enhanced-dataset-metadata>`_.
        * Datasets with Azure Analysis Services live connections aren't supported.
        * Maximum of 100 parameters per request.
        * All specified parameters must exist in the dataset.
        * Parameters values should be of the expected type.
        * The parameter list can't be empty or include duplicate parameters.
        * Parameters names are case-sensitive.
        * Parameter ``IsRequired`` must have a non-empty value.
        * The parameter types ``Any`` and ``Binary`` can't be updated.
          :code:`<br>`:code:`<br>`.

        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param update_mashup_parameters_request: Required.
        :type update_mashup_parameters_request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                update_mashup_parameters_request = {
                    "updateDetails": [
                        {
                            "name": "str",  # The parameter name. Required.
                            "newValue": "str"  # Optional. The new value for the
                              parameter.
                        }
                    ]
                }
        """

    @overload
    async def update_parameters(  # pylint: disable=inconsistent-return-statements
        self,
        dataset_id: str,
        update_mashup_parameters_request: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Updates the parameters values for the specified dataset from **My workspace**.

        ..

           [!NOTE]
           We recommend using `enhanced dataset metadata
        </power-bi/connect-data/desktop-enhanced-dataset-metadata>`_ with this API call.

           [!IMPORTANT]


           * If you're using **enhanced dataset metadata**\ , refresh the dataset to apply the new
        parameter values.
           * If you're not using **enhanced dataset metadata**\ , wait 30 minutes for the update data
        sources operation to complete, and then refresh the dataset.


        Permissions
        -----------

        The user must be the dataset owner.

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------


        * Datasets created using the public `XMLA endpoint
        </power-bi/admin/service-premium-connect-tools>`_ aren't supported. To make changes to those
        data sources, the admin must use the Azure Analysis Services client library for Tabular Object
        Model.
        * `DirectQuery </power-bi/connect-data/desktop-directquery-about>`_ connections are only
        supported with `enhanced dataset metadata
        </power-bi/connect-data/desktop-enhanced-dataset-metadata>`_.
        * Datasets with Azure Analysis Services live connections aren't supported.
        * Maximum of 100 parameters per request.
        * All specified parameters must exist in the dataset.
        * Parameters values should be of the expected type.
        * The parameter list can't be empty or include duplicate parameters.
        * Parameters names are case-sensitive.
        * Parameter ``IsRequired`` must have a non-empty value.
        * The parameter types ``Any`` and ``Binary`` can't be updated.
          :code:`<br>`:code:`<br>`.

        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param update_mashup_parameters_request: Required.
        :type update_mashup_parameters_request: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_parameters(  # pylint: disable=inconsistent-return-statements
        self, dataset_id: str, update_mashup_parameters_request: Union[JSON, IO], **kwargs: Any
    ) -> None:
        """Updates the parameters values for the specified dataset from **My workspace**.

        ..

           [!NOTE]
           We recommend using `enhanced dataset metadata
        </power-bi/connect-data/desktop-enhanced-dataset-metadata>`_ with this API call.

           [!IMPORTANT]


           * If you're using **enhanced dataset metadata**\ , refresh the dataset to apply the new
        parameter values.
           * If you're not using **enhanced dataset metadata**\ , wait 30 minutes for the update data
        sources operation to complete, and then refresh the dataset.


        Permissions
        -----------

        The user must be the dataset owner.

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------


        * Datasets created using the public `XMLA endpoint
        </power-bi/admin/service-premium-connect-tools>`_ aren't supported. To make changes to those
        data sources, the admin must use the Azure Analysis Services client library for Tabular Object
        Model.
        * `DirectQuery </power-bi/connect-data/desktop-directquery-about>`_ connections are only
        supported with `enhanced dataset metadata
        </power-bi/connect-data/desktop-enhanced-dataset-metadata>`_.
        * Datasets with Azure Analysis Services live connections aren't supported.
        * Maximum of 100 parameters per request.
        * All specified parameters must exist in the dataset.
        * Parameters values should be of the expected type.
        * The parameter list can't be empty or include duplicate parameters.
        * Parameters names are case-sensitive.
        * Parameter ``IsRequired`` must have a non-empty value.
        * The parameter types ``Any`` and ``Binary`` can't be updated.
          :code:`<br>`:code:`<br>`.

        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param update_mashup_parameters_request: Is either a JSON type or a IO type. Required.
        :type update_mashup_parameters_request: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                update_mashup_parameters_request = {
                    "updateDetails": [
                        {
                            "name": "str",  # The parameter name. Required.
                            "newValue": "str"  # Optional. The new value for the
                              parameter.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(update_mashup_parameters_request, (IOBase, bytes)):
            _content = update_mashup_parameters_request
        else:
            _json = update_mashup_parameters_request

        _request = build_datasets_update_parameters_request(
            dataset_id=dataset_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get_datasources(self, dataset_id: str, **kwargs: Any) -> JSON:
        """Returns a list of data sources for the specified dataset from **My workspace**.

        Required Scope
        --------------

        Dataset.ReadWrite.All or Dataset.Read.All
        :code:`<br>`:code:`<br>`.

        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional. OData context.
                    "value": [
                        {
                            "connectionDetails": {
                                "account": "str",  # Optional. The connection
                                  account.
                                "classInfo": "str",  # Optional. The connection class
                                  information.
                                "database": "str",  # Optional. The connection
                                  database.
                                "domain": "str",  # Optional. The connection domain.
                                "emailAddress": "str",  # Optional. The connection
                                  email address.
                                "kind": "str",  # Optional. The connection kind.
                                "loginServer": "str",  # Optional. The connection
                                  login server.
                                "path": "str",  # Optional. The connection path.
                                "server": "str",  # Optional. The connection server.
                                "url": "str"  # Optional. The connection URL.
                            },
                            "connectionString": "str",  # Optional. (Deprecated) The data
                              source connection string. Available only for DirectQuery.
                            "datasourceId": "str",  # Optional. The bound data source ID,
                              which is empty when not bound to a gateway.
                            "datasourceType": "str",  # Optional. The data source type.
                            "gatewayId": "str",  # Optional. The bound gateway ID, which
                              is empty when not bound to a gateway. When using a gateway cluster, the
                              gateway ID refers to the primary (first) gateway in the cluster and is
                              similar to the gateway cluster ID.
                            "name": "str"  # Optional. (Deprecated) The data source name.
                              Available only for DirectQuery.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_datasets_get_datasources_request(
            dataset_id=dataset_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def update_datasources(  # pylint: disable=inconsistent-return-statements
        self,
        dataset_id: str,
        update_datasources_request: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Updates the data sources of the specified dataset from **My workspace**.

        ..

           [!NOTE]
           We recommend using `enhanced dataset metadata
        </power-bi/connect-data/desktop-enhanced-dataset-metadata>`_ with this API call.

           [!IMPORTANT]


           * The original data source and the new data source must have the exact same schema.
           * If you're using **enhanced dataset metadata**\ , refresh the dataset to get data from the
        new data sources.
           * If you're not using **enhanced dataset metadata**\ , wait 30 minutes for the update data
        sources operation to complete, and then refresh the dataset.


        Permissions
        -----------

        The user must be the dataset owner.

        Limitations
        -----------


        * Datasets created using the public `XMLA endpoint
        </power-bi/admin/service-premium-connect-tools>`_ aren't supported. To make changes to those
        data sources, the admin must use the Azure Analysis Services client library for Tabular Object
        Model.
        * Only these data sources are supported: SQL Server, Azure SQL Server, Azure Analysis Services,
        Azure Synapse, OData, SharePoint, Teradata, and SAP HANA. For other data sources, use the
        `Update Parameters </rest/api/power-bi/datasets/update-parameters>`_ API call.
        * Changing the data source type isn't supported.
        * Data sources that contain parameters in the connection string aren't supported.
        * Updating data sources that are part of merged or joined tables is only supported if you're
        using `enhanced dataset metadata </power-bi/connect-data/desktop-enhanced-dataset-metadata>`_.
        * For an Advanced Query that references multiple data sources, only the first data source will
        be updated. To overcome this limitation, define the data source as a parameter and use the
        `Update Parameters </rest/api/power-bi/datasets/update-parameters>`_ API call.
        * Datasets with incremental refresh policy are not fully supported, calling this API may not
        work as expected and result of partial datasources update, to overcome this you can try run a
        dataset refresh before calling this API.

        Required Scope
        --------------

        Dataset.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param update_datasources_request: Required.
        :type update_datasources_request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                update_datasources_request = {
                    "updateDetails": [
                        {
                            "connectionDetails": {
                                "account": "str",  # Optional. The connection
                                  account.
                                "classInfo": "str",  # Optional. The connection class
                                  information.
                                "database": "str",  # Optional. The connection
                                  database.
                                "domain": "str",  # Optional. The connection domain.
                                "emailAddress": "str",  # Optional. The connection
                                  email address.
                                "kind": "str",  # Optional. The connection kind.
                                "loginServer": "str",  # Optional. The connection
                                  login server.
                                "path": "str",  # Optional. The connection path.
                                "server": "str",  # Optional. The connection server.
                                "url": "str"  # Optional. The connection URL.
                            },
                            "datasourceSelector": {
                                "connectionDetails": {
                                    "account": "str",  # Optional. The connection
                                      account.
                                    "classInfo": "str",  # Optional. The
                                      connection class information.
                                    "database": "str",  # Optional. The
                                      connection database.
                                    "domain": "str",  # Optional. The connection
                                      domain.
                                    "emailAddress": "str",  # Optional. The
                                      connection email address.
                                    "kind": "str",  # Optional. The connection
                                      kind.
                                    "loginServer": "str",  # Optional. The
                                      connection login server.
                                    "path": "str",  # Optional. The connection
                                      path.
                                    "server": "str",  # Optional. The connection
                                      server.
                                    "url": "str"  # Optional. The connection URL.
                                },
                                "connectionString": "str",  # Optional. (Deprecated)
                                  The data source connection string. Available only for DirectQuery.
                                "datasourceId": "str",  # Optional. The bound data
                                  source ID, which is empty when not bound to a gateway.
                                "datasourceType": "str",  # Optional. The data source
                                  type.
                                "gatewayId": "str",  # Optional. The bound gateway
                                  ID, which is empty when not bound to a gateway. When using a gateway
                                  cluster, the gateway ID refers to the primary (first) gateway in the
                                  cluster and is similar to the gateway cluster ID.
                                "name": "str"  # Optional. (Deprecated) The data
                                  source name. Available only for DirectQuery.
                            }
                        }
                    ]
                }
        """

    @overload
    async def update_datasources(  # pylint: disable=inconsistent-return-statements
        self, dataset_id: str, update_datasources_request: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Updates the data sources of the specified dataset from **My workspace**.

        ..

           [!NOTE]
           We recommend using `enhanced dataset metadata
        </power-bi/connect-data/desktop-enhanced-dataset-metadata>`_ with this API call.

           [!IMPORTANT]


           * The original data source and the new data source must have the exact same schema.
           * If you're using **enhanced dataset metadata**\ , refresh the dataset to get data from the
        new data sources.
           * If you're not using **enhanced dataset metadata**\ , wait 30 minutes for the update data
        sources operation to complete, and then refresh the dataset.


        Permissions
        -----------

        The user must be the dataset owner.

        Limitations
        -----------


        * Datasets created using the public `XMLA endpoint
        </power-bi/admin/service-premium-connect-tools>`_ aren't supported. To make changes to those
        data sources, the admin must use the Azure Analysis Services client library for Tabular Object
        Model.
        * Only these data sources are supported: SQL Server, Azure SQL Server, Azure Analysis Services,
        Azure Synapse, OData, SharePoint, Teradata, and SAP HANA. For other data sources, use the
        `Update Parameters </rest/api/power-bi/datasets/update-parameters>`_ API call.
        * Changing the data source type isn't supported.
        * Data sources that contain parameters in the connection string aren't supported.
        * Updating data sources that are part of merged or joined tables is only supported if you're
        using `enhanced dataset metadata </power-bi/connect-data/desktop-enhanced-dataset-metadata>`_.
        * For an Advanced Query that references multiple data sources, only the first data source will
        be updated. To overcome this limitation, define the data source as a parameter and use the
        `Update Parameters </rest/api/power-bi/datasets/update-parameters>`_ API call.
        * Datasets with incremental refresh policy are not fully supported, calling this API may not
        work as expected and result of partial datasources update, to overcome this you can try run a
        dataset refresh before calling this API.

        Required Scope
        --------------

        Dataset.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param update_datasources_request: Required.
        :type update_datasources_request: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_datasources(  # pylint: disable=inconsistent-return-statements
        self, dataset_id: str, update_datasources_request: Union[JSON, IO], **kwargs: Any
    ) -> None:
        """Updates the data sources of the specified dataset from **My workspace**.

        ..

           [!NOTE]
           We recommend using `enhanced dataset metadata
        </power-bi/connect-data/desktop-enhanced-dataset-metadata>`_ with this API call.

           [!IMPORTANT]


           * The original data source and the new data source must have the exact same schema.
           * If you're using **enhanced dataset metadata**\ , refresh the dataset to get data from the
        new data sources.
           * If you're not using **enhanced dataset metadata**\ , wait 30 minutes for the update data
        sources operation to complete, and then refresh the dataset.


        Permissions
        -----------

        The user must be the dataset owner.

        Limitations
        -----------


        * Datasets created using the public `XMLA endpoint
        </power-bi/admin/service-premium-connect-tools>`_ aren't supported. To make changes to those
        data sources, the admin must use the Azure Analysis Services client library for Tabular Object
        Model.
        * Only these data sources are supported: SQL Server, Azure SQL Server, Azure Analysis Services,
        Azure Synapse, OData, SharePoint, Teradata, and SAP HANA. For other data sources, use the
        `Update Parameters </rest/api/power-bi/datasets/update-parameters>`_ API call.
        * Changing the data source type isn't supported.
        * Data sources that contain parameters in the connection string aren't supported.
        * Updating data sources that are part of merged or joined tables is only supported if you're
        using `enhanced dataset metadata </power-bi/connect-data/desktop-enhanced-dataset-metadata>`_.
        * For an Advanced Query that references multiple data sources, only the first data source will
        be updated. To overcome this limitation, define the data source as a parameter and use the
        `Update Parameters </rest/api/power-bi/datasets/update-parameters>`_ API call.
        * Datasets with incremental refresh policy are not fully supported, calling this API may not
        work as expected and result of partial datasources update, to overcome this you can try run a
        dataset refresh before calling this API.

        Required Scope
        --------------

        Dataset.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param update_datasources_request: Is either a JSON type or a IO type. Required.
        :type update_datasources_request: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                update_datasources_request = {
                    "updateDetails": [
                        {
                            "connectionDetails": {
                                "account": "str",  # Optional. The connection
                                  account.
                                "classInfo": "str",  # Optional. The connection class
                                  information.
                                "database": "str",  # Optional. The connection
                                  database.
                                "domain": "str",  # Optional. The connection domain.
                                "emailAddress": "str",  # Optional. The connection
                                  email address.
                                "kind": "str",  # Optional. The connection kind.
                                "loginServer": "str",  # Optional. The connection
                                  login server.
                                "path": "str",  # Optional. The connection path.
                                "server": "str",  # Optional. The connection server.
                                "url": "str"  # Optional. The connection URL.
                            },
                            "datasourceSelector": {
                                "connectionDetails": {
                                    "account": "str",  # Optional. The connection
                                      account.
                                    "classInfo": "str",  # Optional. The
                                      connection class information.
                                    "database": "str",  # Optional. The
                                      connection database.
                                    "domain": "str",  # Optional. The connection
                                      domain.
                                    "emailAddress": "str",  # Optional. The
                                      connection email address.
                                    "kind": "str",  # Optional. The connection
                                      kind.
                                    "loginServer": "str",  # Optional. The
                                      connection login server.
                                    "path": "str",  # Optional. The connection
                                      path.
                                    "server": "str",  # Optional. The connection
                                      server.
                                    "url": "str"  # Optional. The connection URL.
                                },
                                "connectionString": "str",  # Optional. (Deprecated)
                                  The data source connection string. Available only for DirectQuery.
                                "datasourceId": "str",  # Optional. The bound data
                                  source ID, which is empty when not bound to a gateway.
                                "datasourceType": "str",  # Optional. The data source
                                  type.
                                "gatewayId": "str",  # Optional. The bound gateway
                                  ID, which is empty when not bound to a gateway. When using a gateway
                                  cluster, the gateway ID refers to the primary (first) gateway in the
                                  cluster and is similar to the gateway cluster ID.
                                "name": "str"  # Optional. (Deprecated) The data
                                  source name. Available only for DirectQuery.
                            }
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(update_datasources_request, (IOBase, bytes)):
            _content = update_datasources_request
        else:
            _json = update_datasources_request

        _request = build_datasets_update_datasources_request(
            dataset_id=dataset_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def set_all_dataset_connections(  # pylint: disable=inconsistent-return-statements
        self, dataset_id: str, parameters: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Updates all connections for the specified dataset from **My workspace**. This API call only
        supports SQL DirectQuery datasets.

        ..

           [!IMPORTANT]
           This API call is deprecated and no longer supported. This API call isn't compatible with
        `enhanced dataset metadata </power-bi/connect-data/desktop-enhanced-dataset-metadata>`_.

           Instead use:


           * `Update Parameters </rest/api/power-bi/datasets/update-parameters>`_ to update connections
        for SQL, Azure Synapse, OData, and SharePoint data sources.
           * `Update Datasources </rest/api/power-bi/datasets/update-datasources>`_ to connections for
        other data sources.


        Required Scope
        --------------

        Dataset.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param parameters: The body. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "connectionString": "str"  # A dataset connection string. Required.
                }
        """

    @overload
    async def set_all_dataset_connections(  # pylint: disable=inconsistent-return-statements
        self, dataset_id: str, parameters: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Updates all connections for the specified dataset from **My workspace**. This API call only
        supports SQL DirectQuery datasets.

        ..

           [!IMPORTANT]
           This API call is deprecated and no longer supported. This API call isn't compatible with
        `enhanced dataset metadata </power-bi/connect-data/desktop-enhanced-dataset-metadata>`_.

           Instead use:


           * `Update Parameters </rest/api/power-bi/datasets/update-parameters>`_ to update connections
        for SQL, Azure Synapse, OData, and SharePoint data sources.
           * `Update Datasources </rest/api/power-bi/datasets/update-datasources>`_ to connections for
        other data sources.


        Required Scope
        --------------

        Dataset.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param parameters: The body. Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def set_all_dataset_connections(  # pylint: disable=inconsistent-return-statements
        self, dataset_id: str, parameters: Union[JSON, IO], **kwargs: Any
    ) -> None:
        """Updates all connections for the specified dataset from **My workspace**. This API call only
        supports SQL DirectQuery datasets.

        ..

           [!IMPORTANT]
           This API call is deprecated and no longer supported. This API call isn't compatible with
        `enhanced dataset metadata </power-bi/connect-data/desktop-enhanced-dataset-metadata>`_.

           Instead use:


           * `Update Parameters </rest/api/power-bi/datasets/update-parameters>`_ to update connections
        for SQL, Azure Synapse, OData, and SharePoint data sources.
           * `Update Datasources </rest/api/power-bi/datasets/update-datasources>`_ to connections for
        other data sources.


        Required Scope
        --------------

        Dataset.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param parameters: The body. Is either a JSON type or a IO type. Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "connectionString": "str"  # A dataset connection string. Required.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _json = parameters

        _request = build_datasets_set_all_dataset_connections_request(
            dataset_id=dataset_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def bind_to_gateway(  # pylint: disable=inconsistent-return-statements
        self, dataset_id: str, bind_to_gateway_request: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Binds the specified dataset from **My workspace** to the specified gateway, optionally with a
        given set of data source IDs. If you don't supply a specific data source ID, the dataset will
        be bound to the first matching data source in the gateway.

        ..

           [!IMPORTANT]
           Add the API caller principal as a data source user on the gateway.


        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------

        Only supports the on-premises data gateway
        :code:`<br>`:code:`<br>`.

        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param bind_to_gateway_request: The bind to gateway request. Required.
        :type bind_to_gateway_request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                bind_to_gateway_request = {
                    "gatewayObjectId": "str",  # The gateway ID. When using a gateway cluster,
                      the gateway ID refers to the primary (first) gateway in the cluster and is
                      similar to the gateway cluster ID. Required.
                    "datasourceObjectIds": [
                        "str"  # Optional. The unique identifiers for the data sources in the
                          gateway.
                    ]
                }
        """

    @overload
    async def bind_to_gateway(  # pylint: disable=inconsistent-return-statements
        self, dataset_id: str, bind_to_gateway_request: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Binds the specified dataset from **My workspace** to the specified gateway, optionally with a
        given set of data source IDs. If you don't supply a specific data source ID, the dataset will
        be bound to the first matching data source in the gateway.

        ..

           [!IMPORTANT]
           Add the API caller principal as a data source user on the gateway.


        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------

        Only supports the on-premises data gateway
        :code:`<br>`:code:`<br>`.

        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param bind_to_gateway_request: The bind to gateway request. Required.
        :type bind_to_gateway_request: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def bind_to_gateway(  # pylint: disable=inconsistent-return-statements
        self, dataset_id: str, bind_to_gateway_request: Union[JSON, IO], **kwargs: Any
    ) -> None:
        """Binds the specified dataset from **My workspace** to the specified gateway, optionally with a
        given set of data source IDs. If you don't supply a specific data source ID, the dataset will
        be bound to the first matching data source in the gateway.

        ..

           [!IMPORTANT]
           Add the API caller principal as a data source user on the gateway.


        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------

        Only supports the on-premises data gateway
        :code:`<br>`:code:`<br>`.

        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param bind_to_gateway_request: The bind to gateway request. Is either a JSON type or a IO
         type. Required.
        :type bind_to_gateway_request: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                bind_to_gateway_request = {
                    "gatewayObjectId": "str",  # The gateway ID. When using a gateway cluster,
                      the gateway ID refers to the primary (first) gateway in the cluster and is
                      similar to the gateway cluster ID. Required.
                    "datasourceObjectIds": [
                        "str"  # Optional. The unique identifiers for the data sources in the
                          gateway.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(bind_to_gateway_request, (IOBase, bytes)):
            _content = bind_to_gateway_request
        else:
            _json = bind_to_gateway_request

        _request = build_datasets_bind_to_gateway_request(
            dataset_id=dataset_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get_gateway_datasources(self, dataset_id: str, **kwargs: Any) -> JSON:
        """Returns a list of gateway data sources for the specified dataset from **My workspace**.

        ..

           [!IMPORTANT]
           This API call is deprecated, use `Get Datasources
        </rest/api/power-bi/datasets/get-datasources>`_ instead.


        Required Scope
        --------------

        Dataset.ReadWrite.All or Dataset.Read.All
        :code:`<br>`:code:`<br>`.

        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional. OData context.
                    "value": [
                        {
                            "credentialType": "str",  # The type of data source
                              `credential </power-bi/developer/embedded/configure-credentials>`_.
                              Required. Known values are: "Basic", "Windows", "Anonymous", "OAuth2",
                              "Key", and "SAS".
                            "gatewayId": "str",  # The associated gateway ID. When using
                              a gateway cluster, the gateway ID refers to the primary (first) gateway
                              in the cluster and is similar to the gateway cluster ID. Required.
                            "id": "str",  # The unique ID for the data source. Required.
                            "connectionDetails": "str",  # Optional. Connection details
                              in JSON format.
                            "credentialDetails": {
                                "useEndUserOAuth2Credentials": bool  # Optional.
                                  Whether the end-user Azure AD identity (OAuth 2.0 credentials) is
                                  used when connecting to the data source in DirectQuery mode. Use with
                                  data sources that support `single sign-on (SSO)
                                  </power-bi/connect-data/power-bi-data-sources#single-sign-on-sso-for-directquery-sources>`_.
                            },
                            "datasourceName": "str",  # Optional. The name of the data
                              source.
                            "datasourceType": "str"  # Optional. The type of `data source
                              </power-bi/connect-data/power-bi-data-sources>`_.  .. list-table::
                              :header-rows: 1     * - API name for the data source      -       -     *
                              - ActiveDirectory      - AdobeAnalytics      - AdoDotNet    * -
                              AnalysisServices      - AzureBlobs      - AzureDataLakeStorage    * -
                              AzureMarketplace      - AzureTables      - BizTalk    * - CDPA      -
                              CustomConnector      - CustomHttpApi    * - DB2      - Essbase      -
                              EventHub    * - Excel      - Exchange      - Extension    * - Facebook
                              - File      - Folder    * - GoogleAnalytics      - Hdfs      - HDInsight
                              * - Informix      - MQ      - MySql    * - OData      - ODBC      - OleDb
                              * - Oracle      - PostgreSql      - PowerQueryMashup     * - PubNub
                              - Salesforce      - SAPBW    * - SAPBWMessageServer      - SapErp      -
                              SAPHana    * - SharePoint      - SharePointDocLib      - SharePointList
                              * - Sql      - Sybase      - Teradata    * - UIFlow      - Web.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_datasets_get_gateway_datasources_request(
            dataset_id=dataset_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def discover_gateways(self, dataset_id: str, **kwargs: Any) -> JSON:
        """Returns a list of gateways that the specified dataset from **My workspace** can be bound to.

        This API call is only relevant to datasets that have at least one on-premises connection. For
        datasets with cloud-only connections, this API call returns an empty list.

        Required Scope
        --------------

        Dataset.Read.All
        :code:`<br>`:code:`<br>`.

        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional.
                    "value": [
                        {
                            "id": "str",  # The gateway ID. When using a gateway cluster,
                              the gateway ID refers to the primary (first) gateway in the cluster and
                              is similar to the gateway cluster ID. Required.
                            "gatewayAnnotation": "str",  # Optional. Gateway metadata in
                              JSON format.
                            "gatewayStatus": "str",  # Optional. The gateway connectivity
                              status.
                            "name": "str",  # Optional. The gateway name.
                            "publicKey": {
                                "exponent": "str",  # Optional. The public key
                                  exponent.
                                "modulus": "str"  # Optional. The public key modulus.
                            },
                            "type": "str"  # Optional. The gateway type.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_datasets_discover_gateways_request(
            dataset_id=dataset_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_query_scale_out_sync_status(self, dataset_id: str, **kwargs: Any) -> JSON:
        """Returns the query scale-out sync status for the specified dataset from **My workspace**.

        Required Scope
        --------------

        Dataset.ReadWrite.All or Dataset.Read.All
        :code:`<br>`:code:`<br>`.

        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "commitTimestamp": "2020-02-20 00:00:00",  # Optional. Timestamp indicating
                      the latest commit version.
                    "commitVersion": 0,  # Optional. Latest commit version.
                    "minActiveReadTimestamp": "2020-02-20 00:00:00",  # Optional. Timestamp
                      indicating the minimum active read version.
                    "minActiveReadVersion": 0,  # Optional. Minimum active read version.
                    "scaleOutStatus": "str",  # Optional. Query scale-out status. Known values
                      are: "Enabled", "TenantSettingDisabled", "StorageModeNotSupported", and
                      "ReadOnlyReplicasDisabled".
                    "syncEndTime": "2020-02-20 00:00:00",  # Optional. Timestamp indicating when
                      last sync ended.
                    "syncStartTime": "2020-02-20 00:00:00",  # Optional. Timestamp indicating
                      when last sync started.
                    "targetSyncTimestamp": "2020-02-20 00:00:00",  # Optional. Timestamp
                      indicating the target sync version.
                    "targetSyncVersion": 0,  # Optional. Target sync version.
                    "triggerReason": "str"  # Optional. Query scale-out sync trigger reason.
                      Known values are: "explicit", "automatic", and "system".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_datasets_get_query_scale_out_sync_status_request(
            dataset_id=dataset_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def trigger_query_scale_out_sync(self, dataset_id: str, **kwargs: Any) -> JSON:
        """Triggers a query scale-out sync of read-only replicas for the specified dataset from **My
        workspace**.

        Required Scope
        --------------

        Dataset.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "commitTimestamp": "2020-02-20 00:00:00",  # Optional. Timestamp indicating
                      the latest commit version.
                    "commitVersion": 0,  # Optional. Latest commit version.
                    "minActiveReadTimestamp": "2020-02-20 00:00:00",  # Optional. Timestamp
                      indicating the minimum active read version.
                    "minActiveReadVersion": 0,  # Optional. Minimum active read version.
                    "scaleOutStatus": "str",  # Optional. Query scale-out status. Known values
                      are: "Enabled", "TenantSettingDisabled", "StorageModeNotSupported", and
                      "ReadOnlyReplicasDisabled".
                    "syncEndTime": "2020-02-20 00:00:00",  # Optional. Timestamp indicating when
                      last sync ended.
                    "syncStartTime": "2020-02-20 00:00:00",  # Optional. Timestamp indicating
                      when last sync started.
                    "targetSyncTimestamp": "2020-02-20 00:00:00",  # Optional. Timestamp
                      indicating the target sync version.
                    "targetSyncVersion": 0,  # Optional. Target sync version.
                    "triggerReason": "str"  # Optional. Query scale-out sync trigger reason.
                      Known values are: "explicit", "automatic", and "system".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_datasets_trigger_query_scale_out_sync_request(
            dataset_id=dataset_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def post_dataset_user_in_group(  # pylint: disable=inconsistent-return-statements
        self,
        group_id: str,
        dataset_id: str,
        user_details: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Grants the specified user's permissions to the specified dataset.

        When user permissions to a dataset have been recently updated, the new permissions might not be
        immediately available through API calls. To refresh user permissions, use the `Refresh User
        Permissions </rest/api/power-bi/users/refresh-user-permissions>`_ API call.

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------


        * Adding permissions to service principals (app principalType) isn't supported
        * Caller must have ReadReshare permissions on the dataset.
        * This API call can't be used to grant dataset Write permission on the dataset
          :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param user_details: Details of user access right. Required.
        :type user_details: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                user_details = {
                    "datasetUserAccessRight": "str",  # Required. The access right to grant to
                      the user for the dataset. Required. Known values are: "Read", "ReadReshare",
                      "ReadExplore", and "ReadReshareExplore".
                    "identifier": "str",  # For principal type ``User``"" , provide the *UPN*.
                      Otherwise provide the `object ID
                      </power-bi/developer/embedded/embedded-troubleshoot#what-is-the-difference-between-application-object-id-and-principal-object-id>`_
                      of the principal. Required.
                    "principalType": "str"  # The principal type. Required. Known values are:
                      "None", "User", "Group", and "App".
                }
        """

    @overload
    async def post_dataset_user_in_group(  # pylint: disable=inconsistent-return-statements
        self, group_id: str, dataset_id: str, user_details: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Grants the specified user's permissions to the specified dataset.

        When user permissions to a dataset have been recently updated, the new permissions might not be
        immediately available through API calls. To refresh user permissions, use the `Refresh User
        Permissions </rest/api/power-bi/users/refresh-user-permissions>`_ API call.

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------


        * Adding permissions to service principals (app principalType) isn't supported
        * Caller must have ReadReshare permissions on the dataset.
        * This API call can't be used to grant dataset Write permission on the dataset
          :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param user_details: Details of user access right. Required.
        :type user_details: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def post_dataset_user_in_group(  # pylint: disable=inconsistent-return-statements
        self, group_id: str, dataset_id: str, user_details: Union[JSON, IO], **kwargs: Any
    ) -> None:
        """Grants the specified user's permissions to the specified dataset.

        When user permissions to a dataset have been recently updated, the new permissions might not be
        immediately available through API calls. To refresh user permissions, use the `Refresh User
        Permissions </rest/api/power-bi/users/refresh-user-permissions>`_ API call.

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------


        * Adding permissions to service principals (app principalType) isn't supported
        * Caller must have ReadReshare permissions on the dataset.
        * This API call can't be used to grant dataset Write permission on the dataset
          :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param user_details: Details of user access right. Is either a JSON type or a IO type.
         Required.
        :type user_details: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                user_details = {
                    "datasetUserAccessRight": "str",  # Required. The access right to grant to
                      the user for the dataset. Required. Known values are: "Read", "ReadReshare",
                      "ReadExplore", and "ReadReshareExplore".
                    "identifier": "str",  # For principal type ``User``"" , provide the *UPN*.
                      Otherwise provide the `object ID
                      </power-bi/developer/embedded/embedded-troubleshoot#what-is-the-difference-between-application-object-id-and-principal-object-id>`_
                      of the principal. Required.
                    "principalType": "str"  # The principal type. Required. Known values are:
                      "None", "User", "Group", and "App".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(user_details, (IOBase, bytes)):
            _content = user_details
        else:
            _json = user_details

        _request = build_datasets_post_dataset_user_in_group_request(
            group_id=group_id,
            dataset_id=dataset_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def put_dataset_user_in_group(  # pylint: disable=inconsistent-return-statements
        self,
        group_id: str,
        dataset_id: str,
        user_details: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Updates the existing dataset permissions of the specified user to the specified permissions.

        When user permissions to a dataset have been recently updated, the new permissions might not be
        immediately available through API calls. To refresh user permissions, use the `Refresh User
        Permissions </rest/api/power-bi/users/refresh-user-permissions>`_ API call.
        This API call can be used to remove all the dataset permissions of the specified user by using
        ``datasetUserAccessRight: None``

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Permissions
        -----------

        The permissions for this API call are listed in `Datasets permissions
        </power-bi/developer/embedded/datasets-permissions>`_.

        Limitations
        -----------


        * Updating permissions to service principals (app principalType) isn't supported
        * Caller must have ReadWriteReshare permissions on the dataset. That is, folder admins, members
        and contributors with Reshare permissions, or dataset owners.
        * This API can't be used to add or remove *write* permission.
        * This API can't be used to remove folder-level inherited permissions. For folder admins and
        members, the ReadWriteReshareExplore permission on the folder's datasets is inherited. For
        folder contributors, the ReadWriteExplore permission on the folder's datasets is inherited. For
        folder viewers, the Read permission on the folder's datasets is inherited.
          :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param user_details: Details of user access right. Required.
        :type user_details: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                user_details = {
                    "datasetUserAccessRight": "str",  # The access rights to assign to the user
                      for the dataset (permission level). Required. Known values are: "None", "Read",
                      "ReadWrite", "ReadReshare", "ReadWriteReshare", "ReadExplore",
                      "ReadReshareExplore", "ReadWriteExplore", and "ReadWriteReshareExplore".
                    "identifier": "str",  # For principal type ``User``"" , provide the *UPN*.
                      Otherwise provide the `object ID
                      </power-bi/developer/embedded/embedded-troubleshoot#what-is-the-difference-between-application-object-id-and-principal-object-id>`_
                      of the principal. Required.
                    "principalType": "str"  # The principal type. Required. Known values are:
                      "None", "User", "Group", and "App".
                }
        """

    @overload
    async def put_dataset_user_in_group(  # pylint: disable=inconsistent-return-statements
        self, group_id: str, dataset_id: str, user_details: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Updates the existing dataset permissions of the specified user to the specified permissions.

        When user permissions to a dataset have been recently updated, the new permissions might not be
        immediately available through API calls. To refresh user permissions, use the `Refresh User
        Permissions </rest/api/power-bi/users/refresh-user-permissions>`_ API call.
        This API call can be used to remove all the dataset permissions of the specified user by using
        ``datasetUserAccessRight: None``

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Permissions
        -----------

        The permissions for this API call are listed in `Datasets permissions
        </power-bi/developer/embedded/datasets-permissions>`_.

        Limitations
        -----------


        * Updating permissions to service principals (app principalType) isn't supported
        * Caller must have ReadWriteReshare permissions on the dataset. That is, folder admins, members
        and contributors with Reshare permissions, or dataset owners.
        * This API can't be used to add or remove *write* permission.
        * This API can't be used to remove folder-level inherited permissions. For folder admins and
        members, the ReadWriteReshareExplore permission on the folder's datasets is inherited. For
        folder contributors, the ReadWriteExplore permission on the folder's datasets is inherited. For
        folder viewers, the Read permission on the folder's datasets is inherited.
          :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param user_details: Details of user access right. Required.
        :type user_details: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def put_dataset_user_in_group(  # pylint: disable=inconsistent-return-statements
        self, group_id: str, dataset_id: str, user_details: Union[JSON, IO], **kwargs: Any
    ) -> None:
        """Updates the existing dataset permissions of the specified user to the specified permissions.

        When user permissions to a dataset have been recently updated, the new permissions might not be
        immediately available through API calls. To refresh user permissions, use the `Refresh User
        Permissions </rest/api/power-bi/users/refresh-user-permissions>`_ API call.
        This API call can be used to remove all the dataset permissions of the specified user by using
        ``datasetUserAccessRight: None``

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Permissions
        -----------

        The permissions for this API call are listed in `Datasets permissions
        </power-bi/developer/embedded/datasets-permissions>`_.

        Limitations
        -----------


        * Updating permissions to service principals (app principalType) isn't supported
        * Caller must have ReadWriteReshare permissions on the dataset. That is, folder admins, members
        and contributors with Reshare permissions, or dataset owners.
        * This API can't be used to add or remove *write* permission.
        * This API can't be used to remove folder-level inherited permissions. For folder admins and
        members, the ReadWriteReshareExplore permission on the folder's datasets is inherited. For
        folder contributors, the ReadWriteExplore permission on the folder's datasets is inherited. For
        folder viewers, the Read permission on the folder's datasets is inherited.
          :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param user_details: Details of user access right. Is either a JSON type or a IO type.
         Required.
        :type user_details: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                user_details = {
                    "datasetUserAccessRight": "str",  # The access rights to assign to the user
                      for the dataset (permission level). Required. Known values are: "None", "Read",
                      "ReadWrite", "ReadReshare", "ReadWriteReshare", "ReadExplore",
                      "ReadReshareExplore", "ReadWriteExplore", and "ReadWriteReshareExplore".
                    "identifier": "str",  # For principal type ``User``"" , provide the *UPN*.
                      Otherwise provide the `object ID
                      </power-bi/developer/embedded/embedded-troubleshoot#what-is-the-difference-between-application-object-id-and-principal-object-id>`_
                      of the principal. Required.
                    "principalType": "str"  # The principal type. Required. Known values are:
                      "None", "User", "Group", and "App".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(user_details, (IOBase, bytes)):
            _content = user_details
        else:
            _json = user_details

        _request = build_datasets_put_dataset_user_in_group_request(
            group_id=group_id,
            dataset_id=dataset_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get_dataset_users_in_group(self, group_id: str, dataset_id: str, **kwargs: Any) -> JSON:
        """Returns a list of principals that have access to the specified dataset.

        When user permissions to a dataset have been recently updated, the new permissions might not be
        immediately available through API calls. To refresh user permissions, use the `Refresh User
        Permissions </rest/api/power-bi/users/refresh-user-permissions>`_ API call.

        Permissions
        -----------

        The permissions for this API call are listed in `Datasets permissions
        </power-bi/developer/embedded/datasets-permissions>`_.

        Required Scope
        --------------

        Dataset.Read.All or Dataset.ReadWrite.All

        Limitations
        -----------

        Caller must have ReadWriteReshare permissions on the dataset. That is, folder admins, members
        and contributors with Reshare permissions, or dataset owners.
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional.
                    "value": [
                        {
                            "datasetUserAccessRight": "str",  # The access rights to
                              assign to the user for the dataset (permission level). Required. Known
                              values are: "None", "Read", "ReadWrite", "ReadReshare",
                              "ReadWriteReshare", "ReadExplore", "ReadReshareExplore",
                              "ReadWriteExplore", and "ReadWriteReshareExplore".
                            "identifier": "str",  # For principal type ``User``"" ,
                              provide the *UPN*. Otherwise provide the `object ID
                              </power-bi/developer/embedded/embedded-troubleshoot#what-is-the-difference-between-application-object-id-and-principal-object-id>`_
                              of the principal. Required.
                            "principalType": "str"  # The principal type. Required. Known
                              values are: "None", "User", "Group", and "App".
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_datasets_get_dataset_users_in_group_request(
            group_id=group_id,
            dataset_id=dataset_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def post_dataset_user(  # pylint: disable=inconsistent-return-statements
        self, dataset_id: str, user_details: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Grants the specified user's permissions to the specified dataset.

        When user permissions to a dataset have been recently updated, the new permissions might not be
        immediately available through API calls. To refresh user permissions, use the `Refresh User
        Permissions </rest/api/power-bi/users/refresh-user-permissions>`_ API call.

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------


        * Adding permissions to service principals (app principalType) isn't supported
        * Caller must have ReadReshare permissions on the dataset.
        * This API call can't be used to grant dataset Write permission on the dataset
          :code:`<br>`:code:`<br>`.

        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param user_details: Details of user access right. Required.
        :type user_details: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                user_details = {
                    "datasetUserAccessRight": "str",  # Required. The access right to grant to
                      the user for the dataset. Required. Known values are: "Read", "ReadReshare",
                      "ReadExplore", and "ReadReshareExplore".
                    "identifier": "str",  # For principal type ``User``"" , provide the *UPN*.
                      Otherwise provide the `object ID
                      </power-bi/developer/embedded/embedded-troubleshoot#what-is-the-difference-between-application-object-id-and-principal-object-id>`_
                      of the principal. Required.
                    "principalType": "str"  # The principal type. Required. Known values are:
                      "None", "User", "Group", and "App".
                }
        """

    @overload
    async def post_dataset_user(  # pylint: disable=inconsistent-return-statements
        self, dataset_id: str, user_details: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Grants the specified user's permissions to the specified dataset.

        When user permissions to a dataset have been recently updated, the new permissions might not be
        immediately available through API calls. To refresh user permissions, use the `Refresh User
        Permissions </rest/api/power-bi/users/refresh-user-permissions>`_ API call.

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------


        * Adding permissions to service principals (app principalType) isn't supported
        * Caller must have ReadReshare permissions on the dataset.
        * This API call can't be used to grant dataset Write permission on the dataset
          :code:`<br>`:code:`<br>`.

        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param user_details: Details of user access right. Required.
        :type user_details: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def post_dataset_user(  # pylint: disable=inconsistent-return-statements
        self, dataset_id: str, user_details: Union[JSON, IO], **kwargs: Any
    ) -> None:
        """Grants the specified user's permissions to the specified dataset.

        When user permissions to a dataset have been recently updated, the new permissions might not be
        immediately available through API calls. To refresh user permissions, use the `Refresh User
        Permissions </rest/api/power-bi/users/refresh-user-permissions>`_ API call.

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------


        * Adding permissions to service principals (app principalType) isn't supported
        * Caller must have ReadReshare permissions on the dataset.
        * This API call can't be used to grant dataset Write permission on the dataset
          :code:`<br>`:code:`<br>`.

        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param user_details: Details of user access right. Is either a JSON type or a IO type.
         Required.
        :type user_details: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                user_details = {
                    "datasetUserAccessRight": "str",  # Required. The access right to grant to
                      the user for the dataset. Required. Known values are: "Read", "ReadReshare",
                      "ReadExplore", and "ReadReshareExplore".
                    "identifier": "str",  # For principal type ``User``"" , provide the *UPN*.
                      Otherwise provide the `object ID
                      </power-bi/developer/embedded/embedded-troubleshoot#what-is-the-difference-between-application-object-id-and-principal-object-id>`_
                      of the principal. Required.
                    "principalType": "str"  # The principal type. Required. Known values are:
                      "None", "User", "Group", and "App".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(user_details, (IOBase, bytes)):
            _content = user_details
        else:
            _json = user_details

        _request = build_datasets_post_dataset_user_request(
            dataset_id=dataset_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def put_dataset_user(  # pylint: disable=inconsistent-return-statements
        self, dataset_id: str, user_details: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Updates the existing dataset permissions of the specified user to the specified permissions.

        When user permissions to a dataset have been recently updated, the new permissions might not be
        immediately available through API calls. To refresh user permissions, use the `Refresh User
        Permissions </rest/api/power-bi/users/refresh-user-permissions>`_ API call.
        This API call can be used to remove all the dataset permissions of the specified user by using
        ``datasetUserAccessRight: None``

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Permissions
        -----------

        The permissions for this API call are listed in `Datasets permissions
        </power-bi/developer/embedded/datasets-permissions>`_.

        Limitations
        -----------


        * Updating permissions to service principals (app principalType) isn't supported
        * Caller must have ReadWriteReshare permissions on the dataset. That is, folder admins, members
        and contributors with Reshare permissions, or dataset owners.
        * This API can't be used to add or remove *write* permission.
        * This API can't be used to remove folder-level inherited permissions. For folder admins and
        members, the ReadWriteReshareExplore permission on the folder's datasets is inherited. For
        folder contributors, the ReadWriteExplore permission on the folder's datasets is inherited. For
        folder viewers, the Read permission on the folder's datasets is inherited.
          :code:`<br>`:code:`<br>`.

        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param user_details: Details of user access right. Required.
        :type user_details: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                user_details = {
                    "datasetUserAccessRight": "str",  # The access rights to assign to the user
                      for the dataset (permission level). Required. Known values are: "None", "Read",
                      "ReadWrite", "ReadReshare", "ReadWriteReshare", "ReadExplore",
                      "ReadReshareExplore", "ReadWriteExplore", and "ReadWriteReshareExplore".
                    "identifier": "str",  # For principal type ``User``"" , provide the *UPN*.
                      Otherwise provide the `object ID
                      </power-bi/developer/embedded/embedded-troubleshoot#what-is-the-difference-between-application-object-id-and-principal-object-id>`_
                      of the principal. Required.
                    "principalType": "str"  # The principal type. Required. Known values are:
                      "None", "User", "Group", and "App".
                }
        """

    @overload
    async def put_dataset_user(  # pylint: disable=inconsistent-return-statements
        self, dataset_id: str, user_details: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Updates the existing dataset permissions of the specified user to the specified permissions.

        When user permissions to a dataset have been recently updated, the new permissions might not be
        immediately available through API calls. To refresh user permissions, use the `Refresh User
        Permissions </rest/api/power-bi/users/refresh-user-permissions>`_ API call.
        This API call can be used to remove all the dataset permissions of the specified user by using
        ``datasetUserAccessRight: None``

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Permissions
        -----------

        The permissions for this API call are listed in `Datasets permissions
        </power-bi/developer/embedded/datasets-permissions>`_.

        Limitations
        -----------


        * Updating permissions to service principals (app principalType) isn't supported
        * Caller must have ReadWriteReshare permissions on the dataset. That is, folder admins, members
        and contributors with Reshare permissions, or dataset owners.
        * This API can't be used to add or remove *write* permission.
        * This API can't be used to remove folder-level inherited permissions. For folder admins and
        members, the ReadWriteReshareExplore permission on the folder's datasets is inherited. For
        folder contributors, the ReadWriteExplore permission on the folder's datasets is inherited. For
        folder viewers, the Read permission on the folder's datasets is inherited.
          :code:`<br>`:code:`<br>`.

        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param user_details: Details of user access right. Required.
        :type user_details: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def put_dataset_user(  # pylint: disable=inconsistent-return-statements
        self, dataset_id: str, user_details: Union[JSON, IO], **kwargs: Any
    ) -> None:
        """Updates the existing dataset permissions of the specified user to the specified permissions.

        When user permissions to a dataset have been recently updated, the new permissions might not be
        immediately available through API calls. To refresh user permissions, use the `Refresh User
        Permissions </rest/api/power-bi/users/refresh-user-permissions>`_ API call.
        This API call can be used to remove all the dataset permissions of the specified user by using
        ``datasetUserAccessRight: None``

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Permissions
        -----------

        The permissions for this API call are listed in `Datasets permissions
        </power-bi/developer/embedded/datasets-permissions>`_.

        Limitations
        -----------


        * Updating permissions to service principals (app principalType) isn't supported
        * Caller must have ReadWriteReshare permissions on the dataset. That is, folder admins, members
        and contributors with Reshare permissions, or dataset owners.
        * This API can't be used to add or remove *write* permission.
        * This API can't be used to remove folder-level inherited permissions. For folder admins and
        members, the ReadWriteReshareExplore permission on the folder's datasets is inherited. For
        folder contributors, the ReadWriteExplore permission on the folder's datasets is inherited. For
        folder viewers, the Read permission on the folder's datasets is inherited.
          :code:`<br>`:code:`<br>`.

        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param user_details: Details of user access right. Is either a JSON type or a IO type.
         Required.
        :type user_details: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                user_details = {
                    "datasetUserAccessRight": "str",  # The access rights to assign to the user
                      for the dataset (permission level). Required. Known values are: "None", "Read",
                      "ReadWrite", "ReadReshare", "ReadWriteReshare", "ReadExplore",
                      "ReadReshareExplore", "ReadWriteExplore", and "ReadWriteReshareExplore".
                    "identifier": "str",  # For principal type ``User``"" , provide the *UPN*.
                      Otherwise provide the `object ID
                      </power-bi/developer/embedded/embedded-troubleshoot#what-is-the-difference-between-application-object-id-and-principal-object-id>`_
                      of the principal. Required.
                    "principalType": "str"  # The principal type. Required. Known values are:
                      "None", "User", "Group", and "App".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(user_details, (IOBase, bytes)):
            _content = user_details
        else:
            _json = user_details

        _request = build_datasets_put_dataset_user_request(
            dataset_id=dataset_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get_dataset_users(self, dataset_id: str, **kwargs: Any) -> JSON:
        """Returns a list of principals that have access to the specified dataset.

        When user permissions to a dataset have been recently updated, the new permissions might not be
        immediately available through API calls. To refresh user permissions, use the `Refresh User
        Permissions </rest/api/power-bi/users/refresh-user-permissions>`_ API call.

        Permissions
        -----------

        The permissions for this API call are listed in `Datasets permissions
        </power-bi/developer/embedded/datasets-permissions>`_.

        Required Scope
        --------------

        Dataset.Read.All or Dataset.ReadWrite.All

        Limitations
        -----------

         Caller must have ReadWriteReshare permissions on the dataset. That is, folder admins, members
        and contributors with Reshare permissions, or dataset owners.
        :code:`<br>`:code:`<br>`.

        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional.
                    "value": [
                        {
                            "datasetUserAccessRight": "str",  # The access rights to
                              assign to the user for the dataset (permission level). Required. Known
                              values are: "None", "Read", "ReadWrite", "ReadReshare",
                              "ReadWriteReshare", "ReadExplore", "ReadReshareExplore",
                              "ReadWriteExplore", and "ReadWriteReshareExplore".
                            "identifier": "str",  # For principal type ``User``"" ,
                              provide the *UPN*. Otherwise provide the `object ID
                              </power-bi/developer/embedded/embedded-troubleshoot#what-is-the-difference-between-application-object-id-and-principal-object-id>`_
                              of the principal. Required.
                            "principalType": "str"  # The principal type. Required. Known
                              values are: "None", "User", "Group", and "App".
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_datasets_get_dataset_users_request(
            dataset_id=dataset_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_datasets_in_group(self, group_id: str, **kwargs: Any) -> JSON:
        """Returns a list of datasets from the specified workspace.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Dataset.ReadWrite.All or Dataset.Read.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional. OData context.
                    "value": [
                        {
                            "id": "str",  # The dataset ID. Required.
                            "ContentProviderType": "str",  # Optional. The content
                              provider type for the dataset.
                            "CreateReportEmbedURL": "str",  # Optional. The dataset
                              create report embed URL.
                            "CreatedDate": "2020-02-20 00:00:00",  # Optional. The
                              dataset creation date and time.
                            "Encryption": {
                                "EncryptionStatus": "str"  # Optional. Dataset
                                  encryption status. Known values are: "Unknown", "NotSupported",
                                  "InSyncWithWorkspace", and "NotInSyncWithWorkspace".
                            },
                            "IsEffectiveIdentityRequired": bool,  # Optional. Whether the
                              dataset requires an effective identity, which you must send in a
                              `GenerateToken </rest/api/power-bi/embed-token/generate-token>`_ API
                              call.
                            "IsEffectiveIdentityRolesRequired": bool,  # Optional.
                              Whether row-level security is defined inside the Power BI .pbix file. If
                              so, you must specify a role.
                            "IsInPlaceSharingEnabled": bool,  # Optional. Whether the
                              dataset can be shared with external users to be consumed in their own
                              tenant.
                            "IsOnPremGatewayRequired": bool,  # Optional. Whether the
                              dataset requires an on-premises data gateway.
                            "IsRefreshable": bool,  # Optional. Whether the dataset is
                              refreshable or not. A Power BI refreshable dataset is a dataset that has
                              been refreshed at least once, or for which a valid refresh schedule
                              exists.
                            "QnaEmbedURL": "str",  # Optional. The dataset Q&A embed URL.
                            "addRowsAPIEnabled": bool,  # Optional. Whether the dataset
                              allows adding new rows.
                            "configuredBy": "str",  # Optional. The dataset owner.
                            "description": "str",  # Optional. The dataset description.
                            "name": "str",  # Optional. The dataset name.
                            "queryScaleOutSettings": {
                                "autoSyncReadOnlyReplicas": bool,  # Optional.
                                  Whether the dataset automatically syncs read-only replicas.
                                "maxReadOnlyReplicas": 0  # Optional. Maximum number
                                  of read-only replicas for the dataset (0-64, -1 for automatic number
                                  of replicas).
                            },
                            "targetStorageMode": "str",  # Optional. The dataset storage
                              mode.
                            "upstreamDataflows": [
                                {
                                    "groupId": "str",  # Optional. The target
                                      group ID.
                                    "targetDataflowId": "str"  # Optional. The
                                      target dataflow ID.
                                }
                            ],
                            "users": [
                                {
                                    "datasetUserAccessRight": "str",  # The
                                      access right that the user has for the dataset (permission
                                      level). Required. Known values are: "None", "Read", "ReadWrite",
                                      "ReadReshare", "ReadWriteReshare", "ReadExplore",
                                      "ReadReshareExplore", "ReadWriteExplore", and
                                      "ReadWriteReshareExplore".
                                    "identifier": "str",  # Identifier of the
                                      principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "displayName": "str",  # Optional. Display
                                      name of the principal.
                                    "emailAddress": "str",  # Optional. Email
                                      address of the user.
                                    "graphId": "str",  # Optional. Identifier of
                                      the principal in Microsoft Graph. Only available for admin APIs.
                                    "profile": {
                                        "id": "str",  # The service principal
                                          profile ID. Required.
                                        "displayName": "str"  # Optional. The
                                          service principal profile name.
                                    },
                                    "userType": "str"  # Optional. Type of the
                                      user.
                                }
                            ],
                            "webUrl": "str"  # Optional. The web URL of the dataset.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_datasets_get_datasets_in_group_request(
            group_id=group_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def post_dataset_in_group(
        self,
        group_id: str,
        dataset: JSON,
        *,
        default_retention_policy: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Creates a new dataset in the specified workspace.

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------

        This API call only supports **push datasets**. For a complete list of limitations, see `Push
        datasets limitations </power-bi/developer/embedded/push-datasets-limitations>`_.
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataset: Create dataset parameters. Required.
        :type dataset: JSON
        :keyword default_retention_policy: The default retention policy. Known values are: "None" and
         "basicFIFO". Default value is None.
        :paramtype default_retention_policy: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                dataset = {
                    "name": "str",  # The dataset name. Required.
                    "tables": [
                        {
                            "columns": [
                                {
                                    "dataType": "str",  # The column data type.
                                      Required.
                                    "name": "str",  # The column name. Required.
                                    "dataCategory": "str",  # Optional. Optional.
                                      The string value to be used for the data category which describes
                                      the data within this column.
                                    "formatString": "str",  # Optional. Optional.
                                      The format of the column as specified in `FORMAT_STRING
                                      <https://docs.microsoft.com/analysis-services/multidimensional-models/mdx/mdx-cell-properties-format-string-contents>`_.
                                    "isHidden": bool,  # Optional. Optional.
                                      Whether the column is hidden. The default is ``false``.
                                    "sortByColumn": "str",  # Optional. Optional.
                                      String name of a column in the same table to be used to order the
                                      current column.
                                    "summarizeBy": "str"  # Optional. Optional.
                                      The aggregate function to use for summarizing this column.
                                }
                            ],
                            "name": "str",  # The table name. Required.
                            "description": "str",  # Optional. The table description.
                            "isHidden": bool,  # Optional. Optional. Whether this dataset
                              table is hidden.
                            "measures": [
                                {
                                    "expression": "str",  # A valid DAX
                                      expression. Required.
                                    "name": "str",  # The measure name. Required.
                                    "description": "str",  # Optional. Optional.
                                      The measure description.
                                    "formatString": "str",  # Optional. Optional.
                                      A string describing how the value should be formatted when it's
                                      displayed as specified in `FORMAT_STRING
                                      <https://docs.microsoft.com/analysis-services/multidimensional-models/mdx/mdx-cell-properties-format-string-contents>`_.
                                    "isHidden": bool  # Optional. Optional.
                                      Whether the measure is hidden.
                                }
                            ],
                            "rows": [
                                {
                                    "id": "str"  # Optional. The unique row ID.
                                }
                            ],
                            "source": [
                                {
                                    "expression": "str"  # The source expression.
                                      Required.
                                }
                            ]
                        }
                    ],
                    "datasources": [
                        {
                            "connectionDetails": {
                                "account": "str",  # Optional. The connection
                                  account.
                                "classInfo": "str",  # Optional. The connection class
                                  information.
                                "database": "str",  # Optional. The connection
                                  database.
                                "domain": "str",  # Optional. The connection domain.
                                "emailAddress": "str",  # Optional. The connection
                                  email address.
                                "kind": "str",  # Optional. The connection kind.
                                "loginServer": "str",  # Optional. The connection
                                  login server.
                                "path": "str",  # Optional. The connection path.
                                "server": "str",  # Optional. The connection server.
                                "url": "str"  # Optional. The connection URL.
                            },
                            "connectionString": "str",  # Optional. (Deprecated) The data
                              source connection string. Available only for DirectQuery.
                            "datasourceId": "str",  # Optional. The bound data source ID,
                              which is empty when not bound to a gateway.
                            "datasourceType": "str",  # Optional. The data source type.
                            "gatewayId": "str",  # Optional. The bound gateway ID, which
                              is empty when not bound to a gateway. When using a gateway cluster, the
                              gateway ID refers to the primary (first) gateway in the cluster and is
                              similar to the gateway cluster ID.
                            "name": "str"  # Optional. (Deprecated) The data source name.
                              Available only for DirectQuery.
                        }
                    ],
                    "defaultMode": "str",  # Optional. The dataset mode or type. Known values
                      are: "AsAzure", "AsOnPrem", "Push", "Streaming", and "PushStreaming".
                    "relationships": [
                        {
                            "fromColumn": "str",  # The name of the foreign key column.
                              Required.
                            "fromTable": "str",  # The name of the foreign key table.
                              Required.
                            "name": "str",  # The relationship name and identifier.
                              Required.
                            "toColumn": "str",  # The name of the primary key column.
                              Required.
                            "toTable": "str",  # The name of the primary key table.
                              Required.
                            "crossFilteringBehavior": "OneDirection"  # Optional. Default
                              value is "OneDirection". The filter direction of the relationship. Known
                              values are: "OneDirection", "BothDirections", and "Automatic".
                        }
                    ]
                }

                # response body for status code(s): 201, 202
                response == {
                    "id": "str",  # The dataset ID. Required.
                    "ContentProviderType": "str",  # Optional. The content provider type for the
                      dataset.
                    "CreateReportEmbedURL": "str",  # Optional. The dataset create report embed
                      URL.
                    "CreatedDate": "2020-02-20 00:00:00",  # Optional. The dataset creation date
                      and time.
                    "Encryption": {
                        "EncryptionStatus": "str"  # Optional. Dataset encryption status.
                          Known values are: "Unknown", "NotSupported", "InSyncWithWorkspace", and
                          "NotInSyncWithWorkspace".
                    },
                    "IsEffectiveIdentityRequired": bool,  # Optional. Whether the dataset
                      requires an effective identity, which you must send in a `GenerateToken
                      </rest/api/power-bi/embed-token/generate-token>`_ API call.
                    "IsEffectiveIdentityRolesRequired": bool,  # Optional. Whether row-level
                      security is defined inside the Power BI .pbix file. If so, you must specify a
                      role.
                    "IsInPlaceSharingEnabled": bool,  # Optional. Whether the dataset can be
                      shared with external users to be consumed in their own tenant.
                    "IsOnPremGatewayRequired": bool,  # Optional. Whether the dataset requires an
                      on-premises data gateway.
                    "IsRefreshable": bool,  # Optional. Whether the dataset is refreshable or
                      not. A Power BI refreshable dataset is a dataset that has been refreshed at least
                      once, or for which a valid refresh schedule exists.
                    "QnaEmbedURL": "str",  # Optional. The dataset Q&A embed URL.
                    "addRowsAPIEnabled": bool,  # Optional. Whether the dataset allows adding new
                      rows.
                    "configuredBy": "str",  # Optional. The dataset owner.
                    "description": "str",  # Optional. The dataset description.
                    "name": "str",  # Optional. The dataset name.
                    "queryScaleOutSettings": {
                        "autoSyncReadOnlyReplicas": bool,  # Optional. Whether the dataset
                          automatically syncs read-only replicas.
                        "maxReadOnlyReplicas": 0  # Optional. Maximum number of read-only
                          replicas for the dataset (0-64, -1 for automatic number of replicas).
                    },
                    "targetStorageMode": "str",  # Optional. The dataset storage mode.
                    "upstreamDataflows": [
                        {
                            "groupId": "str",  # Optional. The target group ID.
                            "targetDataflowId": "str"  # Optional. The target dataflow
                              ID.
                        }
                    ],
                    "users": [
                        {
                            "datasetUserAccessRight": "str",  # The access right that the
                              user has for the dataset (permission level). Required. Known values are:
                              "None", "Read", "ReadWrite", "ReadReshare", "ReadWriteReshare",
                              "ReadExplore", "ReadReshareExplore", "ReadWriteExplore", and
                              "ReadWriteReshareExplore".
                            "identifier": "str",  # Identifier of the principal.
                              Required.
                            "principalType": "str",  # The principal type. Required.
                              Known values are: "None", "User", "Group", and "App".
                            "displayName": "str",  # Optional. Display name of the
                              principal.
                            "emailAddress": "str",  # Optional. Email address of the
                              user.
                            "graphId": "str",  # Optional. Identifier of the principal in
                              Microsoft Graph. Only available for admin APIs.
                            "profile": {
                                "id": "str",  # The service principal profile ID.
                                  Required.
                                "displayName": "str"  # Optional. The service
                                  principal profile name.
                            },
                            "userType": "str"  # Optional. Type of the user.
                        }
                    ],
                    "webUrl": "str"  # Optional. The web URL of the dataset.
                }
        """

    @overload
    async def post_dataset_in_group(
        self,
        group_id: str,
        dataset: IO,
        *,
        default_retention_policy: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Creates a new dataset in the specified workspace.

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------

        This API call only supports **push datasets**. For a complete list of limitations, see `Push
        datasets limitations </power-bi/developer/embedded/push-datasets-limitations>`_.
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataset: Create dataset parameters. Required.
        :type dataset: IO
        :keyword default_retention_policy: The default retention policy. Known values are: "None" and
         "basicFIFO". Default value is None.
        :paramtype default_retention_policy: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201, 202
                response == {
                    "id": "str",  # The dataset ID. Required.
                    "ContentProviderType": "str",  # Optional. The content provider type for the
                      dataset.
                    "CreateReportEmbedURL": "str",  # Optional. The dataset create report embed
                      URL.
                    "CreatedDate": "2020-02-20 00:00:00",  # Optional. The dataset creation date
                      and time.
                    "Encryption": {
                        "EncryptionStatus": "str"  # Optional. Dataset encryption status.
                          Known values are: "Unknown", "NotSupported", "InSyncWithWorkspace", and
                          "NotInSyncWithWorkspace".
                    },
                    "IsEffectiveIdentityRequired": bool,  # Optional. Whether the dataset
                      requires an effective identity, which you must send in a `GenerateToken
                      </rest/api/power-bi/embed-token/generate-token>`_ API call.
                    "IsEffectiveIdentityRolesRequired": bool,  # Optional. Whether row-level
                      security is defined inside the Power BI .pbix file. If so, you must specify a
                      role.
                    "IsInPlaceSharingEnabled": bool,  # Optional. Whether the dataset can be
                      shared with external users to be consumed in their own tenant.
                    "IsOnPremGatewayRequired": bool,  # Optional. Whether the dataset requires an
                      on-premises data gateway.
                    "IsRefreshable": bool,  # Optional. Whether the dataset is refreshable or
                      not. A Power BI refreshable dataset is a dataset that has been refreshed at least
                      once, or for which a valid refresh schedule exists.
                    "QnaEmbedURL": "str",  # Optional. The dataset Q&A embed URL.
                    "addRowsAPIEnabled": bool,  # Optional. Whether the dataset allows adding new
                      rows.
                    "configuredBy": "str",  # Optional. The dataset owner.
                    "description": "str",  # Optional. The dataset description.
                    "name": "str",  # Optional. The dataset name.
                    "queryScaleOutSettings": {
                        "autoSyncReadOnlyReplicas": bool,  # Optional. Whether the dataset
                          automatically syncs read-only replicas.
                        "maxReadOnlyReplicas": 0  # Optional. Maximum number of read-only
                          replicas for the dataset (0-64, -1 for automatic number of replicas).
                    },
                    "targetStorageMode": "str",  # Optional. The dataset storage mode.
                    "upstreamDataflows": [
                        {
                            "groupId": "str",  # Optional. The target group ID.
                            "targetDataflowId": "str"  # Optional. The target dataflow
                              ID.
                        }
                    ],
                    "users": [
                        {
                            "datasetUserAccessRight": "str",  # The access right that the
                              user has for the dataset (permission level). Required. Known values are:
                              "None", "Read", "ReadWrite", "ReadReshare", "ReadWriteReshare",
                              "ReadExplore", "ReadReshareExplore", "ReadWriteExplore", and
                              "ReadWriteReshareExplore".
                            "identifier": "str",  # Identifier of the principal.
                              Required.
                            "principalType": "str",  # The principal type. Required.
                              Known values are: "None", "User", "Group", and "App".
                            "displayName": "str",  # Optional. Display name of the
                              principal.
                            "emailAddress": "str",  # Optional. Email address of the
                              user.
                            "graphId": "str",  # Optional. Identifier of the principal in
                              Microsoft Graph. Only available for admin APIs.
                            "profile": {
                                "id": "str",  # The service principal profile ID.
                                  Required.
                                "displayName": "str"  # Optional. The service
                                  principal profile name.
                            },
                            "userType": "str"  # Optional. Type of the user.
                        }
                    ],
                    "webUrl": "str"  # Optional. The web URL of the dataset.
                }
        """

    @distributed_trace_async
    async def post_dataset_in_group(
        self, group_id: str, dataset: Union[JSON, IO], *, default_retention_policy: Optional[str] = None, **kwargs: Any
    ) -> JSON:
        """Creates a new dataset in the specified workspace.

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------

        This API call only supports **push datasets**. For a complete list of limitations, see `Push
        datasets limitations </power-bi/developer/embedded/push-datasets-limitations>`_.
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataset: Create dataset parameters. Is either a JSON type or a IO type. Required.
        :type dataset: JSON or IO
        :keyword default_retention_policy: The default retention policy. Known values are: "None" and
         "basicFIFO". Default value is None.
        :paramtype default_retention_policy: str
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                dataset = {
                    "name": "str",  # The dataset name. Required.
                    "tables": [
                        {
                            "columns": [
                                {
                                    "dataType": "str",  # The column data type.
                                      Required.
                                    "name": "str",  # The column name. Required.
                                    "dataCategory": "str",  # Optional. Optional.
                                      The string value to be used for the data category which describes
                                      the data within this column.
                                    "formatString": "str",  # Optional. Optional.
                                      The format of the column as specified in `FORMAT_STRING
                                      <https://docs.microsoft.com/analysis-services/multidimensional-models/mdx/mdx-cell-properties-format-string-contents>`_.
                                    "isHidden": bool,  # Optional. Optional.
                                      Whether the column is hidden. The default is ``false``.
                                    "sortByColumn": "str",  # Optional. Optional.
                                      String name of a column in the same table to be used to order the
                                      current column.
                                    "summarizeBy": "str"  # Optional. Optional.
                                      The aggregate function to use for summarizing this column.
                                }
                            ],
                            "name": "str",  # The table name. Required.
                            "description": "str",  # Optional. The table description.
                            "isHidden": bool,  # Optional. Optional. Whether this dataset
                              table is hidden.
                            "measures": [
                                {
                                    "expression": "str",  # A valid DAX
                                      expression. Required.
                                    "name": "str",  # The measure name. Required.
                                    "description": "str",  # Optional. Optional.
                                      The measure description.
                                    "formatString": "str",  # Optional. Optional.
                                      A string describing how the value should be formatted when it's
                                      displayed as specified in `FORMAT_STRING
                                      <https://docs.microsoft.com/analysis-services/multidimensional-models/mdx/mdx-cell-properties-format-string-contents>`_.
                                    "isHidden": bool  # Optional. Optional.
                                      Whether the measure is hidden.
                                }
                            ],
                            "rows": [
                                {
                                    "id": "str"  # Optional. The unique row ID.
                                }
                            ],
                            "source": [
                                {
                                    "expression": "str"  # The source expression.
                                      Required.
                                }
                            ]
                        }
                    ],
                    "datasources": [
                        {
                            "connectionDetails": {
                                "account": "str",  # Optional. The connection
                                  account.
                                "classInfo": "str",  # Optional. The connection class
                                  information.
                                "database": "str",  # Optional. The connection
                                  database.
                                "domain": "str",  # Optional. The connection domain.
                                "emailAddress": "str",  # Optional. The connection
                                  email address.
                                "kind": "str",  # Optional. The connection kind.
                                "loginServer": "str",  # Optional. The connection
                                  login server.
                                "path": "str",  # Optional. The connection path.
                                "server": "str",  # Optional. The connection server.
                                "url": "str"  # Optional. The connection URL.
                            },
                            "connectionString": "str",  # Optional. (Deprecated) The data
                              source connection string. Available only for DirectQuery.
                            "datasourceId": "str",  # Optional. The bound data source ID,
                              which is empty when not bound to a gateway.
                            "datasourceType": "str",  # Optional. The data source type.
                            "gatewayId": "str",  # Optional. The bound gateway ID, which
                              is empty when not bound to a gateway. When using a gateway cluster, the
                              gateway ID refers to the primary (first) gateway in the cluster and is
                              similar to the gateway cluster ID.
                            "name": "str"  # Optional. (Deprecated) The data source name.
                              Available only for DirectQuery.
                        }
                    ],
                    "defaultMode": "str",  # Optional. The dataset mode or type. Known values
                      are: "AsAzure", "AsOnPrem", "Push", "Streaming", and "PushStreaming".
                    "relationships": [
                        {
                            "fromColumn": "str",  # The name of the foreign key column.
                              Required.
                            "fromTable": "str",  # The name of the foreign key table.
                              Required.
                            "name": "str",  # The relationship name and identifier.
                              Required.
                            "toColumn": "str",  # The name of the primary key column.
                              Required.
                            "toTable": "str",  # The name of the primary key table.
                              Required.
                            "crossFilteringBehavior": "OneDirection"  # Optional. Default
                              value is "OneDirection". The filter direction of the relationship. Known
                              values are: "OneDirection", "BothDirections", and "Automatic".
                        }
                    ]
                }

                # response body for status code(s): 201, 202
                response == {
                    "id": "str",  # The dataset ID. Required.
                    "ContentProviderType": "str",  # Optional. The content provider type for the
                      dataset.
                    "CreateReportEmbedURL": "str",  # Optional. The dataset create report embed
                      URL.
                    "CreatedDate": "2020-02-20 00:00:00",  # Optional. The dataset creation date
                      and time.
                    "Encryption": {
                        "EncryptionStatus": "str"  # Optional. Dataset encryption status.
                          Known values are: "Unknown", "NotSupported", "InSyncWithWorkspace", and
                          "NotInSyncWithWorkspace".
                    },
                    "IsEffectiveIdentityRequired": bool,  # Optional. Whether the dataset
                      requires an effective identity, which you must send in a `GenerateToken
                      </rest/api/power-bi/embed-token/generate-token>`_ API call.
                    "IsEffectiveIdentityRolesRequired": bool,  # Optional. Whether row-level
                      security is defined inside the Power BI .pbix file. If so, you must specify a
                      role.
                    "IsInPlaceSharingEnabled": bool,  # Optional. Whether the dataset can be
                      shared with external users to be consumed in their own tenant.
                    "IsOnPremGatewayRequired": bool,  # Optional. Whether the dataset requires an
                      on-premises data gateway.
                    "IsRefreshable": bool,  # Optional. Whether the dataset is refreshable or
                      not. A Power BI refreshable dataset is a dataset that has been refreshed at least
                      once, or for which a valid refresh schedule exists.
                    "QnaEmbedURL": "str",  # Optional. The dataset Q&A embed URL.
                    "addRowsAPIEnabled": bool,  # Optional. Whether the dataset allows adding new
                      rows.
                    "configuredBy": "str",  # Optional. The dataset owner.
                    "description": "str",  # Optional. The dataset description.
                    "name": "str",  # Optional. The dataset name.
                    "queryScaleOutSettings": {
                        "autoSyncReadOnlyReplicas": bool,  # Optional. Whether the dataset
                          automatically syncs read-only replicas.
                        "maxReadOnlyReplicas": 0  # Optional. Maximum number of read-only
                          replicas for the dataset (0-64, -1 for automatic number of replicas).
                    },
                    "targetStorageMode": "str",  # Optional. The dataset storage mode.
                    "upstreamDataflows": [
                        {
                            "groupId": "str",  # Optional. The target group ID.
                            "targetDataflowId": "str"  # Optional. The target dataflow
                              ID.
                        }
                    ],
                    "users": [
                        {
                            "datasetUserAccessRight": "str",  # The access right that the
                              user has for the dataset (permission level). Required. Known values are:
                              "None", "Read", "ReadWrite", "ReadReshare", "ReadWriteReshare",
                              "ReadExplore", "ReadReshareExplore", "ReadWriteExplore", and
                              "ReadWriteReshareExplore".
                            "identifier": "str",  # Identifier of the principal.
                              Required.
                            "principalType": "str",  # The principal type. Required.
                              Known values are: "None", "User", "Group", and "App".
                            "displayName": "str",  # Optional. Display name of the
                              principal.
                            "emailAddress": "str",  # Optional. Email address of the
                              user.
                            "graphId": "str",  # Optional. Identifier of the principal in
                              Microsoft Graph. Only available for admin APIs.
                            "profile": {
                                "id": "str",  # The service principal profile ID.
                                  Required.
                                "displayName": "str"  # Optional. The service
                                  principal profile name.
                            },
                            "userType": "str"  # Optional. Type of the user.
                        }
                    ],
                    "webUrl": "str"  # Optional. The web URL of the dataset.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(dataset, (IOBase, bytes)):
            _content = dataset
        else:
            _json = dataset

        _request = build_datasets_post_dataset_in_group_request(
            group_id=group_id,
            default_retention_policy=default_retention_policy,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 202]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 202:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_dataset_to_dataflows_links_in_group(self, group_id: str, **kwargs: Any) -> JSON:
        """Returns a list of upstream dataflows for datasets from the specified workspace.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Dataset.ReadWrite.All or Dataset.Read.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional.
                    "value": [
                        {
                            "dataflowObjectId": "str",  # Optional. The dataflow object
                              ID.
                            "datasetObjectId": "str",  # Optional. The dataset object ID.
                            "workspaceObjectId": "str"  # Optional. The workspace object
                              ID.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_datasets_get_dataset_to_dataflows_links_in_group_request(
            group_id=group_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_dataset_in_group(self, group_id: str, dataset_id: str, **kwargs: Any) -> JSON:
        """Returns the specified dataset from the specified workspace.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Dataset.ReadWrite.All or Dataset.Read.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # The dataset ID. Required.
                    "ContentProviderType": "str",  # Optional. The content provider type for the
                      dataset.
                    "CreateReportEmbedURL": "str",  # Optional. The dataset create report embed
                      URL.
                    "CreatedDate": "2020-02-20 00:00:00",  # Optional. The dataset creation date
                      and time.
                    "Encryption": {
                        "EncryptionStatus": "str"  # Optional. Dataset encryption status.
                          Known values are: "Unknown", "NotSupported", "InSyncWithWorkspace", and
                          "NotInSyncWithWorkspace".
                    },
                    "IsEffectiveIdentityRequired": bool,  # Optional. Whether the dataset
                      requires an effective identity, which you must send in a `GenerateToken
                      </rest/api/power-bi/embed-token/generate-token>`_ API call.
                    "IsEffectiveIdentityRolesRequired": bool,  # Optional. Whether row-level
                      security is defined inside the Power BI .pbix file. If so, you must specify a
                      role.
                    "IsInPlaceSharingEnabled": bool,  # Optional. Whether the dataset can be
                      shared with external users to be consumed in their own tenant.
                    "IsOnPremGatewayRequired": bool,  # Optional. Whether the dataset requires an
                      on-premises data gateway.
                    "IsRefreshable": bool,  # Optional. Whether the dataset is refreshable or
                      not. A Power BI refreshable dataset is a dataset that has been refreshed at least
                      once, or for which a valid refresh schedule exists.
                    "QnaEmbedURL": "str",  # Optional. The dataset Q&A embed URL.
                    "addRowsAPIEnabled": bool,  # Optional. Whether the dataset allows adding new
                      rows.
                    "configuredBy": "str",  # Optional. The dataset owner.
                    "description": "str",  # Optional. The dataset description.
                    "name": "str",  # Optional. The dataset name.
                    "queryScaleOutSettings": {
                        "autoSyncReadOnlyReplicas": bool,  # Optional. Whether the dataset
                          automatically syncs read-only replicas.
                        "maxReadOnlyReplicas": 0  # Optional. Maximum number of read-only
                          replicas for the dataset (0-64, -1 for automatic number of replicas).
                    },
                    "targetStorageMode": "str",  # Optional. The dataset storage mode.
                    "upstreamDataflows": [
                        {
                            "groupId": "str",  # Optional. The target group ID.
                            "targetDataflowId": "str"  # Optional. The target dataflow
                              ID.
                        }
                    ],
                    "users": [
                        {
                            "datasetUserAccessRight": "str",  # The access right that the
                              user has for the dataset (permission level). Required. Known values are:
                              "None", "Read", "ReadWrite", "ReadReshare", "ReadWriteReshare",
                              "ReadExplore", "ReadReshareExplore", "ReadWriteExplore", and
                              "ReadWriteReshareExplore".
                            "identifier": "str",  # Identifier of the principal.
                              Required.
                            "principalType": "str",  # The principal type. Required.
                              Known values are: "None", "User", "Group", and "App".
                            "displayName": "str",  # Optional. Display name of the
                              principal.
                            "emailAddress": "str",  # Optional. Email address of the
                              user.
                            "graphId": "str",  # Optional. Identifier of the principal in
                              Microsoft Graph. Only available for admin APIs.
                            "profile": {
                                "id": "str",  # The service principal profile ID.
                                  Required.
                                "displayName": "str"  # Optional. The service
                                  principal profile name.
                            },
                            "userType": "str"  # Optional. Type of the user.
                        }
                    ],
                    "webUrl": "str"  # Optional. The web URL of the dataset.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_datasets_get_dataset_in_group_request(
            group_id=group_id,
            dataset_id=dataset_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def update_dataset_in_group(  # pylint: disable=inconsistent-return-statements
        self,
        group_id: str,
        dataset_id: str,
        update_dataset_request: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Updates the properties for the specified dataset from the specified workspace.

        Permissions
        -----------

        The user must be the dataset owner.

        Required Scope
        --------------

        Dataset.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param update_dataset_request: Update dataset request parameters. Required.
        :type update_dataset_request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                update_dataset_request = {
                    "queryScaleOutSettings": {
                        "autoSyncReadOnlyReplicas": bool,  # Optional. Whether the dataset
                          automatically syncs read-only replicas.
                        "maxReadOnlyReplicas": 0  # Optional. Maximum number of read-only
                          replicas for the dataset (0-64, -1 for automatic number of replicas).
                    },
                    "targetStorageMode": "str"  # Optional. The dataset storage mode.
                }
        """

    @overload
    async def update_dataset_in_group(  # pylint: disable=inconsistent-return-statements
        self,
        group_id: str,
        dataset_id: str,
        update_dataset_request: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Updates the properties for the specified dataset from the specified workspace.

        Permissions
        -----------

        The user must be the dataset owner.

        Required Scope
        --------------

        Dataset.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param update_dataset_request: Update dataset request parameters. Required.
        :type update_dataset_request: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_dataset_in_group(  # pylint: disable=inconsistent-return-statements
        self, group_id: str, dataset_id: str, update_dataset_request: Union[JSON, IO], **kwargs: Any
    ) -> None:
        """Updates the properties for the specified dataset from the specified workspace.

        Permissions
        -----------

        The user must be the dataset owner.

        Required Scope
        --------------

        Dataset.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param update_dataset_request: Update dataset request parameters. Is either a JSON type or a IO
         type. Required.
        :type update_dataset_request: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                update_dataset_request = {
                    "queryScaleOutSettings": {
                        "autoSyncReadOnlyReplicas": bool,  # Optional. Whether the dataset
                          automatically syncs read-only replicas.
                        "maxReadOnlyReplicas": 0  # Optional. Maximum number of read-only
                          replicas for the dataset (0-64, -1 for automatic number of replicas).
                    },
                    "targetStorageMode": "str"  # Optional. The dataset storage mode.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(update_dataset_request, (IOBase, bytes)):
            _content = update_dataset_request
        else:
            _json = update_dataset_request

        _request = build_datasets_update_dataset_in_group_request(
            group_id=group_id,
            dataset_id=dataset_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def delete_dataset_in_group(  # pylint: disable=inconsistent-return-statements
        self, group_id: str, dataset_id: str, **kwargs: Any
    ) -> None:
        """Deletes the specified dataset from the specified workspace.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Dataset.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_datasets_delete_dataset_in_group_request(
            group_id=group_id,
            dataset_id=dataset_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get_tables_in_group(self, group_id: str, dataset_id: str, **kwargs: Any) -> JSON:
        """Returns a list of tables within the specified dataset from the specified workspace.

        Required Scope
        --------------

        Limitations
        -----------

        This API call only supports **push datasets**. For a complete list of limitations, see `Push
        datasets limitations </power-bi/developer/embedded/push-datasets-limitations>`_.
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional. OData context.
                    "value": [
                        {
                            "columns": [
                                {
                                    "dataType": "str",  # The column data type.
                                      Required.
                                    "name": "str",  # The column name. Required.
                                    "dataCategory": "str",  # Optional. Optional.
                                      The string value to be used for the data category which describes
                                      the data within this column.
                                    "formatString": "str",  # Optional. Optional.
                                      The format of the column as specified in `FORMAT_STRING
                                      <https://docs.microsoft.com/analysis-services/multidimensional-models/mdx/mdx-cell-properties-format-string-contents>`_.
                                    "isHidden": bool,  # Optional. Optional.
                                      Whether the column is hidden. The default is ``false``.
                                    "sortByColumn": "str",  # Optional. Optional.
                                      String name of a column in the same table to be used to order the
                                      current column.
                                    "summarizeBy": "str"  # Optional. Optional.
                                      The aggregate function to use for summarizing this column.
                                }
                            ],
                            "name": "str",  # The table name. Required.
                            "description": "str",  # Optional. The table description.
                            "isHidden": bool,  # Optional. Optional. Whether this dataset
                              table is hidden.
                            "measures": [
                                {
                                    "expression": "str",  # A valid DAX
                                      expression. Required.
                                    "name": "str",  # The measure name. Required.
                                    "description": "str",  # Optional. Optional.
                                      The measure description.
                                    "formatString": "str",  # Optional. Optional.
                                      A string describing how the value should be formatted when it's
                                      displayed as specified in `FORMAT_STRING
                                      <https://docs.microsoft.com/analysis-services/multidimensional-models/mdx/mdx-cell-properties-format-string-contents>`_.
                                    "isHidden": bool  # Optional. Optional.
                                      Whether the measure is hidden.
                                }
                            ],
                            "rows": [
                                {
                                    "id": "str"  # Optional. The unique row ID.
                                }
                            ],
                            "source": [
                                {
                                    "expression": "str"  # The source expression.
                                      Required.
                                }
                            ]
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_datasets_get_tables_in_group_request(
            group_id=group_id,
            dataset_id=dataset_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def put_table_in_group(
        self,
        group_id: str,
        dataset_id: str,
        table_name: str,
        request_message: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Updates the metadata and schema for the specified table within the specified dataset from the
        specified workspace.

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------

        This API call only supports **push datasets**.
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param table_name: The table name. Required.
        :type table_name: str
        :param request_message: The request message. Required.
        :type request_message: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                request_message = {
                    "columns": [
                        {
                            "dataType": "str",  # The column data type. Required.
                            "name": "str",  # The column name. Required.
                            "dataCategory": "str",  # Optional. Optional. The string
                              value to be used for the data category which describes the data within
                              this column.
                            "formatString": "str",  # Optional. Optional. The format of
                              the column as specified in `FORMAT_STRING
                              <https://docs.microsoft.com/analysis-services/multidimensional-models/mdx/mdx-cell-properties-format-string-contents>`_.
                            "isHidden": bool,  # Optional. Optional. Whether the column
                              is hidden. The default is ``false``.
                            "sortByColumn": "str",  # Optional. Optional. String name of
                              a column in the same table to be used to order the current column.
                            "summarizeBy": "str"  # Optional. Optional. The aggregate
                              function to use for summarizing this column.
                        }
                    ],
                    "name": "str",  # The table name. Required.
                    "description": "str",  # Optional. The table description.
                    "isHidden": bool,  # Optional. Optional. Whether this dataset table is
                      hidden.
                    "measures": [
                        {
                            "expression": "str",  # A valid DAX expression. Required.
                            "name": "str",  # The measure name. Required.
                            "description": "str",  # Optional. Optional. The measure
                              description.
                            "formatString": "str",  # Optional. Optional. A string
                              describing how the value should be formatted when it's displayed as
                              specified in `FORMAT_STRING
                              <https://docs.microsoft.com/analysis-services/multidimensional-models/mdx/mdx-cell-properties-format-string-contents>`_.
                            "isHidden": bool  # Optional. Optional. Whether the measure
                              is hidden.
                        }
                    ],
                    "rows": [
                        {
                            "id": "str"  # Optional. The unique row ID.
                        }
                    ],
                    "source": [
                        {
                            "expression": "str"  # The source expression. Required.
                        }
                    ]
                }

                # response body for status code(s): 200
                response == {
                    "columns": [
                        {
                            "dataType": "str",  # The column data type. Required.
                            "name": "str",  # The column name. Required.
                            "dataCategory": "str",  # Optional. Optional. The string
                              value to be used for the data category which describes the data within
                              this column.
                            "formatString": "str",  # Optional. Optional. The format of
                              the column as specified in `FORMAT_STRING
                              <https://docs.microsoft.com/analysis-services/multidimensional-models/mdx/mdx-cell-properties-format-string-contents>`_.
                            "isHidden": bool,  # Optional. Optional. Whether the column
                              is hidden. The default is ``false``.
                            "sortByColumn": "str",  # Optional. Optional. String name of
                              a column in the same table to be used to order the current column.
                            "summarizeBy": "str"  # Optional. Optional. The aggregate
                              function to use for summarizing this column.
                        }
                    ],
                    "name": "str",  # The table name. Required.
                    "description": "str",  # Optional. The table description.
                    "isHidden": bool,  # Optional. Optional. Whether this dataset table is
                      hidden.
                    "measures": [
                        {
                            "expression": "str",  # A valid DAX expression. Required.
                            "name": "str",  # The measure name. Required.
                            "description": "str",  # Optional. Optional. The measure
                              description.
                            "formatString": "str",  # Optional. Optional. A string
                              describing how the value should be formatted when it's displayed as
                              specified in `FORMAT_STRING
                              <https://docs.microsoft.com/analysis-services/multidimensional-models/mdx/mdx-cell-properties-format-string-contents>`_.
                            "isHidden": bool  # Optional. Optional. Whether the measure
                              is hidden.
                        }
                    ],
                    "rows": [
                        {
                            "id": "str"  # Optional. The unique row ID.
                        }
                    ],
                    "source": [
                        {
                            "expression": "str"  # The source expression. Required.
                        }
                    ]
                }
        """

    @overload
    async def put_table_in_group(
        self,
        group_id: str,
        dataset_id: str,
        table_name: str,
        request_message: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Updates the metadata and schema for the specified table within the specified dataset from the
        specified workspace.

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------

        This API call only supports **push datasets**.
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param table_name: The table name. Required.
        :type table_name: str
        :param request_message: The request message. Required.
        :type request_message: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "columns": [
                        {
                            "dataType": "str",  # The column data type. Required.
                            "name": "str",  # The column name. Required.
                            "dataCategory": "str",  # Optional. Optional. The string
                              value to be used for the data category which describes the data within
                              this column.
                            "formatString": "str",  # Optional. Optional. The format of
                              the column as specified in `FORMAT_STRING
                              <https://docs.microsoft.com/analysis-services/multidimensional-models/mdx/mdx-cell-properties-format-string-contents>`_.
                            "isHidden": bool,  # Optional. Optional. Whether the column
                              is hidden. The default is ``false``.
                            "sortByColumn": "str",  # Optional. Optional. String name of
                              a column in the same table to be used to order the current column.
                            "summarizeBy": "str"  # Optional. Optional. The aggregate
                              function to use for summarizing this column.
                        }
                    ],
                    "name": "str",  # The table name. Required.
                    "description": "str",  # Optional. The table description.
                    "isHidden": bool,  # Optional. Optional. Whether this dataset table is
                      hidden.
                    "measures": [
                        {
                            "expression": "str",  # A valid DAX expression. Required.
                            "name": "str",  # The measure name. Required.
                            "description": "str",  # Optional. Optional. The measure
                              description.
                            "formatString": "str",  # Optional. Optional. A string
                              describing how the value should be formatted when it's displayed as
                              specified in `FORMAT_STRING
                              <https://docs.microsoft.com/analysis-services/multidimensional-models/mdx/mdx-cell-properties-format-string-contents>`_.
                            "isHidden": bool  # Optional. Optional. Whether the measure
                              is hidden.
                        }
                    ],
                    "rows": [
                        {
                            "id": "str"  # Optional. The unique row ID.
                        }
                    ],
                    "source": [
                        {
                            "expression": "str"  # The source expression. Required.
                        }
                    ]
                }
        """

    @distributed_trace_async
    async def put_table_in_group(
        self, group_id: str, dataset_id: str, table_name: str, request_message: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Updates the metadata and schema for the specified table within the specified dataset from the
        specified workspace.

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------

        This API call only supports **push datasets**.
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param table_name: The table name. Required.
        :type table_name: str
        :param request_message: The request message. Is either a JSON type or a IO type. Required.
        :type request_message: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                request_message = {
                    "columns": [
                        {
                            "dataType": "str",  # The column data type. Required.
                            "name": "str",  # The column name. Required.
                            "dataCategory": "str",  # Optional. Optional. The string
                              value to be used for the data category which describes the data within
                              this column.
                            "formatString": "str",  # Optional. Optional. The format of
                              the column as specified in `FORMAT_STRING
                              <https://docs.microsoft.com/analysis-services/multidimensional-models/mdx/mdx-cell-properties-format-string-contents>`_.
                            "isHidden": bool,  # Optional. Optional. Whether the column
                              is hidden. The default is ``false``.
                            "sortByColumn": "str",  # Optional. Optional. String name of
                              a column in the same table to be used to order the current column.
                            "summarizeBy": "str"  # Optional. Optional. The aggregate
                              function to use for summarizing this column.
                        }
                    ],
                    "name": "str",  # The table name. Required.
                    "description": "str",  # Optional. The table description.
                    "isHidden": bool,  # Optional. Optional. Whether this dataset table is
                      hidden.
                    "measures": [
                        {
                            "expression": "str",  # A valid DAX expression. Required.
                            "name": "str",  # The measure name. Required.
                            "description": "str",  # Optional. Optional. The measure
                              description.
                            "formatString": "str",  # Optional. Optional. A string
                              describing how the value should be formatted when it's displayed as
                              specified in `FORMAT_STRING
                              <https://docs.microsoft.com/analysis-services/multidimensional-models/mdx/mdx-cell-properties-format-string-contents>`_.
                            "isHidden": bool  # Optional. Optional. Whether the measure
                              is hidden.
                        }
                    ],
                    "rows": [
                        {
                            "id": "str"  # Optional. The unique row ID.
                        }
                    ],
                    "source": [
                        {
                            "expression": "str"  # The source expression. Required.
                        }
                    ]
                }

                # response body for status code(s): 200
                response == {
                    "columns": [
                        {
                            "dataType": "str",  # The column data type. Required.
                            "name": "str",  # The column name. Required.
                            "dataCategory": "str",  # Optional. Optional. The string
                              value to be used for the data category which describes the data within
                              this column.
                            "formatString": "str",  # Optional. Optional. The format of
                              the column as specified in `FORMAT_STRING
                              <https://docs.microsoft.com/analysis-services/multidimensional-models/mdx/mdx-cell-properties-format-string-contents>`_.
                            "isHidden": bool,  # Optional. Optional. Whether the column
                              is hidden. The default is ``false``.
                            "sortByColumn": "str",  # Optional. Optional. String name of
                              a column in the same table to be used to order the current column.
                            "summarizeBy": "str"  # Optional. Optional. The aggregate
                              function to use for summarizing this column.
                        }
                    ],
                    "name": "str",  # The table name. Required.
                    "description": "str",  # Optional. The table description.
                    "isHidden": bool,  # Optional. Optional. Whether this dataset table is
                      hidden.
                    "measures": [
                        {
                            "expression": "str",  # A valid DAX expression. Required.
                            "name": "str",  # The measure name. Required.
                            "description": "str",  # Optional. Optional. The measure
                              description.
                            "formatString": "str",  # Optional. Optional. A string
                              describing how the value should be formatted when it's displayed as
                              specified in `FORMAT_STRING
                              <https://docs.microsoft.com/analysis-services/multidimensional-models/mdx/mdx-cell-properties-format-string-contents>`_.
                            "isHidden": bool  # Optional. Optional. Whether the measure
                              is hidden.
                        }
                    ],
                    "rows": [
                        {
                            "id": "str"  # Optional. The unique row ID.
                        }
                    ],
                    "source": [
                        {
                            "expression": "str"  # The source expression. Required.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(request_message, (IOBase, bytes)):
            _content = request_message
        else:
            _json = request_message

        _request = build_datasets_put_table_in_group_request(
            group_id=group_id,
            dataset_id=dataset_id,
            table_name=table_name,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def post_rows_in_group(  # pylint: disable=inconsistent-return-statements
        self,
        group_id: str,
        dataset_id: str,
        table_name: str,
        request_message: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Adds new data rows to the specified table within the specified dataset from the specified
        workspace.

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------


        * This API call only supports **push datasets**.
        * See `Power BI REST API limitations
        </power-bi/developer/automation/api-rest-api-limitations>`_.
          :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param table_name: The table name. Required.
        :type table_name: str
        :param request_message: The request message. Required.
        :type request_message: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                request_message = {
                    "rows": [
                        {}  # Optional. An array of data rows pushed to a dataset table. Each
                          element is a collection of properties represented using key-value format.
                    ]
                }
        """

    @overload
    async def post_rows_in_group(  # pylint: disable=inconsistent-return-statements
        self,
        group_id: str,
        dataset_id: str,
        table_name: str,
        request_message: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Adds new data rows to the specified table within the specified dataset from the specified
        workspace.

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------


        * This API call only supports **push datasets**.
        * See `Power BI REST API limitations
        </power-bi/developer/automation/api-rest-api-limitations>`_.
          :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param table_name: The table name. Required.
        :type table_name: str
        :param request_message: The request message. Required.
        :type request_message: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def post_rows_in_group(  # pylint: disable=inconsistent-return-statements
        self, group_id: str, dataset_id: str, table_name: str, request_message: Union[JSON, IO], **kwargs: Any
    ) -> None:
        """Adds new data rows to the specified table within the specified dataset from the specified
        workspace.

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------


        * This API call only supports **push datasets**.
        * See `Power BI REST API limitations
        </power-bi/developer/automation/api-rest-api-limitations>`_.
          :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param table_name: The table name. Required.
        :type table_name: str
        :param request_message: The request message. Is either a JSON type or a IO type. Required.
        :type request_message: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                request_message = {
                    "rows": [
                        {}  # Optional. An array of data rows pushed to a dataset table. Each
                          element is a collection of properties represented using key-value format.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(request_message, (IOBase, bytes)):
            _content = request_message
        else:
            _json = request_message

        _request = build_datasets_post_rows_in_group_request(
            group_id=group_id,
            dataset_id=dataset_id,
            table_name=table_name,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def delete_rows_in_group(  # pylint: disable=inconsistent-return-statements
        self, group_id: str, dataset_id: str, table_name: str, **kwargs: Any
    ) -> None:
        """Deletes all rows from the specified table within the specified dataset from the specified
        workspace.

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------

        This API call only supports **push datasets**. For a complete list of limitations, see `Push
        datasets limitations </power-bi/developer/embedded/push-datasets-limitations>`_.
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param table_name: The table name. Required.
        :type table_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_datasets_delete_rows_in_group_request(
            group_id=group_id,
            dataset_id=dataset_id,
            table_name=table_name,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get_refresh_history_in_group(
        self, group_id: str, dataset_id: str, *, top: Optional[int] = None, **kwargs: Any
    ) -> JSON:
        """Returns the refresh history for the specified dataset from the specified workspace.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Dataset.ReadWrite.All or Dataset.Read.All

        Limitations
        -----------

        OneDrive refresh history isn't returned.
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :keyword top: The requested number of entries in the refresh history. If not provided, the
         default is the last available 60 entries. Default value is None.
        :paramtype top: int
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional.
                    "value": [
                        {
                            "endTime": "2020-02-20 00:00:00",  # Optional. The end date
                              and time of the refresh (may be empty if a refresh is in progress).
                            "refreshType": "str",  # Optional. The type of refresh
                              request. Known values are: "Scheduled", "OnDemand", "ViaApi",
                              "ViaXmlaEndpoint", "ViaEnhancedApi", and "OnDemandTraining".
                            "requestId": "str",  # Optional. The identifier of the
                              refresh request. Provide this identifier in all service requests.
                            "serviceExceptionJson": "str",  # Optional. Failure error
                              code in JSON format (empty if no error).
                            "startTime": "2020-02-20 00:00:00",  # Optional. The start
                              date and time of the refresh.
                            "status": "str"  # Optional. * ``Unknown`` if the completion
                              state is unknown or a refresh is in progress. * ``Completed`` for a
                              successfully completed refresh. * ``Failed`` for an unsuccessful refresh
                              ("" ``serviceExceptionJson`` will contain the error code). * ``Disabled``
                              if the refresh is disabled by a selective refresh.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_datasets_get_refresh_history_in_group_request(
            group_id=group_id,
            dataset_id=dataset_id,
            top=top,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def refresh_dataset_in_group(  # pylint: disable=inconsistent-return-statements
        self,
        group_id: str,
        dataset_id: str,
        dataset_refresh_request: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Triggers a refresh for the specified dataset from the specified workspace. An `enhanced refresh
        </power-bi/connect-data/asynchronous-refresh>`_ is triggered only if a request payload other
        than ``notifyOption`` is set.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------


        * For Shared capacities, a maximum of eight requests per day, including refreshes executed by
        using scheduled refresh, can be initiated.
        * For Shared capacities, only ``notifyOption`` can be specified in the request body.
        * Enhanced refresh is not supported for shared capacities.
        * For enhanced refresh, ``notifyOption`` is not required and must be excluded from the request
        body. However, one or more parameters other than ``notifyOption`` are required.
        * For Premium capacities, the maximum requests per day is only limited by the available
        resources in the capacity. If available resources are overloaded, refreshes are throttled until
        the load is reduced. The refresh will fail if throttling exceeds 1 hour.
          :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param dataset_refresh_request: Default value is None.
        :type dataset_refresh_request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                dataset_refresh_request = {
                    "notifyOption": "str",  # Mail notification options. This parameter is not
                      applicable to enhanced refreshes or API operations with a service principal.
                      Required. Known values are: "NoNotification", "MailOnFailure", and
                      "MailOnCompletion".
                    "applyRefreshPolicy": bool,  # Optional. Determine if the policy is applied
                      or not.
                    "commitMode": "str",  # Optional. Determines if objects will be committed in
                      batches or only when complete. Known values are: "Transactional" and
                      "PartialBatch".
                    "effectiveDate": "2020-02-20 00:00:00",  # Optional. If an incremental
                      refresh policy is applied, the ``effectiveDate`` parameter overrides the current
                      date.
                    "maxParallelism": 0,  # Optional. The maximum number of threads on which to
                      run parallel processing commands.
                    "objects": [
                        {
                            "partition": "str",  # Optional. Partition to refresh.
                            "table": "str"  # Optional. Table to refresh.
                        }
                    ],
                    "retryCount": 0,  # Optional. Number of times the operation will retry before
                      failing.
                    "type": "str"  # Optional. The type of processing to perform. Known values
                      are: "Full", "ClearValues", "Calculate", "DataOnly", "Automatic", and
                      "Defragment".
                }
        """

    @overload
    async def refresh_dataset_in_group(  # pylint: disable=inconsistent-return-statements
        self,
        group_id: str,
        dataset_id: str,
        dataset_refresh_request: Optional[IO] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Triggers a refresh for the specified dataset from the specified workspace. An `enhanced refresh
        </power-bi/connect-data/asynchronous-refresh>`_ is triggered only if a request payload other
        than ``notifyOption`` is set.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------


        * For Shared capacities, a maximum of eight requests per day, including refreshes executed by
        using scheduled refresh, can be initiated.
        * For Shared capacities, only ``notifyOption`` can be specified in the request body.
        * Enhanced refresh is not supported for shared capacities.
        * For enhanced refresh, ``notifyOption`` is not required and must be excluded from the request
        body. However, one or more parameters other than ``notifyOption`` are required.
        * For Premium capacities, the maximum requests per day is only limited by the available
        resources in the capacity. If available resources are overloaded, refreshes are throttled until
        the load is reduced. The refresh will fail if throttling exceeds 1 hour.
          :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param dataset_refresh_request: Default value is None.
        :type dataset_refresh_request: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def refresh_dataset_in_group(  # pylint: disable=inconsistent-return-statements
        self, group_id: str, dataset_id: str, dataset_refresh_request: Optional[Union[JSON, IO]] = None, **kwargs: Any
    ) -> None:
        """Triggers a refresh for the specified dataset from the specified workspace. An `enhanced refresh
        </power-bi/connect-data/asynchronous-refresh>`_ is triggered only if a request payload other
        than ``notifyOption`` is set.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------


        * For Shared capacities, a maximum of eight requests per day, including refreshes executed by
        using scheduled refresh, can be initiated.
        * For Shared capacities, only ``notifyOption`` can be specified in the request body.
        * Enhanced refresh is not supported for shared capacities.
        * For enhanced refresh, ``notifyOption`` is not required and must be excluded from the request
        body. However, one or more parameters other than ``notifyOption`` are required.
        * For Premium capacities, the maximum requests per day is only limited by the available
        resources in the capacity. If available resources are overloaded, refreshes are throttled until
        the load is reduced. The refresh will fail if throttling exceeds 1 hour.
          :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param dataset_refresh_request: Is either a JSON type or a IO type. Default value is None.
        :type dataset_refresh_request: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                dataset_refresh_request = {
                    "notifyOption": "str",  # Mail notification options. This parameter is not
                      applicable to enhanced refreshes or API operations with a service principal.
                      Required. Known values are: "NoNotification", "MailOnFailure", and
                      "MailOnCompletion".
                    "applyRefreshPolicy": bool,  # Optional. Determine if the policy is applied
                      or not.
                    "commitMode": "str",  # Optional. Determines if objects will be committed in
                      batches or only when complete. Known values are: "Transactional" and
                      "PartialBatch".
                    "effectiveDate": "2020-02-20 00:00:00",  # Optional. If an incremental
                      refresh policy is applied, the ``effectiveDate`` parameter overrides the current
                      date.
                    "maxParallelism": 0,  # Optional. The maximum number of threads on which to
                      run parallel processing commands.
                    "objects": [
                        {
                            "partition": "str",  # Optional. Partition to refresh.
                            "table": "str"  # Optional. Table to refresh.
                        }
                    ],
                    "retryCount": 0,  # Optional. Number of times the operation will retry before
                      failing.
                    "type": "str"  # Optional. The type of processing to perform. Known values
                      are: "Full", "ClearValues", "Calculate", "DataOnly", "Automatic", and
                      "Defragment".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(dataset_refresh_request, (IOBase, bytes)):
            _content = dataset_refresh_request
        else:
            if dataset_refresh_request is not None:
                _json = dataset_refresh_request
            else:
                _json = None

        _request = build_datasets_refresh_dataset_in_group_request(
            group_id=group_id,
            dataset_id=dataset_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["x-ms-request-id"] = self._deserialize("str", response.headers.get("x-ms-request-id"))
        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace_async
    async def get_refresh_execution_details_in_group(
        self, group_id: str, dataset_id: str, refresh_id: str, **kwargs: Any
    ) -> JSON:
        """Returns execution details of an `enhanced refresh operation
        </power-bi/connect-data/asynchronous-refresh>`_ for the specified dataset from the specified
        workspace.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Dataset.ReadWrite.All or Dataset.Read.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param refresh_id: The refresh ID. Required.
        :type refresh_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 202
                response == {
                    "commitMode": "str",  # Optional. Determines if objects will be committed in
                      batches or only when complete. Known values are: "Transactional" and
                      "PartialBatch".
                    "currentRefreshType": "str",  # Optional. The type of processing for the
                      current iteration. This is useful when ``commitMode`` is set to ``PartialBatch``.
                      Known values are: "Full", "ClearValues", "Calculate", "DataOnly", "Automatic",
                      and "Defragment".
                    "endTime": "2020-02-20 00:00:00",  # Optional. The end date and time of the
                      refresh (may be empty if a refresh is in progress).
                    "extendedStatus": "str",  # Optional. Dataset operation detailed status.
                      Known values are: "Unknown", "NotStarted", "InProgress", "Completed", "TimedOut",
                      "Failed", "Disabled", and "Cancelled".
                    "messages": [
                        {
                            "code": "str",  # Optional. The error code in hex format.
                            "message": "str",  # Optional. The text of error or warning
                              message.
                            "type": "str"  # Optional. The type of the error. Known
                              values are: "Error" and "Warning".
                        }
                    ],
                    "numberOfAttempts": 0,  # Optional. The number of attempts for the refresh
                      request.
                    "objects": [
                        {
                            "partition": "str",  # Optional. Partition to refresh.
                            "table": "str"  # Optional. Table to refresh.
                        }
                    ],
                    "startTime": "2020-02-20 00:00:00",  # Optional. The start date and time of
                      the refresh.
                    "status": "str",  # Optional. Dataset operation general status. Known values
                      are: "Unknown", "Completed", "Failed", and "Disabled".
                    "type": "str"  # Optional. The type of processing to perform. Known values
                      are: "Full", "ClearValues", "Calculate", "DataOnly", "Automatic", and
                      "Defragment".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_datasets_get_refresh_execution_details_in_group_request(
            group_id=group_id,
            dataset_id=dataset_id,
            refresh_id=refresh_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 202:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def cancel_refresh_in_group(  # pylint: disable=inconsistent-return-statements
        self, group_id: str, dataset_id: str, refresh_id: str, **kwargs: Any
    ) -> None:
        """Cancels the specified refresh operation for the specified dataset from the specified workspace.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Dataset.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param refresh_id: The refresh ID. Required.
        :type refresh_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_datasets_cancel_refresh_in_group_request(
            group_id=group_id,
            dataset_id=dataset_id,
            refresh_id=refresh_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get_refresh_schedule_in_group(self, group_id: str, dataset_id: str, **kwargs: Any) -> JSON:
        """Returns the refresh schedule for the specified dataset from the specified workspace.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Dataset.ReadWrite.All or Dataset.Read.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "NotifyOption": "str",  # Optional. The notification option on termination of
                      a scheduled refresh. Service principals only support the ``NoNotification``
                      value. Known values are: "NoNotification" and "MailOnFailure".
                    "days": [
                        "str"  # Optional. The days on which to execute the refresh.
                    ],
                    "enabled": bool,  # Optional. Whether the refresh is enabled.
                    "localTimeZoneId": "str",  # Optional. The ID of the time zone to use. For
                      more information, see `Time zone info </dotnet/api/system.timezoneinfo.id>`_.
                    "times": [
                        "str"  # Optional. The times of day to execute the refresh.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_datasets_get_refresh_schedule_in_group_request(
            group_id=group_id,
            dataset_id=dataset_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def update_refresh_schedule_in_group(  # pylint: disable=inconsistent-return-statements
        self,
        group_id: str,
        dataset_id: str,
        dataset_model_refresh_schedule_request: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Updates the refresh schedule for the specified dataset from the specified workspace.

        A request that disables the refresh schedule should contain no other changes.

        At least one day must be specified. If no times are specified, then Power BI will use a default
        single time per day.

        Permissions
        -----------


        * The user must be the dataset owner.
        * This API call can be called by a service principal profile. For more information see:
        `Service principal profiles in Power BI Embedded
        </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------

        The limit on the number of time slots per day depends on whether a `Premium
        </power-bi/admin/service-premium-what-is>`_ or Shared capacity is used.
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param dataset_model_refresh_schedule_request: Update Refresh Schedule parameters, by
         specifying all or some of the parameters. Required.
        :type dataset_model_refresh_schedule_request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                dataset_model_refresh_schedule_request = {
                    "value": {
                        "NotifyOption": "str",  # Optional. The notification option on
                          termination of a scheduled refresh. Service principals only support the
                          ``NoNotification`` value. Known values are: "NoNotification" and
                          "MailOnFailure".
                        "days": [
                            "str"  # Optional. The days on which to execute the refresh.
                        ],
                        "enabled": bool,  # Optional. Whether the refresh is enabled.
                        "localTimeZoneId": "str",  # Optional. The ID of the time zone to
                          use. For more information, see `Time zone info
                          </dotnet/api/system.timezoneinfo.id>`_.
                        "times": [
                            "str"  # Optional. The times of day to execute the refresh.
                        ]
                    }
                }
        """

    @overload
    async def update_refresh_schedule_in_group(  # pylint: disable=inconsistent-return-statements
        self,
        group_id: str,
        dataset_id: str,
        dataset_model_refresh_schedule_request: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Updates the refresh schedule for the specified dataset from the specified workspace.

        A request that disables the refresh schedule should contain no other changes.

        At least one day must be specified. If no times are specified, then Power BI will use a default
        single time per day.

        Permissions
        -----------


        * The user must be the dataset owner.
        * This API call can be called by a service principal profile. For more information see:
        `Service principal profiles in Power BI Embedded
        </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------

        The limit on the number of time slots per day depends on whether a `Premium
        </power-bi/admin/service-premium-what-is>`_ or Shared capacity is used.
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param dataset_model_refresh_schedule_request: Update Refresh Schedule parameters, by
         specifying all or some of the parameters. Required.
        :type dataset_model_refresh_schedule_request: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_refresh_schedule_in_group(  # pylint: disable=inconsistent-return-statements
        self, group_id: str, dataset_id: str, dataset_model_refresh_schedule_request: Union[JSON, IO], **kwargs: Any
    ) -> None:
        """Updates the refresh schedule for the specified dataset from the specified workspace.

        A request that disables the refresh schedule should contain no other changes.

        At least one day must be specified. If no times are specified, then Power BI will use a default
        single time per day.

        Permissions
        -----------


        * The user must be the dataset owner.
        * This API call can be called by a service principal profile. For more information see:
        `Service principal profiles in Power BI Embedded
        </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------

        The limit on the number of time slots per day depends on whether a `Premium
        </power-bi/admin/service-premium-what-is>`_ or Shared capacity is used.
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param dataset_model_refresh_schedule_request: Update Refresh Schedule parameters, by
         specifying all or some of the parameters. Is either a JSON type or a IO type. Required.
        :type dataset_model_refresh_schedule_request: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                dataset_model_refresh_schedule_request = {
                    "value": {
                        "NotifyOption": "str",  # Optional. The notification option on
                          termination of a scheduled refresh. Service principals only support the
                          ``NoNotification`` value. Known values are: "NoNotification" and
                          "MailOnFailure".
                        "days": [
                            "str"  # Optional. The days on which to execute the refresh.
                        ],
                        "enabled": bool,  # Optional. Whether the refresh is enabled.
                        "localTimeZoneId": "str",  # Optional. The ID of the time zone to
                          use. For more information, see `Time zone info
                          </dotnet/api/system.timezoneinfo.id>`_.
                        "times": [
                            "str"  # Optional. The times of day to execute the refresh.
                        ]
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(dataset_model_refresh_schedule_request, (IOBase, bytes)):
            _content = dataset_model_refresh_schedule_request
        else:
            _json = dataset_model_refresh_schedule_request

        _request = build_datasets_update_refresh_schedule_in_group_request(
            group_id=group_id,
            dataset_id=dataset_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get_direct_query_refresh_schedule_in_group(  # pylint: disable=name-too-long
        self, group_id: str, dataset_id: str, **kwargs: Any
    ) -> JSON:
        """Returns the refresh schedule for a specified `DirectQuery
        </power-bi/connect-data/desktop-directquery-about>`_ or `LiveConnection
        </power-bi/connect-data/desktop-directquery-about#live-connections>`_ dataset from the
        specified workspace.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Dataset.ReadWrite.All or Dataset.Read.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "days": [
                        "str"  # Optional. The days on which to execute the refresh.
                    ],
                    "frequency": 0,  # Optional. The interval in minutes between successive
                      refreshes. Supported values are *15*"" , *30*"" , *60*"" , *120*"" , and *180*.
                    "localTimeZoneId": "str",  # Optional. The ID of the time zone to use. For
                      more information, see `Time zone info </dotnet/api/system.timezoneinfo.id>`_.
                    "times": [
                        "str"  # Optional. The times of day to execute the refresh.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_datasets_get_direct_query_refresh_schedule_in_group_request(
            group_id=group_id,
            dataset_id=dataset_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def update_direct_query_refresh_schedule_in_group(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        group_id: str,
        dataset_id: str,
        dataset_dq_refresh_schedule_request: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Updates the refresh schedule for a specified `DirectQuery
        </power-bi/connect-data/desktop-directquery-about>`_ or `LiveConnection
        </power-bi/connect-data/desktop-directquery-about#live-connections>`_ dataset from the
        specified workspace.

        A request should contain either a set of days and times *or* a valid frequency, but not both.
        If you choose a set of days without specifying any times, then Power BI will use a default
        single time per day. Setting the frequency will automatically overwrite the days and times
        setting.

        Permissions
        -----------


        * The user must be the dataset owner.
        * This API call can be called by a service principal profile. For more information see:
        `Service principal profiles in Power BI Embedded
        </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Dataset.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param dataset_dq_refresh_schedule_request: Patch DirectQuery or LiveConnection Refresh
         Schedule parameters, by specifying all or some of the parameters. Required.
        :type dataset_dq_refresh_schedule_request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                dataset_dq_refresh_schedule_request = {
                    "value": {
                        "days": [
                            "str"  # Optional. The days on which to execute the refresh.
                        ],
                        "frequency": 0,  # Optional. The interval in minutes between
                          successive refreshes. Supported values are *15*"" , *30*"" , *60*"" , *120*""
                          , and *180*.
                        "localTimeZoneId": "str",  # Optional. The ID of the time zone to
                          use. For more information, see `Time zone info
                          </dotnet/api/system.timezoneinfo.id>`_.
                        "times": [
                            "str"  # Optional. The times of day to execute the refresh.
                        ]
                    }
                }
        """

    @overload
    async def update_direct_query_refresh_schedule_in_group(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        group_id: str,
        dataset_id: str,
        dataset_dq_refresh_schedule_request: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Updates the refresh schedule for a specified `DirectQuery
        </power-bi/connect-data/desktop-directquery-about>`_ or `LiveConnection
        </power-bi/connect-data/desktop-directquery-about#live-connections>`_ dataset from the
        specified workspace.

        A request should contain either a set of days and times *or* a valid frequency, but not both.
        If you choose a set of days without specifying any times, then Power BI will use a default
        single time per day. Setting the frequency will automatically overwrite the days and times
        setting.

        Permissions
        -----------


        * The user must be the dataset owner.
        * This API call can be called by a service principal profile. For more information see:
        `Service principal profiles in Power BI Embedded
        </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Dataset.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param dataset_dq_refresh_schedule_request: Patch DirectQuery or LiveConnection Refresh
         Schedule parameters, by specifying all or some of the parameters. Required.
        :type dataset_dq_refresh_schedule_request: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_direct_query_refresh_schedule_in_group(  # pylint: disable=inconsistent-return-statements,name-too-long
        self, group_id: str, dataset_id: str, dataset_dq_refresh_schedule_request: Union[JSON, IO], **kwargs: Any
    ) -> None:
        """Updates the refresh schedule for a specified `DirectQuery
        </power-bi/connect-data/desktop-directquery-about>`_ or `LiveConnection
        </power-bi/connect-data/desktop-directquery-about#live-connections>`_ dataset from the
        specified workspace.

        A request should contain either a set of days and times *or* a valid frequency, but not both.
        If you choose a set of days without specifying any times, then Power BI will use a default
        single time per day. Setting the frequency will automatically overwrite the days and times
        setting.

        Permissions
        -----------


        * The user must be the dataset owner.
        * This API call can be called by a service principal profile. For more information see:
        `Service principal profiles in Power BI Embedded
        </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Dataset.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param dataset_dq_refresh_schedule_request: Patch DirectQuery or LiveConnection Refresh
         Schedule parameters, by specifying all or some of the parameters. Is either a JSON type or a IO
         type. Required.
        :type dataset_dq_refresh_schedule_request: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                dataset_dq_refresh_schedule_request = {
                    "value": {
                        "days": [
                            "str"  # Optional. The days on which to execute the refresh.
                        ],
                        "frequency": 0,  # Optional. The interval in minutes between
                          successive refreshes. Supported values are *15*"" , *30*"" , *60*"" , *120*""
                          , and *180*.
                        "localTimeZoneId": "str",  # Optional. The ID of the time zone to
                          use. For more information, see `Time zone info
                          </dotnet/api/system.timezoneinfo.id>`_.
                        "times": [
                            "str"  # Optional. The times of day to execute the refresh.
                        ]
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(dataset_dq_refresh_schedule_request, (IOBase, bytes)):
            _content = dataset_dq_refresh_schedule_request
        else:
            _json = dataset_dq_refresh_schedule_request

        _request = build_datasets_update_direct_query_refresh_schedule_in_group_request(
            group_id=group_id,
            dataset_id=dataset_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get_parameters_in_group(self, group_id: str, dataset_id: str, **kwargs: Any) -> JSON:
        """Returns a list of parameters for the specified dataset from the specified workspace.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Dataset.Read.All or Dataset.ReadWrite.All

        Limitations
        -----------

        Datasets with SQL, Oracle, Teradata, and SAP HANA `DirectQuery
        </power-bi/connect-data/desktop-directquery-about>`_ connections aren't supported.
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataset_id: Required.
        :type dataset_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional.
                    "value": [
                        {
                            "isRequired": bool,  # Whether the dataset parameter is
                              required. Required.
                            "name": "str",  # The parameter name. Required.
                            "type": "str",  # The parameter type. Required.
                            "currentValue": "str",  # Optional. The current value of the
                              parameter.
                            "suggestedValues": [
                                "str"  # Optional. A list of suggested parameter
                                  values.
                            ]
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_datasets_get_parameters_in_group_request(
            group_id=group_id,
            dataset_id=dataset_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def update_parameters_in_group(  # pylint: disable=inconsistent-return-statements
        self,
        group_id: str,
        dataset_id: str,
        update_mashup_parameters_request: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Updates the parameters values for the specified dataset from the specified workspace.

        ..

           [!NOTE]
           We recommend using `enhanced dataset metadata
        </power-bi/connect-data/desktop-enhanced-dataset-metadata>`_ with this API call.

           [!IMPORTANT]


           * If you're using **enhanced dataset metadata**\ , refresh the dataset to apply the new
        parameter values.
           * If you're not using **enhanced dataset metadata**\ , wait 30 minutes for the update data
        sources operation to complete, and then refresh the dataset.


        Permissions
        -----------


        * The user must be the dataset owner.
        * This API call can be called by a service principal profile. For more information see:
        `Service principal profiles in Power BI Embedded
        </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------


        * Datasets created using the public `XMLA endpoint
        </power-bi/admin/service-premium-connect-tools>`_ aren't supported. To make changes to those
        data sources, the admin must use the Azure Analysis Services client library for Tabular Object
        Model.
        * `DirectQuery </power-bi/connect-data/desktop-directquery-about>`_ connections are only
        supported with `enhanced dataset metadata
        </power-bi/connect-data/desktop-enhanced-dataset-metadata>`_.
        * Datasets with Azure Analysis Services live connections aren't supported.
        * Maximum of 100 parameters per request.
        * All specified parameters must exist in the dataset.
        * Parameters values should be of the expected type.
        * The parameter list can't be empty or include duplicate parameters.
        * Parameters names are case-sensitive.
        * Parameter ``IsRequired`` must have a non-empty value.
        * The parameter types ``Any`` and ``Binary`` can't be updated.
          :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataset_id: Required.
        :type dataset_id: str
        :param update_mashup_parameters_request: Required.
        :type update_mashup_parameters_request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                update_mashup_parameters_request = {
                    "updateDetails": [
                        {
                            "name": "str",  # The parameter name. Required.
                            "newValue": "str"  # Optional. The new value for the
                              parameter.
                        }
                    ]
                }
        """

    @overload
    async def update_parameters_in_group(  # pylint: disable=inconsistent-return-statements
        self,
        group_id: str,
        dataset_id: str,
        update_mashup_parameters_request: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Updates the parameters values for the specified dataset from the specified workspace.

        ..

           [!NOTE]
           We recommend using `enhanced dataset metadata
        </power-bi/connect-data/desktop-enhanced-dataset-metadata>`_ with this API call.

           [!IMPORTANT]


           * If you're using **enhanced dataset metadata**\ , refresh the dataset to apply the new
        parameter values.
           * If you're not using **enhanced dataset metadata**\ , wait 30 minutes for the update data
        sources operation to complete, and then refresh the dataset.


        Permissions
        -----------


        * The user must be the dataset owner.
        * This API call can be called by a service principal profile. For more information see:
        `Service principal profiles in Power BI Embedded
        </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------


        * Datasets created using the public `XMLA endpoint
        </power-bi/admin/service-premium-connect-tools>`_ aren't supported. To make changes to those
        data sources, the admin must use the Azure Analysis Services client library for Tabular Object
        Model.
        * `DirectQuery </power-bi/connect-data/desktop-directquery-about>`_ connections are only
        supported with `enhanced dataset metadata
        </power-bi/connect-data/desktop-enhanced-dataset-metadata>`_.
        * Datasets with Azure Analysis Services live connections aren't supported.
        * Maximum of 100 parameters per request.
        * All specified parameters must exist in the dataset.
        * Parameters values should be of the expected type.
        * The parameter list can't be empty or include duplicate parameters.
        * Parameters names are case-sensitive.
        * Parameter ``IsRequired`` must have a non-empty value.
        * The parameter types ``Any`` and ``Binary`` can't be updated.
          :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataset_id: Required.
        :type dataset_id: str
        :param update_mashup_parameters_request: Required.
        :type update_mashup_parameters_request: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_parameters_in_group(  # pylint: disable=inconsistent-return-statements
        self, group_id: str, dataset_id: str, update_mashup_parameters_request: Union[JSON, IO], **kwargs: Any
    ) -> None:
        """Updates the parameters values for the specified dataset from the specified workspace.

        ..

           [!NOTE]
           We recommend using `enhanced dataset metadata
        </power-bi/connect-data/desktop-enhanced-dataset-metadata>`_ with this API call.

           [!IMPORTANT]


           * If you're using **enhanced dataset metadata**\ , refresh the dataset to apply the new
        parameter values.
           * If you're not using **enhanced dataset metadata**\ , wait 30 minutes for the update data
        sources operation to complete, and then refresh the dataset.


        Permissions
        -----------


        * The user must be the dataset owner.
        * This API call can be called by a service principal profile. For more information see:
        `Service principal profiles in Power BI Embedded
        </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------


        * Datasets created using the public `XMLA endpoint
        </power-bi/admin/service-premium-connect-tools>`_ aren't supported. To make changes to those
        data sources, the admin must use the Azure Analysis Services client library for Tabular Object
        Model.
        * `DirectQuery </power-bi/connect-data/desktop-directquery-about>`_ connections are only
        supported with `enhanced dataset metadata
        </power-bi/connect-data/desktop-enhanced-dataset-metadata>`_.
        * Datasets with Azure Analysis Services live connections aren't supported.
        * Maximum of 100 parameters per request.
        * All specified parameters must exist in the dataset.
        * Parameters values should be of the expected type.
        * The parameter list can't be empty or include duplicate parameters.
        * Parameters names are case-sensitive.
        * Parameter ``IsRequired`` must have a non-empty value.
        * The parameter types ``Any`` and ``Binary`` can't be updated.
          :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataset_id: Required.
        :type dataset_id: str
        :param update_mashup_parameters_request: Is either a JSON type or a IO type. Required.
        :type update_mashup_parameters_request: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                update_mashup_parameters_request = {
                    "updateDetails": [
                        {
                            "name": "str",  # The parameter name. Required.
                            "newValue": "str"  # Optional. The new value for the
                              parameter.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(update_mashup_parameters_request, (IOBase, bytes)):
            _content = update_mashup_parameters_request
        else:
            _json = update_mashup_parameters_request

        _request = build_datasets_update_parameters_in_group_request(
            group_id=group_id,
            dataset_id=dataset_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get_datasources_in_group(self, group_id: str, dataset_id: str, **kwargs: Any) -> JSON:
        """Returns a list of data sources for the specified dataset from the specified workspace.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Dataset.ReadWrite.All or Dataset.Read.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataset_id: Required.
        :type dataset_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional. OData context.
                    "value": [
                        {
                            "connectionDetails": {
                                "account": "str",  # Optional. The connection
                                  account.
                                "classInfo": "str",  # Optional. The connection class
                                  information.
                                "database": "str",  # Optional. The connection
                                  database.
                                "domain": "str",  # Optional. The connection domain.
                                "emailAddress": "str",  # Optional. The connection
                                  email address.
                                "kind": "str",  # Optional. The connection kind.
                                "loginServer": "str",  # Optional. The connection
                                  login server.
                                "path": "str",  # Optional. The connection path.
                                "server": "str",  # Optional. The connection server.
                                "url": "str"  # Optional. The connection URL.
                            },
                            "connectionString": "str",  # Optional. (Deprecated) The data
                              source connection string. Available only for DirectQuery.
                            "datasourceId": "str",  # Optional. The bound data source ID,
                              which is empty when not bound to a gateway.
                            "datasourceType": "str",  # Optional. The data source type.
                            "gatewayId": "str",  # Optional. The bound gateway ID, which
                              is empty when not bound to a gateway. When using a gateway cluster, the
                              gateway ID refers to the primary (first) gateway in the cluster and is
                              similar to the gateway cluster ID.
                            "name": "str"  # Optional. (Deprecated) The data source name.
                              Available only for DirectQuery.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_datasets_get_datasources_in_group_request(
            group_id=group_id,
            dataset_id=dataset_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def update_datasources_in_group(  # pylint: disable=inconsistent-return-statements
        self,
        group_id: str,
        dataset_id: str,
        update_datasources_request: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Updates the data sources of the specified dataset from the specified workspace.

        ..

           [!NOTE]
           We recommend using `enhanced dataset metadata
        </power-bi/connect-data/desktop-enhanced-dataset-metadata>`_ with this API call.

           [!IMPORTANT]


           * The original data source and the new data source must have the exact same schema.
           * If you're using **enhanced dataset metadata**\ , refresh the dataset to get data from the
        new data sources.
           * If you're not using **enhanced dataset metadata**\ , wait 30 minutes for the update data
        sources operation to complete, and then refresh the dataset.


        Permissions
        -----------


        * The user must be the dataset owner.
        * This API call can be called by a service principal profile. For more information see:
        `Service principal profiles in Power BI Embedded
        </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------


        * Datasets created using the public `XMLA endpoint
        </power-bi/admin/service-premium-connect-tools>`_ aren't supported. To make changes to those
        data sources, the admin must use the Azure Analysis Services client library for Tabular Object
        Model.
        * Only these data sources are supported: SQL Server, Azure SQL Server, Azure Analysis Services,
        Azure Synapse, OData, SharePoint, Teradata, and SAP HANA. For other data sources, use the
        `Update Parameters In Group </rest/api/power-bi/datasets/update-parameters-in-group>`_ API
        call.
        * Changing the data source type isn't supported.
        * Data sources that contain parameters in the connection string aren't supported.
        * Updating data sources that are part of merged or joined tables is only supported if you're
        using `enhanced dataset metadata </power-bi/connect-data/desktop-enhanced-dataset-metadata>`_.
        * For an Advanced Query that reference multiple data sources, only the first data source will
        be updated. To overcome this limitation, define the data source as a parameter and use the
        `Update Parameters In Group </rest/api/power-bi/datasets/update-parameters-in-group>`_ API
        call.
        * Datasets with incremental refresh policy are not fully supported, calling this API may not
        work as expected and result of partial datasources update, to overcome this you can try run a
        dataset refresh before calling this API.
          :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataset_id: Required.
        :type dataset_id: str
        :param update_datasources_request: Required.
        :type update_datasources_request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                update_datasources_request = {
                    "updateDetails": [
                        {
                            "connectionDetails": {
                                "account": "str",  # Optional. The connection
                                  account.
                                "classInfo": "str",  # Optional. The connection class
                                  information.
                                "database": "str",  # Optional. The connection
                                  database.
                                "domain": "str",  # Optional. The connection domain.
                                "emailAddress": "str",  # Optional. The connection
                                  email address.
                                "kind": "str",  # Optional. The connection kind.
                                "loginServer": "str",  # Optional. The connection
                                  login server.
                                "path": "str",  # Optional. The connection path.
                                "server": "str",  # Optional. The connection server.
                                "url": "str"  # Optional. The connection URL.
                            },
                            "datasourceSelector": {
                                "connectionDetails": {
                                    "account": "str",  # Optional. The connection
                                      account.
                                    "classInfo": "str",  # Optional. The
                                      connection class information.
                                    "database": "str",  # Optional. The
                                      connection database.
                                    "domain": "str",  # Optional. The connection
                                      domain.
                                    "emailAddress": "str",  # Optional. The
                                      connection email address.
                                    "kind": "str",  # Optional. The connection
                                      kind.
                                    "loginServer": "str",  # Optional. The
                                      connection login server.
                                    "path": "str",  # Optional. The connection
                                      path.
                                    "server": "str",  # Optional. The connection
                                      server.
                                    "url": "str"  # Optional. The connection URL.
                                },
                                "connectionString": "str",  # Optional. (Deprecated)
                                  The data source connection string. Available only for DirectQuery.
                                "datasourceId": "str",  # Optional. The bound data
                                  source ID, which is empty when not bound to a gateway.
                                "datasourceType": "str",  # Optional. The data source
                                  type.
                                "gatewayId": "str",  # Optional. The bound gateway
                                  ID, which is empty when not bound to a gateway. When using a gateway
                                  cluster, the gateway ID refers to the primary (first) gateway in the
                                  cluster and is similar to the gateway cluster ID.
                                "name": "str"  # Optional. (Deprecated) The data
                                  source name. Available only for DirectQuery.
                            }
                        }
                    ]
                }
        """

    @overload
    async def update_datasources_in_group(  # pylint: disable=inconsistent-return-statements
        self,
        group_id: str,
        dataset_id: str,
        update_datasources_request: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Updates the data sources of the specified dataset from the specified workspace.

        ..

           [!NOTE]
           We recommend using `enhanced dataset metadata
        </power-bi/connect-data/desktop-enhanced-dataset-metadata>`_ with this API call.

           [!IMPORTANT]


           * The original data source and the new data source must have the exact same schema.
           * If you're using **enhanced dataset metadata**\ , refresh the dataset to get data from the
        new data sources.
           * If you're not using **enhanced dataset metadata**\ , wait 30 minutes for the update data
        sources operation to complete, and then refresh the dataset.


        Permissions
        -----------


        * The user must be the dataset owner.
        * This API call can be called by a service principal profile. For more information see:
        `Service principal profiles in Power BI Embedded
        </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------


        * Datasets created using the public `XMLA endpoint
        </power-bi/admin/service-premium-connect-tools>`_ aren't supported. To make changes to those
        data sources, the admin must use the Azure Analysis Services client library for Tabular Object
        Model.
        * Only these data sources are supported: SQL Server, Azure SQL Server, Azure Analysis Services,
        Azure Synapse, OData, SharePoint, Teradata, and SAP HANA. For other data sources, use the
        `Update Parameters In Group </rest/api/power-bi/datasets/update-parameters-in-group>`_ API
        call.
        * Changing the data source type isn't supported.
        * Data sources that contain parameters in the connection string aren't supported.
        * Updating data sources that are part of merged or joined tables is only supported if you're
        using `enhanced dataset metadata </power-bi/connect-data/desktop-enhanced-dataset-metadata>`_.
        * For an Advanced Query that reference multiple data sources, only the first data source will
        be updated. To overcome this limitation, define the data source as a parameter and use the
        `Update Parameters In Group </rest/api/power-bi/datasets/update-parameters-in-group>`_ API
        call.
        * Datasets with incremental refresh policy are not fully supported, calling this API may not
        work as expected and result of partial datasources update, to overcome this you can try run a
        dataset refresh before calling this API.
          :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataset_id: Required.
        :type dataset_id: str
        :param update_datasources_request: Required.
        :type update_datasources_request: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_datasources_in_group(  # pylint: disable=inconsistent-return-statements
        self, group_id: str, dataset_id: str, update_datasources_request: Union[JSON, IO], **kwargs: Any
    ) -> None:
        """Updates the data sources of the specified dataset from the specified workspace.

        ..

           [!NOTE]
           We recommend using `enhanced dataset metadata
        </power-bi/connect-data/desktop-enhanced-dataset-metadata>`_ with this API call.

           [!IMPORTANT]


           * The original data source and the new data source must have the exact same schema.
           * If you're using **enhanced dataset metadata**\ , refresh the dataset to get data from the
        new data sources.
           * If you're not using **enhanced dataset metadata**\ , wait 30 minutes for the update data
        sources operation to complete, and then refresh the dataset.


        Permissions
        -----------


        * The user must be the dataset owner.
        * This API call can be called by a service principal profile. For more information see:
        `Service principal profiles in Power BI Embedded
        </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------


        * Datasets created using the public `XMLA endpoint
        </power-bi/admin/service-premium-connect-tools>`_ aren't supported. To make changes to those
        data sources, the admin must use the Azure Analysis Services client library for Tabular Object
        Model.
        * Only these data sources are supported: SQL Server, Azure SQL Server, Azure Analysis Services,
        Azure Synapse, OData, SharePoint, Teradata, and SAP HANA. For other data sources, use the
        `Update Parameters In Group </rest/api/power-bi/datasets/update-parameters-in-group>`_ API
        call.
        * Changing the data source type isn't supported.
        * Data sources that contain parameters in the connection string aren't supported.
        * Updating data sources that are part of merged or joined tables is only supported if you're
        using `enhanced dataset metadata </power-bi/connect-data/desktop-enhanced-dataset-metadata>`_.
        * For an Advanced Query that reference multiple data sources, only the first data source will
        be updated. To overcome this limitation, define the data source as a parameter and use the
        `Update Parameters In Group </rest/api/power-bi/datasets/update-parameters-in-group>`_ API
        call.
        * Datasets with incremental refresh policy are not fully supported, calling this API may not
        work as expected and result of partial datasources update, to overcome this you can try run a
        dataset refresh before calling this API.
          :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataset_id: Required.
        :type dataset_id: str
        :param update_datasources_request: Is either a JSON type or a IO type. Required.
        :type update_datasources_request: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                update_datasources_request = {
                    "updateDetails": [
                        {
                            "connectionDetails": {
                                "account": "str",  # Optional. The connection
                                  account.
                                "classInfo": "str",  # Optional. The connection class
                                  information.
                                "database": "str",  # Optional. The connection
                                  database.
                                "domain": "str",  # Optional. The connection domain.
                                "emailAddress": "str",  # Optional. The connection
                                  email address.
                                "kind": "str",  # Optional. The connection kind.
                                "loginServer": "str",  # Optional. The connection
                                  login server.
                                "path": "str",  # Optional. The connection path.
                                "server": "str",  # Optional. The connection server.
                                "url": "str"  # Optional. The connection URL.
                            },
                            "datasourceSelector": {
                                "connectionDetails": {
                                    "account": "str",  # Optional. The connection
                                      account.
                                    "classInfo": "str",  # Optional. The
                                      connection class information.
                                    "database": "str",  # Optional. The
                                      connection database.
                                    "domain": "str",  # Optional. The connection
                                      domain.
                                    "emailAddress": "str",  # Optional. The
                                      connection email address.
                                    "kind": "str",  # Optional. The connection
                                      kind.
                                    "loginServer": "str",  # Optional. The
                                      connection login server.
                                    "path": "str",  # Optional. The connection
                                      path.
                                    "server": "str",  # Optional. The connection
                                      server.
                                    "url": "str"  # Optional. The connection URL.
                                },
                                "connectionString": "str",  # Optional. (Deprecated)
                                  The data source connection string. Available only for DirectQuery.
                                "datasourceId": "str",  # Optional. The bound data
                                  source ID, which is empty when not bound to a gateway.
                                "datasourceType": "str",  # Optional. The data source
                                  type.
                                "gatewayId": "str",  # Optional. The bound gateway
                                  ID, which is empty when not bound to a gateway. When using a gateway
                                  cluster, the gateway ID refers to the primary (first) gateway in the
                                  cluster and is similar to the gateway cluster ID.
                                "name": "str"  # Optional. (Deprecated) The data
                                  source name. Available only for DirectQuery.
                            }
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(update_datasources_request, (IOBase, bytes)):
            _content = update_datasources_request
        else:
            _json = update_datasources_request

        _request = build_datasets_update_datasources_in_group_request(
            group_id=group_id,
            dataset_id=dataset_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def set_all_dataset_connections_in_group(  # pylint: disable=inconsistent-return-statements
        self, group_id: str, dataset_id: str, parameters: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Updates all connections for the specified dataset from the specified workspace. This API call
        only supports SQL DirectQuery datasets.

        ..

           [!IMPORTANT]
           This API call is deprecated and no longer supported. This API call isn't compatible with
        `enhanced dataset metadata </power-bi/connect-data/desktop-enhanced-dataset-metadata>`_.

           Instead use:


           * `Update Parameters In Group </rest/api/power-bi/datasets/update-parameters-in-group>`_ to
        update connections for SQL, Azure Synapse, OData, and SharePoint data sources.
           * `Update Datasources In Group </rest/api/power-bi/datasets/update-datasources-in-group>`_
        to connections for other data sources.


        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------

        Supports SQL DirectQuery datasets.
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param parameters: The body. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "connectionString": "str"  # A dataset connection string. Required.
                }
        """

    @overload
    async def set_all_dataset_connections_in_group(  # pylint: disable=inconsistent-return-statements
        self, group_id: str, dataset_id: str, parameters: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Updates all connections for the specified dataset from the specified workspace. This API call
        only supports SQL DirectQuery datasets.

        ..

           [!IMPORTANT]
           This API call is deprecated and no longer supported. This API call isn't compatible with
        `enhanced dataset metadata </power-bi/connect-data/desktop-enhanced-dataset-metadata>`_.

           Instead use:


           * `Update Parameters In Group </rest/api/power-bi/datasets/update-parameters-in-group>`_ to
        update connections for SQL, Azure Synapse, OData, and SharePoint data sources.
           * `Update Datasources In Group </rest/api/power-bi/datasets/update-datasources-in-group>`_
        to connections for other data sources.


        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------

        Supports SQL DirectQuery datasets.
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param parameters: The body. Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def set_all_dataset_connections_in_group(  # pylint: disable=inconsistent-return-statements
        self, group_id: str, dataset_id: str, parameters: Union[JSON, IO], **kwargs: Any
    ) -> None:
        """Updates all connections for the specified dataset from the specified workspace. This API call
        only supports SQL DirectQuery datasets.

        ..

           [!IMPORTANT]
           This API call is deprecated and no longer supported. This API call isn't compatible with
        `enhanced dataset metadata </power-bi/connect-data/desktop-enhanced-dataset-metadata>`_.

           Instead use:


           * `Update Parameters In Group </rest/api/power-bi/datasets/update-parameters-in-group>`_ to
        update connections for SQL, Azure Synapse, OData, and SharePoint data sources.
           * `Update Datasources In Group </rest/api/power-bi/datasets/update-datasources-in-group>`_
        to connections for other data sources.


        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------

        Supports SQL DirectQuery datasets.
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param parameters: The body. Is either a JSON type or a IO type. Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "connectionString": "str"  # A dataset connection string. Required.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _json = parameters

        _request = build_datasets_set_all_dataset_connections_in_group_request(
            group_id=group_id,
            dataset_id=dataset_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def bind_to_gateway_in_group(  # pylint: disable=inconsistent-return-statements
        self,
        group_id: str,
        dataset_id: str,
        bind_to_gateway_request: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Binds the specified dataset from the specified workspace to the specified gateway, optionally
        with a given set of data source IDs. If you don't supply a specific data source ID, the dataset
        will be bound to the first matching data source in the gateway.

        ..

           [!IMPORTANT]
           Add the API caller principal as a data source user on the gateway.


        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------

        Only supports the on-premises data gateway
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param bind_to_gateway_request: The bind to gateway request. Required.
        :type bind_to_gateway_request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                bind_to_gateway_request = {
                    "gatewayObjectId": "str",  # The gateway ID. When using a gateway cluster,
                      the gateway ID refers to the primary (first) gateway in the cluster and is
                      similar to the gateway cluster ID. Required.
                    "datasourceObjectIds": [
                        "str"  # Optional. The unique identifiers for the data sources in the
                          gateway.
                    ]
                }
        """

    @overload
    async def bind_to_gateway_in_group(  # pylint: disable=inconsistent-return-statements
        self,
        group_id: str,
        dataset_id: str,
        bind_to_gateway_request: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Binds the specified dataset from the specified workspace to the specified gateway, optionally
        with a given set of data source IDs. If you don't supply a specific data source ID, the dataset
        will be bound to the first matching data source in the gateway.

        ..

           [!IMPORTANT]
           Add the API caller principal as a data source user on the gateway.


        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------

        Only supports the on-premises data gateway
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param bind_to_gateway_request: The bind to gateway request. Required.
        :type bind_to_gateway_request: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def bind_to_gateway_in_group(  # pylint: disable=inconsistent-return-statements
        self, group_id: str, dataset_id: str, bind_to_gateway_request: Union[JSON, IO], **kwargs: Any
    ) -> None:
        """Binds the specified dataset from the specified workspace to the specified gateway, optionally
        with a given set of data source IDs. If you don't supply a specific data source ID, the dataset
        will be bound to the first matching data source in the gateway.

        ..

           [!IMPORTANT]
           Add the API caller principal as a data source user on the gateway.


        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------

        Only supports the on-premises data gateway
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param bind_to_gateway_request: The bind to gateway request. Is either a JSON type or a IO
         type. Required.
        :type bind_to_gateway_request: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                bind_to_gateway_request = {
                    "gatewayObjectId": "str",  # The gateway ID. When using a gateway cluster,
                      the gateway ID refers to the primary (first) gateway in the cluster and is
                      similar to the gateway cluster ID. Required.
                    "datasourceObjectIds": [
                        "str"  # Optional. The unique identifiers for the data sources in the
                          gateway.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(bind_to_gateway_request, (IOBase, bytes)):
            _content = bind_to_gateway_request
        else:
            _json = bind_to_gateway_request

        _request = build_datasets_bind_to_gateway_in_group_request(
            group_id=group_id,
            dataset_id=dataset_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get_gateway_datasources_in_group(self, group_id: str, dataset_id: str, **kwargs: Any) -> JSON:
        """Returns a list of gateway data sources for the specified dataset from the specified workspace.

        ..

           [!IMPORTANT]
           This API call is deprecated, use `Get Datasources In Group
        </rest/api/power-bi/datasets/get-datasources-in-group>`_ instead.


        Required Scope
        --------------

        Dataset.ReadWrite.All or Dataset.Read.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional. OData context.
                    "value": [
                        {
                            "credentialType": "str",  # The type of data source
                              `credential </power-bi/developer/embedded/configure-credentials>`_.
                              Required. Known values are: "Basic", "Windows", "Anonymous", "OAuth2",
                              "Key", and "SAS".
                            "gatewayId": "str",  # The associated gateway ID. When using
                              a gateway cluster, the gateway ID refers to the primary (first) gateway
                              in the cluster and is similar to the gateway cluster ID. Required.
                            "id": "str",  # The unique ID for the data source. Required.
                            "connectionDetails": "str",  # Optional. Connection details
                              in JSON format.
                            "credentialDetails": {
                                "useEndUserOAuth2Credentials": bool  # Optional.
                                  Whether the end-user Azure AD identity (OAuth 2.0 credentials) is
                                  used when connecting to the data source in DirectQuery mode. Use with
                                  data sources that support `single sign-on (SSO)
                                  </power-bi/connect-data/power-bi-data-sources#single-sign-on-sso-for-directquery-sources>`_.
                            },
                            "datasourceName": "str",  # Optional. The name of the data
                              source.
                            "datasourceType": "str"  # Optional. The type of `data source
                              </power-bi/connect-data/power-bi-data-sources>`_.  .. list-table::
                              :header-rows: 1     * - API name for the data source      -       -     *
                              - ActiveDirectory      - AdobeAnalytics      - AdoDotNet    * -
                              AnalysisServices      - AzureBlobs      - AzureDataLakeStorage    * -
                              AzureMarketplace      - AzureTables      - BizTalk    * - CDPA      -
                              CustomConnector      - CustomHttpApi    * - DB2      - Essbase      -
                              EventHub    * - Excel      - Exchange      - Extension    * - Facebook
                              - File      - Folder    * - GoogleAnalytics      - Hdfs      - HDInsight
                              * - Informix      - MQ      - MySql    * - OData      - ODBC      - OleDb
                              * - Oracle      - PostgreSql      - PowerQueryMashup     * - PubNub
                              - Salesforce      - SAPBW    * - SAPBWMessageServer      - SapErp      -
                              SAPHana    * - SharePoint      - SharePointDocLib      - SharePointList
                              * - Sql      - Sybase      - Teradata    * - UIFlow      - Web.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_datasets_get_gateway_datasources_in_group_request(
            group_id=group_id,
            dataset_id=dataset_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def discover_gateways_in_group(self, group_id: str, dataset_id: str, **kwargs: Any) -> JSON:
        """Returns a list of gateways that the specified dataset from the specified workspace can be bound
        to.

        This API call is only relevant to datasets that have at least one on-premises connection. For
        datasets with cloud-only connections, this API call returns an empty list.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Dataset.Read.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional.
                    "value": [
                        {
                            "id": "str",  # The gateway ID. When using a gateway cluster,
                              the gateway ID refers to the primary (first) gateway in the cluster and
                              is similar to the gateway cluster ID. Required.
                            "gatewayAnnotation": "str",  # Optional. Gateway metadata in
                              JSON format.
                            "gatewayStatus": "str",  # Optional. The gateway connectivity
                              status.
                            "name": "str",  # Optional. The gateway name.
                            "publicKey": {
                                "exponent": "str",  # Optional. The public key
                                  exponent.
                                "modulus": "str"  # Optional. The public key modulus.
                            },
                            "type": "str"  # Optional. The gateway type.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_datasets_discover_gateways_in_group_request(
            group_id=group_id,
            dataset_id=dataset_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def take_over_in_group(  # pylint: disable=inconsistent-return-statements
        self, group_id: str, dataset_id: str, **kwargs: Any
    ) -> None:
        """Transfers ownership over the specified dataset to the current authorized user.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Dataset.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_datasets_take_over_in_group_request(
            group_id=group_id,
            dataset_id=dataset_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def execute_queries_in_group(
        self,
        group_id: str,
        dataset_id: str,
        request_message: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Executes Data Analysis Expressions (DAX) queries against the provided dataset.

        DAX query errors will result in:


        * A response error, such as ``DAX query failure``.
        * A failure HTTP status code (400).

        A query that requests more than one table, or more than the allowed number of table rows, will
        result in:


        * Limited data being returned.
        * A response error, such as ``More than one result table in a query`` or ``More than {allowed
        number} rows in a query result``.
        * A successful HTTP status code (200).

        Columns that are fully qualified in the query will be returned with a fully qualified name, for
        example, ``MyTable[MyColumn]``. Columns that are renamed or created in the query will be
        returned within square bracket, for example, ``[MyNewColumn]``.

        Permissions
        -----------

        The user must have `Manage dataset access permissions
        </power-bi/connect-data/service-datasets-manage-access-permissions>`_.

        Required Scope
        --------------

        Dataset.ReadWrite.All or Dataset.Read.All

        Limitations
        -----------


        * Datasets that are hosted in Azure Analysis Services or that have a live connection to an
        on-premises Azure Analysis Services model aren't supported.
        * The tenant setting **Dataset Execute Queries REST API**\ , found under **Integration
        settings**\ , must be enabled.
        * One query per API call.
        * One table request per query.
        * Maximum of 100,000 rows or 1,000,000 values per query (whichever is hit first). For example
        if you query for 5 columns, you can get back max 100,000 rows. If you query for 20 columns, you
        can get back max 50,000 rows (1 million divided by 20).
        * Maximum of 15MB of data per query. Once 15MB is exceeded, the current row will be completed
        but no additional rows will be written.
        * Maximum of 120 requests per user per minute. Target dataset does not impact this rate limit.
        * Service Principals aren't supported for datasets with RLS per `RLS limitations
        </power-bi/admin/service-admin-rls#considerations-and-limitations>`_ or with SSO enabled. To
        use Service Principals, make sure the admin tenant setting `\ *Allow service principals to use
        Power BI APIs*
        </power-bi/admin/service-admin-portal-developer#allow-service-principals-to-use-power-bi-apis>`_
        under *Developer settings* is enabled.
        * Only DAX queries are supported at this time. MDX and DMV queries are not supported.
          :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param request_message: The request message. Required.
        :type request_message: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                request_message = {
                    "queries": [
                        {
                            "query": "str"  # The DAX query to be executed. Required.
                        }
                    ],
                    "impersonatedUserName": "str",  # Optional. The UPN of a user to be
                      impersonated. If the model is not RLS enabled, this will be ignored.
                    "serializerSettings": {
                        "includeNulls": bool  # Optional. Whether null (blank) values should
                          be included in the result set. If unspecified, the default value is
                          ``false``.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "error": {
                        "code": "str",  # Optional. The code associated with the error.
                        "message": "str"  # Optional. The message of the error. If not
                          present here, this information my also be found in details object nested
                          under the error object.
                    },
                    "informationProtectionLabel": {
                        "id": "str",  # Optional. The identifier (guid) of the information
                          protection label.
                        "name": "str"  # Optional. The display name of the information
                          protection label.
                    },
                    "results": [
                        {
                            "error": {
                                "code": "str",  # Optional. The code associated with
                                  the error.
                                "message": "str"  # Optional. The message of the
                                  error. If not present here, this information my also be found in
                                  details object nested under the error object.
                            },
                            "tables": [
                                {
                                    "error": {
                                        "code": "str",  # Optional. The code
                                          associated with the error.
                                        "message": "str"  # Optional. The
                                          message of the error. If not present here, this information
                                          my also be found in details object nested under the error
                                          object.
                                    },
                                    "rows": [
                                        {}  # Optional. A list of rows.
                                    ]
                                }
                            ]
                        }
                    ]
                }
        """

    @overload
    async def execute_queries_in_group(
        self,
        group_id: str,
        dataset_id: str,
        request_message: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Executes Data Analysis Expressions (DAX) queries against the provided dataset.

        DAX query errors will result in:


        * A response error, such as ``DAX query failure``.
        * A failure HTTP status code (400).

        A query that requests more than one table, or more than the allowed number of table rows, will
        result in:


        * Limited data being returned.
        * A response error, such as ``More than one result table in a query`` or ``More than {allowed
        number} rows in a query result``.
        * A successful HTTP status code (200).

        Columns that are fully qualified in the query will be returned with a fully qualified name, for
        example, ``MyTable[MyColumn]``. Columns that are renamed or created in the query will be
        returned within square bracket, for example, ``[MyNewColumn]``.

        Permissions
        -----------

        The user must have `Manage dataset access permissions
        </power-bi/connect-data/service-datasets-manage-access-permissions>`_.

        Required Scope
        --------------

        Dataset.ReadWrite.All or Dataset.Read.All

        Limitations
        -----------


        * Datasets that are hosted in Azure Analysis Services or that have a live connection to an
        on-premises Azure Analysis Services model aren't supported.
        * The tenant setting **Dataset Execute Queries REST API**\ , found under **Integration
        settings**\ , must be enabled.
        * One query per API call.
        * One table request per query.
        * Maximum of 100,000 rows or 1,000,000 values per query (whichever is hit first). For example
        if you query for 5 columns, you can get back max 100,000 rows. If you query for 20 columns, you
        can get back max 50,000 rows (1 million divided by 20).
        * Maximum of 15MB of data per query. Once 15MB is exceeded, the current row will be completed
        but no additional rows will be written.
        * Maximum of 120 requests per user per minute. Target dataset does not impact this rate limit.
        * Service Principals aren't supported for datasets with RLS per `RLS limitations
        </power-bi/admin/service-admin-rls#considerations-and-limitations>`_ or with SSO enabled. To
        use Service Principals, make sure the admin tenant setting `\ *Allow service principals to use
        Power BI APIs*
        </power-bi/admin/service-admin-portal-developer#allow-service-principals-to-use-power-bi-apis>`_
        under *Developer settings* is enabled.
        * Only DAX queries are supported at this time. MDX and DMV queries are not supported.
          :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param request_message: The request message. Required.
        :type request_message: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "error": {
                        "code": "str",  # Optional. The code associated with the error.
                        "message": "str"  # Optional. The message of the error. If not
                          present here, this information my also be found in details object nested
                          under the error object.
                    },
                    "informationProtectionLabel": {
                        "id": "str",  # Optional. The identifier (guid) of the information
                          protection label.
                        "name": "str"  # Optional. The display name of the information
                          protection label.
                    },
                    "results": [
                        {
                            "error": {
                                "code": "str",  # Optional. The code associated with
                                  the error.
                                "message": "str"  # Optional. The message of the
                                  error. If not present here, this information my also be found in
                                  details object nested under the error object.
                            },
                            "tables": [
                                {
                                    "error": {
                                        "code": "str",  # Optional. The code
                                          associated with the error.
                                        "message": "str"  # Optional. The
                                          message of the error. If not present here, this information
                                          my also be found in details object nested under the error
                                          object.
                                    },
                                    "rows": [
                                        {}  # Optional. A list of rows.
                                    ]
                                }
                            ]
                        }
                    ]
                }
        """

    @distributed_trace_async
    async def execute_queries_in_group(
        self, group_id: str, dataset_id: str, request_message: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Executes Data Analysis Expressions (DAX) queries against the provided dataset.

        DAX query errors will result in:


        * A response error, such as ``DAX query failure``.
        * A failure HTTP status code (400).

        A query that requests more than one table, or more than the allowed number of table rows, will
        result in:


        * Limited data being returned.
        * A response error, such as ``More than one result table in a query`` or ``More than {allowed
        number} rows in a query result``.
        * A successful HTTP status code (200).

        Columns that are fully qualified in the query will be returned with a fully qualified name, for
        example, ``MyTable[MyColumn]``. Columns that are renamed or created in the query will be
        returned within square bracket, for example, ``[MyNewColumn]``.

        Permissions
        -----------

        The user must have `Manage dataset access permissions
        </power-bi/connect-data/service-datasets-manage-access-permissions>`_.

        Required Scope
        --------------

        Dataset.ReadWrite.All or Dataset.Read.All

        Limitations
        -----------


        * Datasets that are hosted in Azure Analysis Services or that have a live connection to an
        on-premises Azure Analysis Services model aren't supported.
        * The tenant setting **Dataset Execute Queries REST API**\ , found under **Integration
        settings**\ , must be enabled.
        * One query per API call.
        * One table request per query.
        * Maximum of 100,000 rows or 1,000,000 values per query (whichever is hit first). For example
        if you query for 5 columns, you can get back max 100,000 rows. If you query for 20 columns, you
        can get back max 50,000 rows (1 million divided by 20).
        * Maximum of 15MB of data per query. Once 15MB is exceeded, the current row will be completed
        but no additional rows will be written.
        * Maximum of 120 requests per user per minute. Target dataset does not impact this rate limit.
        * Service Principals aren't supported for datasets with RLS per `RLS limitations
        </power-bi/admin/service-admin-rls#considerations-and-limitations>`_ or with SSO enabled. To
        use Service Principals, make sure the admin tenant setting `\ *Allow service principals to use
        Power BI APIs*
        </power-bi/admin/service-admin-portal-developer#allow-service-principals-to-use-power-bi-apis>`_
        under *Developer settings* is enabled.
        * Only DAX queries are supported at this time. MDX and DMV queries are not supported.
          :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param request_message: The request message. Is either a JSON type or a IO type. Required.
        :type request_message: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                request_message = {
                    "queries": [
                        {
                            "query": "str"  # The DAX query to be executed. Required.
                        }
                    ],
                    "impersonatedUserName": "str",  # Optional. The UPN of a user to be
                      impersonated. If the model is not RLS enabled, this will be ignored.
                    "serializerSettings": {
                        "includeNulls": bool  # Optional. Whether null (blank) values should
                          be included in the result set. If unspecified, the default value is
                          ``false``.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "error": {
                        "code": "str",  # Optional. The code associated with the error.
                        "message": "str"  # Optional. The message of the error. If not
                          present here, this information my also be found in details object nested
                          under the error object.
                    },
                    "informationProtectionLabel": {
                        "id": "str",  # Optional. The identifier (guid) of the information
                          protection label.
                        "name": "str"  # Optional. The display name of the information
                          protection label.
                    },
                    "results": [
                        {
                            "error": {
                                "code": "str",  # Optional. The code associated with
                                  the error.
                                "message": "str"  # Optional. The message of the
                                  error. If not present here, this information my also be found in
                                  details object nested under the error object.
                            },
                            "tables": [
                                {
                                    "error": {
                                        "code": "str",  # Optional. The code
                                          associated with the error.
                                        "message": "str"  # Optional. The
                                          message of the error. If not present here, this information
                                          my also be found in details object nested under the error
                                          object.
                                    },
                                    "rows": [
                                        {}  # Optional. A list of rows.
                                    ]
                                }
                            ]
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(request_message, (IOBase, bytes)):
            _content = request_message
        else:
            _json = request_message

        _request = build_datasets_execute_queries_in_group_request(
            group_id=group_id,
            dataset_id=dataset_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_query_scale_out_sync_status_in_group(self, group_id: str, dataset_id: str, **kwargs: Any) -> JSON:
        """Returns the query scale-out sync status for the specified dataset from the specified workspace.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Dataset.ReadWrite.All or Dataset.Read.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "commitTimestamp": "2020-02-20 00:00:00",  # Optional. Timestamp indicating
                      the latest commit version.
                    "commitVersion": 0,  # Optional. Latest commit version.
                    "minActiveReadTimestamp": "2020-02-20 00:00:00",  # Optional. Timestamp
                      indicating the minimum active read version.
                    "minActiveReadVersion": 0,  # Optional. Minimum active read version.
                    "scaleOutStatus": "str",  # Optional. Query scale-out status. Known values
                      are: "Enabled", "TenantSettingDisabled", "StorageModeNotSupported", and
                      "ReadOnlyReplicasDisabled".
                    "syncEndTime": "2020-02-20 00:00:00",  # Optional. Timestamp indicating when
                      last sync ended.
                    "syncStartTime": "2020-02-20 00:00:00",  # Optional. Timestamp indicating
                      when last sync started.
                    "targetSyncTimestamp": "2020-02-20 00:00:00",  # Optional. Timestamp
                      indicating the target sync version.
                    "targetSyncVersion": 0,  # Optional. Target sync version.
                    "triggerReason": "str"  # Optional. Query scale-out sync trigger reason.
                      Known values are: "explicit", "automatic", and "system".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_datasets_get_query_scale_out_sync_status_in_group_request(
            group_id=group_id,
            dataset_id=dataset_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def trigger_query_scale_out_sync_in_group(self, group_id: str, dataset_id: str, **kwargs: Any) -> JSON:
        """Triggers a query scale-out sync of read-only replicas for the specified dataset from the
        specified workspace.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Dataset.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "commitTimestamp": "2020-02-20 00:00:00",  # Optional. Timestamp indicating
                      the latest commit version.
                    "commitVersion": 0,  # Optional. Latest commit version.
                    "minActiveReadTimestamp": "2020-02-20 00:00:00",  # Optional. Timestamp
                      indicating the minimum active read version.
                    "minActiveReadVersion": 0,  # Optional. Minimum active read version.
                    "scaleOutStatus": "str",  # Optional. Query scale-out status. Known values
                      are: "Enabled", "TenantSettingDisabled", "StorageModeNotSupported", and
                      "ReadOnlyReplicasDisabled".
                    "syncEndTime": "2020-02-20 00:00:00",  # Optional. Timestamp indicating when
                      last sync ended.
                    "syncStartTime": "2020-02-20 00:00:00",  # Optional. Timestamp indicating
                      when last sync started.
                    "targetSyncTimestamp": "2020-02-20 00:00:00",  # Optional. Timestamp
                      indicating the target sync version.
                    "targetSyncVersion": 0,  # Optional. Target sync version.
                    "triggerReason": "str"  # Optional. Query scale-out sync trigger reason.
                      Known values are: "explicit", "automatic", and "system".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_datasets_trigger_query_scale_out_sync_in_group_request(
            group_id=group_id,
            dataset_id=dataset_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def generate_token_in_group(
        self,
        group_id: str,
        dataset_id: str,
        request_parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Generates an embed token based on the specified dataset from the specified workspace.

        ..

           [!TIP]
           To create embed tokens, it's recommended to use the latest API, `Generate Token
        </rest/api/power-bi/embed-token/generate-token>`_. Generate token supports additional
        functions, such as creating a token for multiple items.

           [!NOTE]
           An embed token can be used to `embed Q&A </power-bi/developer/qanda>`_ within your
        application.

           [!IMPORTANT]
           This API call is only relevant to the `embed for your customers
        </power-bi/developer/embed-sample-for-customers>`_ scenario. To learn more about using this
        API, see `Considerations when generating an embed token
        </power-bi/developer/embedded/generate-embed-token>`_.


        Permissions
        -----------


        * When using a service principal for authentication, refer to `Embed Power BI content with
        service principal </power-bi/developer/embed-service-principal>`_ and `Considerations and
        limitations
        </power-bi/developer/embedded/embed-service-principal#considerations-and-limitations>`_.
        * This API call can be called by a service principal profile. For more information see:
        `Service principal profiles in Power BI Embedded
        </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Dataset.ReadWrite.All or Dataset.Read.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param request_parameters: Generate token parameters. Required.
        :type request_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                request_parameters = {
                    "accessLevel": "str",  # Optional. The required access level for embed token
                      generation. Known values are: "View", "Edit", and "Create".
                    "allowSaveAs": bool,  # Optional. Whether an embedded report can be saved as
                      a new report. The default value is ``false``. Only applies when you generate an
                      embed token for report embedding.
                    "datasetId": "str",  # Optional. The dataset ID used for report creation.
                      Only applies when you generate an embed token for report creation.
                    "identities": [
                        {
                            "username": "str",  # The effective username within a token
                              that applies row-level security rules. For an on-premises model, the
                              username can contain alphanumeric or any of the following characters '.',
                              '-', '_', '!', '#', '^', '~', '""', '@'. For cloud models, the username
                              can contain any ASCII character. For either model, the username length
                              must not exceed 256 characters, and the username shouldn't contain
                              spaces. Required.
                            "customData": "str",  # Optional. `Custom data
                              </power-bi/developer/embedded/embedded-row-level-security#using-the-customdata-feature>`_
                              that's used to apply row-level security rules. Supported for live
                              connection to Azure Analysis Services models and cloud models only.
                            "datasets": [
                                "str"  # Optional. An array of datasets for which
                                  this identity applies.
                            ],
                            "identityBlob": {
                                "value": "str"  # An OAuth 2.0 access token for Azure
                                  SQL. Required.
                            },
                            "reports": [
                                "str"  # Optional. An array of reports for which this
                                  identity applies. Only supported for paginated reports.
                            ],
                            "roles": [
                                "str"  # Optional. An array of row-level security
                                  (RLS) roles within a token that applies RLS rules. An identity can
                                  contain up to 50 roles. A role can contain any character except
                                  ``,``"" , and its length must not exceed 50 characters.
                            ]
                        }
                    ],
                    "lifetimeInMinutes": 0  # Optional. The maximum lifetime of the token in
                      minutes, starting from the time it was generated. Can be used to shorten the
                      expiration time of a token, but not to extend it. The value must be a positive
                      integer. Zero (0) is equivalent to null and will be ignored, resulting in the
                      default expiration time.
                }

                # response body for status code(s): 200
                response == {
                    "expiration": "2020-02-20 00:00:00",  # The date and time (UTC) of token
                      expiration. Required.
                    "token": "str",  # The embed token. Required.
                    "tokenId": "str"  # The unique token ID. Through audit logs, the token ID can
                      be used to correlate operations that use the token with the generate operation.
                      Required.
                }
        """

    @overload
    async def generate_token_in_group(
        self,
        group_id: str,
        dataset_id: str,
        request_parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Generates an embed token based on the specified dataset from the specified workspace.

        ..

           [!TIP]
           To create embed tokens, it's recommended to use the latest API, `Generate Token
        </rest/api/power-bi/embed-token/generate-token>`_. Generate token supports additional
        functions, such as creating a token for multiple items.

           [!NOTE]
           An embed token can be used to `embed Q&A </power-bi/developer/qanda>`_ within your
        application.

           [!IMPORTANT]
           This API call is only relevant to the `embed for your customers
        </power-bi/developer/embed-sample-for-customers>`_ scenario. To learn more about using this
        API, see `Considerations when generating an embed token
        </power-bi/developer/embedded/generate-embed-token>`_.


        Permissions
        -----------


        * When using a service principal for authentication, refer to `Embed Power BI content with
        service principal </power-bi/developer/embed-service-principal>`_ and `Considerations and
        limitations
        </power-bi/developer/embedded/embed-service-principal#considerations-and-limitations>`_.
        * This API call can be called by a service principal profile. For more information see:
        `Service principal profiles in Power BI Embedded
        </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Dataset.ReadWrite.All or Dataset.Read.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param request_parameters: Generate token parameters. Required.
        :type request_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "expiration": "2020-02-20 00:00:00",  # The date and time (UTC) of token
                      expiration. Required.
                    "token": "str",  # The embed token. Required.
                    "tokenId": "str"  # The unique token ID. Through audit logs, the token ID can
                      be used to correlate operations that use the token with the generate operation.
                      Required.
                }
        """

    @distributed_trace_async
    async def generate_token_in_group(
        self, group_id: str, dataset_id: str, request_parameters: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Generates an embed token based on the specified dataset from the specified workspace.

        ..

           [!TIP]
           To create embed tokens, it's recommended to use the latest API, `Generate Token
        </rest/api/power-bi/embed-token/generate-token>`_. Generate token supports additional
        functions, such as creating a token for multiple items.

           [!NOTE]
           An embed token can be used to `embed Q&A </power-bi/developer/qanda>`_ within your
        application.

           [!IMPORTANT]
           This API call is only relevant to the `embed for your customers
        </power-bi/developer/embed-sample-for-customers>`_ scenario. To learn more about using this
        API, see `Considerations when generating an embed token
        </power-bi/developer/embedded/generate-embed-token>`_.


        Permissions
        -----------


        * When using a service principal for authentication, refer to `Embed Power BI content with
        service principal </power-bi/developer/embed-service-principal>`_ and `Considerations and
        limitations
        </power-bi/developer/embedded/embed-service-principal#considerations-and-limitations>`_.
        * This API call can be called by a service principal profile. For more information see:
        `Service principal profiles in Power BI Embedded
        </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Dataset.ReadWrite.All or Dataset.Read.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :param request_parameters: Generate token parameters. Is either a JSON type or a IO type.
         Required.
        :type request_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                request_parameters = {
                    "accessLevel": "str",  # Optional. The required access level for embed token
                      generation. Known values are: "View", "Edit", and "Create".
                    "allowSaveAs": bool,  # Optional. Whether an embedded report can be saved as
                      a new report. The default value is ``false``. Only applies when you generate an
                      embed token for report embedding.
                    "datasetId": "str",  # Optional. The dataset ID used for report creation.
                      Only applies when you generate an embed token for report creation.
                    "identities": [
                        {
                            "username": "str",  # The effective username within a token
                              that applies row-level security rules. For an on-premises model, the
                              username can contain alphanumeric or any of the following characters '.',
                              '-', '_', '!', '#', '^', '~', '""', '@'. For cloud models, the username
                              can contain any ASCII character. For either model, the username length
                              must not exceed 256 characters, and the username shouldn't contain
                              spaces. Required.
                            "customData": "str",  # Optional. `Custom data
                              </power-bi/developer/embedded/embedded-row-level-security#using-the-customdata-feature>`_
                              that's used to apply row-level security rules. Supported for live
                              connection to Azure Analysis Services models and cloud models only.
                            "datasets": [
                                "str"  # Optional. An array of datasets for which
                                  this identity applies.
                            ],
                            "identityBlob": {
                                "value": "str"  # An OAuth 2.0 access token for Azure
                                  SQL. Required.
                            },
                            "reports": [
                                "str"  # Optional. An array of reports for which this
                                  identity applies. Only supported for paginated reports.
                            ],
                            "roles": [
                                "str"  # Optional. An array of row-level security
                                  (RLS) roles within a token that applies RLS rules. An identity can
                                  contain up to 50 roles. A role can contain any character except
                                  ``,``"" , and its length must not exceed 50 characters.
                            ]
                        }
                    ],
                    "lifetimeInMinutes": 0  # Optional. The maximum lifetime of the token in
                      minutes, starting from the time it was generated. Can be used to shorten the
                      expiration time of a token, but not to extend it. The value must be a positive
                      integer. Zero (0) is equivalent to null and will be ignored, resulting in the
                      default expiration time.
                }

                # response body for status code(s): 200
                response == {
                    "expiration": "2020-02-20 00:00:00",  # The date and time (UTC) of token
                      expiration. Required.
                    "token": "str",  # The embed token. Required.
                    "tokenId": "str"  # The unique token ID. Through audit logs, the token ID can
                      be used to correlate operations that use the token with the generate operation.
                      Required.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(request_parameters, (IOBase, bytes)):
            _content = request_parameters
        else:
            _json = request_parameters

        _request = build_datasets_generate_token_in_group_request(
            group_id=group_id,
            dataset_id=dataset_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_datasets_as_admin(
        self, *, filter: Optional[str] = None, top: Optional[int] = None, skip: Optional[int] = None, **kwargs: Any
    ) -> JSON:
        """Returns a list of datasets for the organization.

        Each request takes two seconds to process, during which time other requests are queued.

        Permissions
        -----------


        * The user must have administrator rights (such as Office 365 Global Administrator or Power BI
        Service Administrator) or authenticate using a service principal.
        * Delegated permissions are supported.

        When running under service prinicipal authentication, an app **must not** have any
        admin-consent required premissions for Power BI set on it in the Azure portal.

        Required Scope
        --------------

        Tenant.Read.All or Tenant.ReadWrite.All

        Relevant only when authenticating via a standard delegated admin access token. Must not be
        present when authentication via a service principal is used.
        :code:`<br>`:code:`<br>`.

        :keyword filter: Filters the results, based on a boolean condition. Default value is None.
        :paramtype filter: str
        :keyword top: Returns only the first n results. Default value is None.
        :paramtype top: int
        :keyword skip: Skips the first n results. Default value is None.
        :paramtype skip: int
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional. OData context.
                    "value": [
                        {
                            "id": "str",  # The dataset ID. Required.
                            "ContentProviderType": "str",  # Optional. The content
                              provider type for the dataset.
                            "CreateReportEmbedURL": "str",  # Optional. The dataset
                              create report embed URL.
                            "CreatedDate": "2020-02-20 00:00:00",  # Optional. The
                              dataset creation date and time.
                            "Encryption": {
                                "EncryptionStatus": "str"  # Optional. Dataset
                                  encryption status. Known values are: "Unknown", "NotSupported",
                                  "InSyncWithWorkspace", and "NotInSyncWithWorkspace".
                            },
                            "IsEffectiveIdentityRequired": bool,  # Optional. Whether the
                              dataset requires an effective identity, which you must send in a
                              `GenerateToken </rest/api/power-bi/embed-token/generate-token>`_ API
                              call.
                            "IsEffectiveIdentityRolesRequired": bool,  # Optional.
                              Whether row-level security is defined inside the Power BI .pbix file. If
                              so, you must specify a role.
                            "IsInPlaceSharingEnabled": bool,  # Optional. Whether the
                              dataset can be shared with external users to be consumed in their own
                              tenant.
                            "IsOnPremGatewayRequired": bool,  # Optional. Whether the
                              dataset requires an on-premises data gateway.
                            "IsRefreshable": bool,  # Optional. Whether the dataset is
                              refreshable or not. A Power BI refreshable dataset is a dataset that has
                              been refreshed at least once, or for which a valid refresh schedule
                              exists.
                            "QnaEmbedURL": "str",  # Optional. The dataset Q&A embed URL.
                            "addRowsAPIEnabled": bool,  # Optional. Whether the dataset
                              allows adding new rows.
                            "configuredBy": "str",  # Optional. The dataset owner.
                            "description": "str",  # Optional. The dataset description.
                            "name": "str",  # Optional. The dataset name.
                            "queryScaleOutSettings": {
                                "autoSyncReadOnlyReplicas": bool,  # Optional.
                                  Whether the dataset automatically syncs read-only replicas.
                                "maxReadOnlyReplicas": 0  # Optional. Maximum number
                                  of read-only replicas for the dataset (0-64, -1 for automatic number
                                  of replicas).
                            },
                            "targetStorageMode": "str",  # Optional. The dataset storage
                              mode.
                            "upstreamDataflows": [
                                {
                                    "groupId": "str",  # Optional. The target
                                      group ID.
                                    "targetDataflowId": "str"  # Optional. The
                                      target dataflow ID.
                                }
                            ],
                            "users": [
                                {
                                    "datasetUserAccessRight": "str",  # The
                                      access right that the user has for the dataset (permission
                                      level). Required. Known values are: "None", "Read", "ReadWrite",
                                      "ReadReshare", "ReadWriteReshare", "ReadExplore",
                                      "ReadReshareExplore", "ReadWriteExplore", and
                                      "ReadWriteReshareExplore".
                                    "identifier": "str",  # Identifier of the
                                      principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "displayName": "str",  # Optional. Display
                                      name of the principal.
                                    "emailAddress": "str",  # Optional. Email
                                      address of the user.
                                    "graphId": "str",  # Optional. Identifier of
                                      the principal in Microsoft Graph. Only available for admin APIs.
                                    "profile": {
                                        "id": "str",  # The service principal
                                          profile ID. Required.
                                        "displayName": "str"  # Optional. The
                                          service principal profile name.
                                    },
                                    "userType": "str"  # Optional. Type of the
                                      user.
                                }
                            ],
                            "webUrl": "str",  # Optional. The web URL of the dataset.
                            "workspaceId": "str"  # Optional. The dataset workspace ID.
                              This property will be returned only in GetDatasetsAsAdmin.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_datasets_get_datasets_as_admin_request(
            filter=filter,
            top=top,
            skip=skip,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_datasources_as_admin(self, dataset_id: str, **kwargs: Any) -> JSON:
        """Returns a list of data sources for the specified dataset.

        Each request takes 0.5 seconds to process, during which time other requests are queued.

        Permissions
        -----------


        * The user must have administrator rights (such as Office 365 Global Administrator or Power BI
        Service Administrator) or authenticate using a service principal.
        * Delegated permissions are supported.

        When running under service prinicipal authentication, an app **must not** have any
        admin-consent required premissions for Power BI set on it in the Azure portal.

        Required Scope
        --------------

        Tenant.Read.All or Tenant.ReadWrite.All

        Relevant only when authenticating via a standard delegated admin access token. Must not be
        present when authentication via a service principal is used.
        :code:`<br>`:code:`<br>`.

        :param dataset_id: Required.
        :type dataset_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional. OData context.
                    "value": [
                        {
                            "connectionDetails": {
                                "account": "str",  # Optional. The connection
                                  account.
                                "classInfo": "str",  # Optional. The connection class
                                  information.
                                "database": "str",  # Optional. The connection
                                  database.
                                "domain": "str",  # Optional. The connection domain.
                                "emailAddress": "str",  # Optional. The connection
                                  email address.
                                "kind": "str",  # Optional. The connection kind.
                                "loginServer": "str",  # Optional. The connection
                                  login server.
                                "path": "str",  # Optional. The connection path.
                                "server": "str",  # Optional. The connection server.
                                "url": "str"  # Optional. The connection URL.
                            },
                            "connectionString": "str",  # Optional. (Deprecated) The data
                              source connection string. Available only for DirectQuery.
                            "datasourceId": "str",  # Optional. The bound data source ID,
                              which is empty when not bound to a gateway.
                            "datasourceType": "str",  # Optional. The data source type.
                            "gatewayId": "str",  # Optional. The bound gateway ID, which
                              is empty when not bound to a gateway. When using a gateway cluster, the
                              gateway ID refers to the primary (first) gateway in the cluster and is
                              similar to the gateway cluster ID.
                            "name": "str"  # Optional. (Deprecated) The data source name.
                              Available only for DirectQuery.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_datasets_get_datasources_as_admin_request(
            dataset_id=dataset_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_dataset_users_as_admin(self, dataset_id: str, **kwargs: Any) -> JSON:
        """Returns a list of users that have access to the specified dataset.

        Permissions
        -----------


        * The user must have administrator rights (such as Office 365 Global Administrator or Power BI
        Service Administrator) or authenticate using a service principal.
        * Delegated permissions are supported.
        * The permissions for this API call are listed in `Datasets permissions
        </power-bi/developer/embedded/datasets-permissions>`_.

        When running under service prinicipal authentication, an app **must not** have any
        admin-consent required premissions for Power BI set on it in the Azure portal.

        Required Scope
        --------------

        Tenant.Read.All or Tenant.ReadWrite.All

        Relevant only when authenticating via a standard delegated admin access token. Must not be
        present when authentication via a service principal is used.

        Limitations
        -----------

        Maximum 200 requests per hour.
        :code:`<br>`:code:`<br>`.

        :param dataset_id: The dataset ID. Required.
        :type dataset_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional.
                    "value": [
                        {
                            "datasetUserAccessRight": "str",  # The access right that the
                              user has for the dataset (permission level). Required. Known values are:
                              "None", "Read", "ReadWrite", "ReadReshare", "ReadWriteReshare",
                              "ReadExplore", "ReadReshareExplore", "ReadWriteExplore", and
                              "ReadWriteReshareExplore".
                            "identifier": "str",  # Identifier of the principal.
                              Required.
                            "principalType": "str",  # The principal type. Required.
                              Known values are: "None", "User", "Group", and "App".
                            "displayName": "str",  # Optional. Display name of the
                              principal.
                            "emailAddress": "str",  # Optional. Email address of the
                              user.
                            "graphId": "str",  # Optional. Identifier of the principal in
                              Microsoft Graph. Only available for admin APIs.
                            "profile": {
                                "id": "str",  # The service principal profile ID.
                                  Required.
                                "displayName": "str"  # Optional. The service
                                  principal profile name.
                            },
                            "userType": "str"  # Optional. Type of the user.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_datasets_get_dataset_users_as_admin_request(
            dataset_id=dataset_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_datasets_in_group_as_admin(
        self,
        group_id: str,
        *,
        filter: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        expand: Optional[str] = None,
        **kwargs: Any
    ) -> JSON:
        """Returns a list of datasets from the specified workspace.

        Permissions
        -----------


        * The user must have administrator rights (such as Office 365 Global Administrator or Power BI
        Service Administrator) or authenticate using a service principal.
        * Delegated permissions are supported.

        When running under service prinicipal authentication, an app **must not** have any
        admin-consent required premissions for Power BI set on it in the Azure portal.

        Required Scope
        --------------

        Tenant.Read.All or Tenant.ReadWrite.All

        Relevant only when authenticating via a standard delegated admin access token. Must not be
        present when authentication via a service principal is used.

        Limitations
        -----------

        Maximum 200 requests per hour.
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :keyword filter: Filters the results, based on a boolean condition. Default value is None.
        :paramtype filter: str
        :keyword top: Returns only the first n results. Default value is None.
        :paramtype top: int
        :keyword skip: Skips the first n results. Default value is None.
        :paramtype skip: int
        :keyword expand: Expands related entities inline. Default value is None.
        :paramtype expand: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional. OData context.
                    "value": [
                        {
                            "id": "str",  # The dataset ID. Required.
                            "ContentProviderType": "str",  # Optional. The content
                              provider type for the dataset.
                            "CreateReportEmbedURL": "str",  # Optional. The dataset
                              create report embed URL.
                            "CreatedDate": "2020-02-20 00:00:00",  # Optional. The
                              dataset creation date and time.
                            "Encryption": {
                                "EncryptionStatus": "str"  # Optional. Dataset
                                  encryption status. Known values are: "Unknown", "NotSupported",
                                  "InSyncWithWorkspace", and "NotInSyncWithWorkspace".
                            },
                            "IsEffectiveIdentityRequired": bool,  # Optional. Whether the
                              dataset requires an effective identity, which you must send in a
                              `GenerateToken </rest/api/power-bi/embed-token/generate-token>`_ API
                              call.
                            "IsEffectiveIdentityRolesRequired": bool,  # Optional.
                              Whether row-level security is defined inside the Power BI .pbix file. If
                              so, you must specify a role.
                            "IsInPlaceSharingEnabled": bool,  # Optional. Whether the
                              dataset can be shared with external users to be consumed in their own
                              tenant.
                            "IsOnPremGatewayRequired": bool,  # Optional. Whether the
                              dataset requires an on-premises data gateway.
                            "IsRefreshable": bool,  # Optional. Whether the dataset is
                              refreshable or not. A Power BI refreshable dataset is a dataset that has
                              been refreshed at least once, or for which a valid refresh schedule
                              exists.
                            "QnaEmbedURL": "str",  # Optional. The dataset Q&A embed URL.
                            "addRowsAPIEnabled": bool,  # Optional. Whether the dataset
                              allows adding new rows.
                            "configuredBy": "str",  # Optional. The dataset owner.
                            "description": "str",  # Optional. The dataset description.
                            "name": "str",  # Optional. The dataset name.
                            "queryScaleOutSettings": {
                                "autoSyncReadOnlyReplicas": bool,  # Optional.
                                  Whether the dataset automatically syncs read-only replicas.
                                "maxReadOnlyReplicas": 0  # Optional. Maximum number
                                  of read-only replicas for the dataset (0-64, -1 for automatic number
                                  of replicas).
                            },
                            "targetStorageMode": "str",  # Optional. The dataset storage
                              mode.
                            "upstreamDataflows": [
                                {
                                    "groupId": "str",  # Optional. The target
                                      group ID.
                                    "targetDataflowId": "str"  # Optional. The
                                      target dataflow ID.
                                }
                            ],
                            "users": [
                                {
                                    "datasetUserAccessRight": "str",  # The
                                      access right that the user has for the dataset (permission
                                      level). Required. Known values are: "None", "Read", "ReadWrite",
                                      "ReadReshare", "ReadWriteReshare", "ReadExplore",
                                      "ReadReshareExplore", "ReadWriteExplore", and
                                      "ReadWriteReshareExplore".
                                    "identifier": "str",  # Identifier of the
                                      principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "displayName": "str",  # Optional. Display
                                      name of the principal.
                                    "emailAddress": "str",  # Optional. Email
                                      address of the user.
                                    "graphId": "str",  # Optional. Identifier of
                                      the principal in Microsoft Graph. Only available for admin APIs.
                                    "profile": {
                                        "id": "str",  # The service principal
                                          profile ID. Required.
                                        "displayName": "str"  # Optional. The
                                          service principal profile name.
                                    },
                                    "userType": "str"  # Optional. Type of the
                                      user.
                                }
                            ],
                            "webUrl": "str",  # Optional. The web URL of the dataset.
                            "workspaceId": "str"  # Optional. The dataset workspace ID.
                              This property will be returned only in GetDatasetsAsAdmin.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_datasets_get_datasets_in_group_as_admin_request(
            group_id=group_id,
            filter=filter,
            top=top,
            skip=skip,
            expand=expand,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_dataset_to_dataflows_links_in_group_as_admin(  # pylint: disable=name-too-long
        self, group_id: str, **kwargs: Any
    ) -> JSON:
        """Returns a list of upstream dataflows for datasets from the specified workspace.

        Permissions
        -----------


        * The user must have administrator rights (such as Office 365 Global Administrator or Power BI
        Service Administrator) or authenticate using a service principal.
        * Delegated permissions are supported.

        When running under service prinicipal authentication, an app **must not** have any
        admin-consent required premissions for Power BI set on it in the Azure portal.

        Required Scope
        --------------

        Tenant.Read.All or Tenant.ReadWrite.All

        Relevant only when authenticating via a standard delegated admin access token. Must not be
        present when authentication via a service principal is used.

        Limitations
        -----------

        Maximum 200 requests per hour.
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional.
                    "value": [
                        {
                            "dataflowObjectId": "str",  # Optional. The dataflow object
                              ID.
                            "datasetObjectId": "str",  # Optional. The dataset object ID.
                            "workspaceObjectId": "str"  # Optional. The workspace object
                              ID.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_datasets_get_dataset_to_dataflows_links_in_group_as_admin_request(
            group_id=group_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore


class UsersOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~power_bi_client.aio.PowerBIClient`'s
        :attr:`users` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def refresh_user_permissions(self, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Refreshes user permissions in Power BI.

        When a user is granted permissions to a workspace, app, or Power BI item (such as a report or a
        dashboard), the new permissions might not be immediately available through API calls. This
        operation refreshes user permissions to ensure they're fully updated.

        ..

           [!IMPORTANT]


           * Call **Refresh User Permissions** before making other API calls.
           * Since it takes about two minutes for the permissions to get refreshed, wait for two
        minutes before making other API calls.


        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Workspace.Read.All or Workspace.ReadWrite.All

        Limitations
        -----------

        Maximum one call per user per hour.
        :code:`<br>`:code:`<br>`.

        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_users_refresh_user_permissions_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get_user_artifact_access_as_admin(
        self,
        user_id: str,
        *,
        continuation_token_parameter: Optional[str] = None,
        artifact_types: Optional[str] = None,
        **kwargs: Any
    ) -> JSON:
        """Returns a list of Power BI items (such as reports or dashboards) that the specified user has
        access to.

        Permissions
        -----------


        * The user must have administrator rights (such as Office 365 Global Administrator or Power BI
        Service Administrator) or authenticate using a service principal.
        * Delegated permissions are supported.

        Required Scope
        --------------

        Tenant.Read.All or Tenant.ReadWrite.All

        Limitations
        -----------

        Maximum 200 requests per hour.
        :code:`<br>`:code:`<br>`.

        :param user_id: The graph ID or user principal name (UPN) of the user. Required.
        :type user_id: str
        :keyword continuation_token_parameter: Token required to get the next chunk of the result set.
         Default value is None.
        :paramtype continuation_token_parameter: str
        :keyword artifact_types: Comma separated list of artifact types. Default value is None.
        :paramtype artifact_types: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "artifactAccessEntities": [
                        {
                            "accessRight": "str",  # The access right that the user has
                              for the Power BI item. Required.
                            "artifactId": "str",  # The Power BI item ID. Required.
                            "artifactType": "str",  # The type of Power BI item.
                              Required. Known values are: "Report", "PaginatedReport", "Dashboard",
                              "Dataset", "Dataflow", "PersonalGroup", "Group", "Workspace", "Capacity",
                              and "App".
                            "displayName": "str",  # The display name of the Power BI
                              item. Required.
                            "shareType": "str",  # Optional. The type of how the access
                              is given to the Power BI item. Only available for widely shared artifacts
                              APIs.
                            "sharer": {
                                "identifier": "str",  # Identifier of the principal.
                                  Required.
                                "principalType": "str",  # The principal type.
                                  Required. Known values are: "None", "User", "Group", and "App".
                                "displayName": "str",  # Optional. Display name of
                                  the principal.
                                "emailAddress": "str",  # Optional. Email address of
                                  the user.
                                "graphId": "str",  # Optional. Identifier of the
                                  principal in Microsoft Graph. Only available for admin APIs.
                                "profile": {
                                    "id": "str",  # The service principal profile
                                      ID. Required.
                                    "displayName": "str"  # Optional. The service
                                      principal profile name.
                                },
                                "userType": "str"  # Optional. Type of the user.
                            }
                        }
                    ],
                    "continuationToken": "str",  # Optional. The token for the next chunk in the
                      result set.
                    "continuationUri": "str",  # Optional. The URI of the next chunk in the
                      result set.
                    "odata.context": "str"  # Optional.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_users_get_user_artifact_access_as_admin_request(
            user_id=user_id,
            continuation_token_parameter=continuation_token_parameter,
            artifact_types=artifact_types,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_user_subscriptions_as_admin(
        self, user_id: str, *, continuation_token_parameter: Optional[str] = None, **kwargs: Any
    ) -> JSON:
        """Returns a list of subscriptions for the specified user. This is a preview API call.

        Permissions
        ^^^^^^^^^^^


        * The user must have administrator rights (such as Office 365 Global Administrator or Power BI
        Service Administrator) or authenticate using a service principal.
        * Delegated permissions are supported.

        Required Scope
        --------------

        Tenant.Read.All or Tenant.ReadWrite.All

        Limitations
        -----------

        Maximum 200 requests per hour.
        :code:`<br>`:code:`<br>`.

        :param user_id: The graph ID or user principal name (UPN) of the user. Required.
        :type user_id: str
        :keyword continuation_token_parameter: Token required to get the next chunk of the result set.
         Default value is None.
        :paramtype continuation_token_parameter: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "continuationToken": "str",  # Optional. Token to get the next chunk of the
                      result set.
                    "continuationUri": "str",  # Optional. The URI for the next chunk in the
                      result set.
                    "odata.context": "str",  # Optional.
                    "subscriptionEntities": [
                        {
                            "id": "str",  # The subscription ID. Required.
                            "artifactDisplayName": "str",  # Optional. The name of the
                              subscribed Power BI item (such as a report or a dashboard).
                            "artifactId": "str",  # Optional. The ID of the subscribed
                              Power BI item (such as a report or a dashboard).
                            "artifactType": "str",  # Optional. The type of Power BI item
                              (for example a ``Report``"" , ``Dashboard``"" , or ``Dataset``"" ).
                            "attachmentFormat": "str",  # Optional. Format of the report
                              attached in the email subscription.
                            "endDate": "2020-02-20 00:00:00",  # Optional. The end date
                              and time of the email subscription.
                            "frequency": "str",  # Optional. The frequency of the email
                              subscription.
                            "isEnabled": bool,  # Optional. Whether the email
                              subscription is enabled.
                            "linkToContent": bool,  # Optional. Whether a subscription
                              link exists in the email subscription.
                            "previewImage": bool,  # Optional. Whether a screenshot of
                              the report exists in the email subscription.
                            "startDate": "2020-02-20 00:00:00",  # Optional. The start
                              date and time of the email subscription.
                            "subArtifactDisplayName": "str",  # Optional. The page name
                              of the subscribed Power BI item, if it's a report.
                            "title": "str",  # Optional. The app name.
                            "users": [
                                {
                                    "identifier": "str",  # Identifier of the
                                      principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "displayName": "str",  # Optional. Display
                                      name of the principal.
                                    "emailAddress": "str",  # Optional. Email
                                      address of the user.
                                    "graphId": "str",  # Optional. Identifier of
                                      the principal in Microsoft Graph. Only available for admin APIs.
                                    "profile": {
                                        "id": "str",  # The service principal
                                          profile ID. Required.
                                        "displayName": "str"  # Optional. The
                                          service principal profile name.
                                    },
                                    "userType": "str"  # Optional. Type of the
                                      user.
                                }
                            ]
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_users_get_user_subscriptions_as_admin_request(
            user_id=user_id,
            continuation_token_parameter=continuation_token_parameter,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore


class ImportsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~power_bi_client.aio.PowerBIClient`'s
        :attr:`imports` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get_imports(self, **kwargs: Any) -> JSON:
        """Returns a list of imports from **My workspace**.

        Required Scope
        --------------

        Dataset.ReadWrite.All or Dataset.Read.All
        :code:`<br>`:code:`<br>`.

        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional. OData context.
                    "value": [
                        {
                            "id": "str",  # The import ID. Required.
                            "createdDateTime": "2020-02-20 00:00:00",  # Optional. Import
                              creation date and time.
                            "datasets": [
                                {
                                    "id": "str",  # The dataset ID. Required.
                                    "ContentProviderType": "str",  # Optional.
                                      The content provider type for the dataset.
                                    "CreateReportEmbedURL": "str",  # Optional.
                                      The dataset create report embed URL.
                                    "CreatedDate": "2020-02-20 00:00:00",  #
                                      Optional. The dataset creation date and time.
                                    "Encryption": {
                                        "EncryptionStatus": "str"  #
                                          Optional. Dataset encryption status. Known values are:
                                          "Unknown", "NotSupported", "InSyncWithWorkspace", and
                                          "NotInSyncWithWorkspace".
                                    },
                                    "IsEffectiveIdentityRequired": bool,  #
                                      Optional. Whether the dataset requires an effective identity,
                                      which you must send in a `GenerateToken
                                      </rest/api/power-bi/embed-token/generate-token>`_ API call.
                                    "IsEffectiveIdentityRolesRequired": bool,  #
                                      Optional. Whether row-level security is defined inside the Power
                                      BI .pbix file. If so, you must specify a role.
                                    "IsInPlaceSharingEnabled": bool,  # Optional.
                                      Whether the dataset can be shared with external users to be
                                      consumed in their own tenant.
                                    "IsOnPremGatewayRequired": bool,  # Optional.
                                      Whether the dataset requires an on-premises data gateway.
                                    "IsRefreshable": bool,  # Optional. Whether
                                      the dataset is refreshable or not. A Power BI refreshable dataset
                                      is a dataset that has been refreshed at least once, or for which
                                      a valid refresh schedule exists.
                                    "QnaEmbedURL": "str",  # Optional. The
                                      dataset Q&A embed URL.
                                    "addRowsAPIEnabled": bool,  # Optional.
                                      Whether the dataset allows adding new rows.
                                    "configuredBy": "str",  # Optional. The
                                      dataset owner.
                                    "description": "str",  # Optional. The
                                      dataset description.
                                    "name": "str",  # Optional. The dataset name.
                                    "queryScaleOutSettings": {
                                        "autoSyncReadOnlyReplicas": bool,  #
                                          Optional. Whether the dataset automatically syncs read-only
                                          replicas.
                                        "maxReadOnlyReplicas": 0  # Optional.
                                          Maximum number of read-only replicas for the dataset (0-64,
                                          -1 for automatic number of replicas).
                                    },
                                    "targetStorageMode": "str",  # Optional. The
                                      dataset storage mode.
                                    "upstreamDataflows": [
                                        {
                                            "groupId": "str",  #
                                              Optional. The target group ID.
                                            "targetDataflowId": "str"  #
                                              Optional. The target dataflow ID.
                                        }
                                    ],
                                    "users": [
                                        {
                                            "datasetUserAccessRight":
                                              "str",  # The access right that the user has for the
                                              dataset (permission level). Required. Known values are:
                                              "None", "Read", "ReadWrite", "ReadReshare",
                                              "ReadWriteReshare", "ReadExplore", "ReadReshareExplore",
                                              "ReadWriteExplore", and "ReadWriteReshareExplore".
                                            "identifier": "str",  #
                                              Identifier of the principal. Required.
                                            "principalType": "str",  #
                                              The principal type. Required. Known values are: "None",
                                              "User", "Group", and "App".
                                            "displayName": "str",  #
                                              Optional. Display name of the principal.
                                            "emailAddress": "str",  #
                                              Optional. Email address of the user.
                                            "graphId": "str",  #
                                              Optional. Identifier of the principal in Microsoft Graph.
                                              Only available for admin APIs.
                                            "profile": {
                                                "id": "str",  # The
                                                  service principal profile ID. Required.
                                                "displayName": "str"
                                                  # Optional. The service principal profile name.
                                            },
                                            "userType": "str"  #
                                              Optional. Type of the user.
                                        }
                                    ],
                                    "webUrl": "str"  # Optional. The web URL of
                                      the dataset.
                                }
                            ],
                            "importState": "str",  # Optional. The import upload state.
                              Known values are: "Publishing", "Succeeded", and "Failed".
                            "name": "str",  # Optional. The import name.
                            "reports": [
                                {
                                    "id": "str",  # The report ID. Required.
                                    "appId": "str",  # Optional. The app ID,
                                      returned only if the report belongs to an app.
                                    "datasetId": "str",  # Optional. The dataset
                                      ID of the report.
                                    "description": "str",  # Optional. The report
                                      description.
                                    "embedUrl": "str",  # Optional. The embed URL
                                      of the report.
                                    "name": "str",  # Optional. The name of the
                                      report.
                                    "reportType": "str",  # Optional. The report
                                      type. "PaginatedReport"
                                    "subscriptions": [
                                        {
                                            "id": "str",  # The
                                              subscription ID. Required.
                                            "artifactDisplayName": "str",
                                              # Optional. The name of the subscribed Power BI item
                                              (such as a report or a dashboard).
                                            "artifactId": "str",  #
                                              Optional. The ID of the subscribed Power BI item (such as
                                              a report or a dashboard).
                                            "artifactType": "str",  #
                                              Optional. The type of Power BI item (for example a
                                              ``Report``"" , ``Dashboard``"" , or ``Dataset``"" ).
                                            "attachmentFormat": "str",  #
                                              Optional. Format of the report attached in the email
                                              subscription.
                                            "endDate": "2020-02-20
                                              00:00:00",  # Optional. The end date and time of the
                                              email subscription.
                                            "frequency": "str",  #
                                              Optional. The frequency of the email subscription.
                                            "isEnabled": bool,  #
                                              Optional. Whether the email subscription is enabled.
                                            "linkToContent": bool,  #
                                              Optional. Whether a subscription link exists in the email
                                              subscription.
                                            "previewImage": bool,  #
                                              Optional. Whether a screenshot of the report exists in
                                              the email subscription.
                                            "startDate": "2020-02-20
                                              00:00:00",  # Optional. The start date and time of the
                                              email subscription.
                                            "subArtifactDisplayName":
                                              "str",  # Optional. The page name of the subscribed Power
                                              BI item, if it's a report.
                                            "title": "str",  # Optional.
                                              The app name.
                                            "users": [
                                                {
                                                    "identifier":
                                                      "str",  # Identifier of the principal. Required.
                "principalType": "str",  # The principal type.
                                                      Required. Known values are: "None", "User",
                                                      "Group", and "App".
                "displayName": "str",  # Optional. Display name
                                                      of the principal.
                "emailAddress": "str",  # Optional. Email address
                                                      of the user.
                                                    "graphId":
                                                      "str",  # Optional. Identifier of the principal
                                                      in Microsoft Graph. Only available for admin
                                                      APIs.
                                                    "profile": {
                                                        "id":
                                                          "str",  # The service principal profile ID.
                                                          Required.
                "displayName": "str"  # Optional. The service
                                                          principal profile name.
                                                    },
                                                    "userType":
                                                      "str"  # Optional. Type of the user.
                                                }
                                            ]
                                        }
                                    ],
                                    "users": [
                                        {
                                            "identifier": "str",  #
                                              Identifier of the principal. Required.
                                            "principalType": "str",  #
                                              The principal type. Required. Known values are: "None",
                                              "User", "Group", and "App".
                                            "reportUserAccessRight":
                                              "str",  # The access right that the user has for the
                                              report (permission level). Required. Known values are:
                                              "None", "Read", "ReadWrite", "ReadReshare", "ReadCopy",
                                              and "Owner".
                                            "displayName": "str",  #
                                              Optional. Display name of the principal.
                                            "emailAddress": "str",  #
                                              Optional. Email address of the user.
                                            "graphId": "str",  #
                                              Optional. Identifier of the principal in Microsoft Graph.
                                              Only available for admin APIs.
                                            "profile": {
                                                "id": "str",  # The
                                                  service principal profile ID. Required.
                                                "displayName": "str"
                                                  # Optional. The service principal profile name.
                                            },
                                            "userType": "str"  #
                                              Optional. Type of the user.
                                        }
                                    ],
                                    "webUrl": "str"  # Optional. The web URL of
                                      the report.
                                }
                            ],
                            "updatedDateTime": "2020-02-20 00:00:00"  # Optional. Import
                              last update date and time.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_imports_get_imports_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def post_import(
        self,
        import_info: JSON,
        *,
        dataset_display_name: str,
        name_conflict: Optional[str] = None,
        skip_report: Optional[bool] = None,
        override_report_label: Optional[bool] = None,
        override_model_label: Optional[bool] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Creates new content in **My workspace**.

        See the `Import Large Files
        <https://github.com/microsoft/PowerBI-Developer-Samples/blob/master/PowerShell%20Scripts/Import%20Large%20Files>`_
        PowerShell script for an example of using this API.

        ..

           [!NOTE]
           Supported content:


           * Power BI .pbix files
           * JSON files (.json)
           * Excel files (.xlsx)
           * RDL files (.rdl)



        * To import a file, specify the content type **multipart/form-data** in the request headers and
        encode the file as `form data <https://www.w3.org/TR/html401/interact/forms.html>`_ in the
        request body.
        * To import an .rdl file, include the file extension in the name specified by
        ``datasetDisplayName``\ , as described in `URI parameters
        </rest/api/power-bi/imports/post-import-in-group#uri-parameters>`_.
        * To import an .xlsx file from OneDrive for Business, include the content type
        **application/json** in the request headers. Include `ImportInfo
        </rest/api/power-bi/imports/post-import-in-group#importinfo>`_ with ``filePath`` set to the
        .xlsx file path in the request body.
        * To import large Power BI .pbix files that are between 1 GB and 10 GB in size, see `Create
        Temporary Upload Location </rest/api/power-bi/imports/create-temporary-upload-location>`_. This
        is only supported for Premium capacity workspaces.
        * To create a dataflow from a model.json file, set ``datasetDisplayName`` to *model.json*\ , as
        described in `URI parameters
        </rest/api/power-bi/imports/post-import-in-group#uri-parameters>`_.

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------


        * Dataflows with service principal aren't supported.
        * Importing a Power BI .pbix file from OneDrive isn't supported.
        * Importing a file that has a **protected** sensitivity label isn't supported for service
        principals.
          :code:`<br>`:code:`<br>`.

        :param import_info: The import to post. Required.
        :type import_info: JSON
        :keyword dataset_display_name: The display name of the dataset, should include file extension.
         Not supported when importing from OneDrive for Business. Required.
        :paramtype dataset_display_name: str
        :keyword name_conflict: Specifies what to do if a dataset with the same name already exists.
         The default value is ``Ignore``. For RDL files, ``Abort`` and ``Overwrite`` are the only
         supported options. Known values are: "Ignore", "Abort", "Overwrite", "CreateOrOverwrite", and
         "GenerateUniqueName". Default value is None.
        :paramtype name_conflict: str
        :keyword skip_report: Whether to skip report import. If specified, the value must be ``true``.
         Only supported for Power BI .pbix files. Default value is None.
        :paramtype skip_report: bool
        :keyword override_report_label: Whether to override the existing report label when republishing
         a Power BI .pbix file. The service default value is ``true``. Default value is None.
        :paramtype override_report_label: bool
        :keyword override_model_label: Whether to override the existing label on a model when
         republishing a Power BI .pbix file. The service default value is ``true``. Default value is
         None.
        :paramtype override_model_label: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                import_info = {
                    "connectionType": "str",  # Optional. The import connection type for a
                      OneDrive for Business file. Known values are: "import" and "connect".
                    "filePath": "str",  # Optional. The path of the OneDrive for Business Excel
                      (.xlsx) file to import, which can be absolute or relative. Power BI .pbix files
                      aren't supported.
                    "fileUrl": "str"  # Optional. The shared access signature URL of the
                      temporary blob storage used to import large Power BI .pbix files between 1 GB and
                      10 GB in size.
                }

                # response body for status code(s): 200, 202
                response == {
                    "id": "str",  # The import ID. Required.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Import creation date
                      and time.
                    "datasets": [
                        {
                            "id": "str",  # The dataset ID. Required.
                            "ContentProviderType": "str",  # Optional. The content
                              provider type for the dataset.
                            "CreateReportEmbedURL": "str",  # Optional. The dataset
                              create report embed URL.
                            "CreatedDate": "2020-02-20 00:00:00",  # Optional. The
                              dataset creation date and time.
                            "Encryption": {
                                "EncryptionStatus": "str"  # Optional. Dataset
                                  encryption status. Known values are: "Unknown", "NotSupported",
                                  "InSyncWithWorkspace", and "NotInSyncWithWorkspace".
                            },
                            "IsEffectiveIdentityRequired": bool,  # Optional. Whether the
                              dataset requires an effective identity, which you must send in a
                              `GenerateToken </rest/api/power-bi/embed-token/generate-token>`_ API
                              call.
                            "IsEffectiveIdentityRolesRequired": bool,  # Optional.
                              Whether row-level security is defined inside the Power BI .pbix file. If
                              so, you must specify a role.
                            "IsInPlaceSharingEnabled": bool,  # Optional. Whether the
                              dataset can be shared with external users to be consumed in their own
                              tenant.
                            "IsOnPremGatewayRequired": bool,  # Optional. Whether the
                              dataset requires an on-premises data gateway.
                            "IsRefreshable": bool,  # Optional. Whether the dataset is
                              refreshable or not. A Power BI refreshable dataset is a dataset that has
                              been refreshed at least once, or for which a valid refresh schedule
                              exists.
                            "QnaEmbedURL": "str",  # Optional. The dataset Q&A embed URL.
                            "addRowsAPIEnabled": bool,  # Optional. Whether the dataset
                              allows adding new rows.
                            "configuredBy": "str",  # Optional. The dataset owner.
                            "description": "str",  # Optional. The dataset description.
                            "name": "str",  # Optional. The dataset name.
                            "queryScaleOutSettings": {
                                "autoSyncReadOnlyReplicas": bool,  # Optional.
                                  Whether the dataset automatically syncs read-only replicas.
                                "maxReadOnlyReplicas": 0  # Optional. Maximum number
                                  of read-only replicas for the dataset (0-64, -1 for automatic number
                                  of replicas).
                            },
                            "targetStorageMode": "str",  # Optional. The dataset storage
                              mode.
                            "upstreamDataflows": [
                                {
                                    "groupId": "str",  # Optional. The target
                                      group ID.
                                    "targetDataflowId": "str"  # Optional. The
                                      target dataflow ID.
                                }
                            ],
                            "users": [
                                {
                                    "datasetUserAccessRight": "str",  # The
                                      access right that the user has for the dataset (permission
                                      level). Required. Known values are: "None", "Read", "ReadWrite",
                                      "ReadReshare", "ReadWriteReshare", "ReadExplore",
                                      "ReadReshareExplore", "ReadWriteExplore", and
                                      "ReadWriteReshareExplore".
                                    "identifier": "str",  # Identifier of the
                                      principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "displayName": "str",  # Optional. Display
                                      name of the principal.
                                    "emailAddress": "str",  # Optional. Email
                                      address of the user.
                                    "graphId": "str",  # Optional. Identifier of
                                      the principal in Microsoft Graph. Only available for admin APIs.
                                    "profile": {
                                        "id": "str",  # The service principal
                                          profile ID. Required.
                                        "displayName": "str"  # Optional. The
                                          service principal profile name.
                                    },
                                    "userType": "str"  # Optional. Type of the
                                      user.
                                }
                            ],
                            "webUrl": "str"  # Optional. The web URL of the dataset.
                        }
                    ],
                    "importState": "str",  # Optional. The import upload state. Known values are:
                      "Publishing", "Succeeded", and "Failed".
                    "name": "str",  # Optional. The import name.
                    "reports": [
                        {
                            "id": "str",  # The report ID. Required.
                            "appId": "str",  # Optional. The app ID, returned only if the
                              report belongs to an app.
                            "datasetId": "str",  # Optional. The dataset ID of the
                              report.
                            "description": "str",  # Optional. The report description.
                            "embedUrl": "str",  # Optional. The embed URL of the report.
                            "name": "str",  # Optional. The name of the report.
                            "reportType": "str",  # Optional. The report type.
                              "PaginatedReport"
                            "subscriptions": [
                                {
                                    "id": "str",  # The subscription ID.
                                      Required.
                                    "artifactDisplayName": "str",  # Optional.
                                      The name of the subscribed Power BI item (such as a report or a
                                      dashboard).
                                    "artifactId": "str",  # Optional. The ID of
                                      the subscribed Power BI item (such as a report or a dashboard).
                                    "artifactType": "str",  # Optional. The type
                                      of Power BI item (for example a ``Report``"" , ``Dashboard``"" ,
                                      or ``Dataset``"" ).
                                    "attachmentFormat": "str",  # Optional.
                                      Format of the report attached in the email subscription.
                                    "endDate": "2020-02-20 00:00:00",  #
                                      Optional. The end date and time of the email subscription.
                                    "frequency": "str",  # Optional. The
                                      frequency of the email subscription.
                                    "isEnabled": bool,  # Optional. Whether the
                                      email subscription is enabled.
                                    "linkToContent": bool,  # Optional. Whether a
                                      subscription link exists in the email subscription.
                                    "previewImage": bool,  # Optional. Whether a
                                      screenshot of the report exists in the email subscription.
                                    "startDate": "2020-02-20 00:00:00",  #
                                      Optional. The start date and time of the email subscription.
                                    "subArtifactDisplayName": "str",  # Optional.
                                      The page name of the subscribed Power BI item, if it's a report.
                                    "title": "str",  # Optional. The app name.
                                    "users": [
                                        {
                                            "identifier": "str",  #
                                              Identifier of the principal. Required.
                                            "principalType": "str",  #
                                              The principal type. Required. Known values are: "None",
                                              "User", "Group", and "App".
                                            "displayName": "str",  #
                                              Optional. Display name of the principal.
                                            "emailAddress": "str",  #
                                              Optional. Email address of the user.
                                            "graphId": "str",  #
                                              Optional. Identifier of the principal in Microsoft Graph.
                                              Only available for admin APIs.
                                            "profile": {
                                                "id": "str",  # The
                                                  service principal profile ID. Required.
                                                "displayName": "str"
                                                  # Optional. The service principal profile name.
                                            },
                                            "userType": "str"  #
                                              Optional. Type of the user.
                                        }
                                    ]
                                }
                            ],
                            "users": [
                                {
                                    "identifier": "str",  # Identifier of the
                                      principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "reportUserAccessRight": "str",  # The access
                                      right that the user has for the report (permission level).
                                      Required. Known values are: "None", "Read", "ReadWrite",
                                      "ReadReshare", "ReadCopy", and "Owner".
                                    "displayName": "str",  # Optional. Display
                                      name of the principal.
                                    "emailAddress": "str",  # Optional. Email
                                      address of the user.
                                    "graphId": "str",  # Optional. Identifier of
                                      the principal in Microsoft Graph. Only available for admin APIs.
                                    "profile": {
                                        "id": "str",  # The service principal
                                          profile ID. Required.
                                        "displayName": "str"  # Optional. The
                                          service principal profile name.
                                    },
                                    "userType": "str"  # Optional. Type of the
                                      user.
                                }
                            ],
                            "webUrl": "str"  # Optional. The web URL of the report.
                        }
                    ],
                    "updatedDateTime": "2020-02-20 00:00:00"  # Optional. Import last update date
                      and time.
                }
        """

    @overload
    async def post_import(
        self,
        import_info: IO,
        *,
        dataset_display_name: str,
        name_conflict: Optional[str] = None,
        skip_report: Optional[bool] = None,
        override_report_label: Optional[bool] = None,
        override_model_label: Optional[bool] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Creates new content in **My workspace**.

        See the `Import Large Files
        <https://github.com/microsoft/PowerBI-Developer-Samples/blob/master/PowerShell%20Scripts/Import%20Large%20Files>`_
        PowerShell script for an example of using this API.

        ..

           [!NOTE]
           Supported content:


           * Power BI .pbix files
           * JSON files (.json)
           * Excel files (.xlsx)
           * RDL files (.rdl)



        * To import a file, specify the content type **multipart/form-data** in the request headers and
        encode the file as `form data <https://www.w3.org/TR/html401/interact/forms.html>`_ in the
        request body.
        * To import an .rdl file, include the file extension in the name specified by
        ``datasetDisplayName``\ , as described in `URI parameters
        </rest/api/power-bi/imports/post-import-in-group#uri-parameters>`_.
        * To import an .xlsx file from OneDrive for Business, include the content type
        **application/json** in the request headers. Include `ImportInfo
        </rest/api/power-bi/imports/post-import-in-group#importinfo>`_ with ``filePath`` set to the
        .xlsx file path in the request body.
        * To import large Power BI .pbix files that are between 1 GB and 10 GB in size, see `Create
        Temporary Upload Location </rest/api/power-bi/imports/create-temporary-upload-location>`_. This
        is only supported for Premium capacity workspaces.
        * To create a dataflow from a model.json file, set ``datasetDisplayName`` to *model.json*\ , as
        described in `URI parameters
        </rest/api/power-bi/imports/post-import-in-group#uri-parameters>`_.

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------


        * Dataflows with service principal aren't supported.
        * Importing a Power BI .pbix file from OneDrive isn't supported.
        * Importing a file that has a **protected** sensitivity label isn't supported for service
        principals.
          :code:`<br>`:code:`<br>`.

        :param import_info: The import to post. Required.
        :type import_info: IO
        :keyword dataset_display_name: The display name of the dataset, should include file extension.
         Not supported when importing from OneDrive for Business. Required.
        :paramtype dataset_display_name: str
        :keyword name_conflict: Specifies what to do if a dataset with the same name already exists.
         The default value is ``Ignore``. For RDL files, ``Abort`` and ``Overwrite`` are the only
         supported options. Known values are: "Ignore", "Abort", "Overwrite", "CreateOrOverwrite", and
         "GenerateUniqueName". Default value is None.
        :paramtype name_conflict: str
        :keyword skip_report: Whether to skip report import. If specified, the value must be ``true``.
         Only supported for Power BI .pbix files. Default value is None.
        :paramtype skip_report: bool
        :keyword override_report_label: Whether to override the existing report label when republishing
         a Power BI .pbix file. The service default value is ``true``. Default value is None.
        :paramtype override_report_label: bool
        :keyword override_model_label: Whether to override the existing label on a model when
         republishing a Power BI .pbix file. The service default value is ``true``. Default value is
         None.
        :paramtype override_model_label: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 202
                response == {
                    "id": "str",  # The import ID. Required.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Import creation date
                      and time.
                    "datasets": [
                        {
                            "id": "str",  # The dataset ID. Required.
                            "ContentProviderType": "str",  # Optional. The content
                              provider type for the dataset.
                            "CreateReportEmbedURL": "str",  # Optional. The dataset
                              create report embed URL.
                            "CreatedDate": "2020-02-20 00:00:00",  # Optional. The
                              dataset creation date and time.
                            "Encryption": {
                                "EncryptionStatus": "str"  # Optional. Dataset
                                  encryption status. Known values are: "Unknown", "NotSupported",
                                  "InSyncWithWorkspace", and "NotInSyncWithWorkspace".
                            },
                            "IsEffectiveIdentityRequired": bool,  # Optional. Whether the
                              dataset requires an effective identity, which you must send in a
                              `GenerateToken </rest/api/power-bi/embed-token/generate-token>`_ API
                              call.
                            "IsEffectiveIdentityRolesRequired": bool,  # Optional.
                              Whether row-level security is defined inside the Power BI .pbix file. If
                              so, you must specify a role.
                            "IsInPlaceSharingEnabled": bool,  # Optional. Whether the
                              dataset can be shared with external users to be consumed in their own
                              tenant.
                            "IsOnPremGatewayRequired": bool,  # Optional. Whether the
                              dataset requires an on-premises data gateway.
                            "IsRefreshable": bool,  # Optional. Whether the dataset is
                              refreshable or not. A Power BI refreshable dataset is a dataset that has
                              been refreshed at least once, or for which a valid refresh schedule
                              exists.
                            "QnaEmbedURL": "str",  # Optional. The dataset Q&A embed URL.
                            "addRowsAPIEnabled": bool,  # Optional. Whether the dataset
                              allows adding new rows.
                            "configuredBy": "str",  # Optional. The dataset owner.
                            "description": "str",  # Optional. The dataset description.
                            "name": "str",  # Optional. The dataset name.
                            "queryScaleOutSettings": {
                                "autoSyncReadOnlyReplicas": bool,  # Optional.
                                  Whether the dataset automatically syncs read-only replicas.
                                "maxReadOnlyReplicas": 0  # Optional. Maximum number
                                  of read-only replicas for the dataset (0-64, -1 for automatic number
                                  of replicas).
                            },
                            "targetStorageMode": "str",  # Optional. The dataset storage
                              mode.
                            "upstreamDataflows": [
                                {
                                    "groupId": "str",  # Optional. The target
                                      group ID.
                                    "targetDataflowId": "str"  # Optional. The
                                      target dataflow ID.
                                }
                            ],
                            "users": [
                                {
                                    "datasetUserAccessRight": "str",  # The
                                      access right that the user has for the dataset (permission
                                      level). Required. Known values are: "None", "Read", "ReadWrite",
                                      "ReadReshare", "ReadWriteReshare", "ReadExplore",
                                      "ReadReshareExplore", "ReadWriteExplore", and
                                      "ReadWriteReshareExplore".
                                    "identifier": "str",  # Identifier of the
                                      principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "displayName": "str",  # Optional. Display
                                      name of the principal.
                                    "emailAddress": "str",  # Optional. Email
                                      address of the user.
                                    "graphId": "str",  # Optional. Identifier of
                                      the principal in Microsoft Graph. Only available for admin APIs.
                                    "profile": {
                                        "id": "str",  # The service principal
                                          profile ID. Required.
                                        "displayName": "str"  # Optional. The
                                          service principal profile name.
                                    },
                                    "userType": "str"  # Optional. Type of the
                                      user.
                                }
                            ],
                            "webUrl": "str"  # Optional. The web URL of the dataset.
                        }
                    ],
                    "importState": "str",  # Optional. The import upload state. Known values are:
                      "Publishing", "Succeeded", and "Failed".
                    "name": "str",  # Optional. The import name.
                    "reports": [
                        {
                            "id": "str",  # The report ID. Required.
                            "appId": "str",  # Optional. The app ID, returned only if the
                              report belongs to an app.
                            "datasetId": "str",  # Optional. The dataset ID of the
                              report.
                            "description": "str",  # Optional. The report description.
                            "embedUrl": "str",  # Optional. The embed URL of the report.
                            "name": "str",  # Optional. The name of the report.
                            "reportType": "str",  # Optional. The report type.
                              "PaginatedReport"
                            "subscriptions": [
                                {
                                    "id": "str",  # The subscription ID.
                                      Required.
                                    "artifactDisplayName": "str",  # Optional.
                                      The name of the subscribed Power BI item (such as a report or a
                                      dashboard).
                                    "artifactId": "str",  # Optional. The ID of
                                      the subscribed Power BI item (such as a report or a dashboard).
                                    "artifactType": "str",  # Optional. The type
                                      of Power BI item (for example a ``Report``"" , ``Dashboard``"" ,
                                      or ``Dataset``"" ).
                                    "attachmentFormat": "str",  # Optional.
                                      Format of the report attached in the email subscription.
                                    "endDate": "2020-02-20 00:00:00",  #
                                      Optional. The end date and time of the email subscription.
                                    "frequency": "str",  # Optional. The
                                      frequency of the email subscription.
                                    "isEnabled": bool,  # Optional. Whether the
                                      email subscription is enabled.
                                    "linkToContent": bool,  # Optional. Whether a
                                      subscription link exists in the email subscription.
                                    "previewImage": bool,  # Optional. Whether a
                                      screenshot of the report exists in the email subscription.
                                    "startDate": "2020-02-20 00:00:00",  #
                                      Optional. The start date and time of the email subscription.
                                    "subArtifactDisplayName": "str",  # Optional.
                                      The page name of the subscribed Power BI item, if it's a report.
                                    "title": "str",  # Optional. The app name.
                                    "users": [
                                        {
                                            "identifier": "str",  #
                                              Identifier of the principal. Required.
                                            "principalType": "str",  #
                                              The principal type. Required. Known values are: "None",
                                              "User", "Group", and "App".
                                            "displayName": "str",  #
                                              Optional. Display name of the principal.
                                            "emailAddress": "str",  #
                                              Optional. Email address of the user.
                                            "graphId": "str",  #
                                              Optional. Identifier of the principal in Microsoft Graph.
                                              Only available for admin APIs.
                                            "profile": {
                                                "id": "str",  # The
                                                  service principal profile ID. Required.
                                                "displayName": "str"
                                                  # Optional. The service principal profile name.
                                            },
                                            "userType": "str"  #
                                              Optional. Type of the user.
                                        }
                                    ]
                                }
                            ],
                            "users": [
                                {
                                    "identifier": "str",  # Identifier of the
                                      principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "reportUserAccessRight": "str",  # The access
                                      right that the user has for the report (permission level).
                                      Required. Known values are: "None", "Read", "ReadWrite",
                                      "ReadReshare", "ReadCopy", and "Owner".
                                    "displayName": "str",  # Optional. Display
                                      name of the principal.
                                    "emailAddress": "str",  # Optional. Email
                                      address of the user.
                                    "graphId": "str",  # Optional. Identifier of
                                      the principal in Microsoft Graph. Only available for admin APIs.
                                    "profile": {
                                        "id": "str",  # The service principal
                                          profile ID. Required.
                                        "displayName": "str"  # Optional. The
                                          service principal profile name.
                                    },
                                    "userType": "str"  # Optional. Type of the
                                      user.
                                }
                            ],
                            "webUrl": "str"  # Optional. The web URL of the report.
                        }
                    ],
                    "updatedDateTime": "2020-02-20 00:00:00"  # Optional. Import last update date
                      and time.
                }
        """

    @distributed_trace_async
    async def post_import(
        self,
        import_info: Union[JSON, IO],
        *,
        dataset_display_name: str,
        name_conflict: Optional[str] = None,
        skip_report: Optional[bool] = None,
        override_report_label: Optional[bool] = None,
        override_model_label: Optional[bool] = None,
        **kwargs: Any
    ) -> JSON:
        """Creates new content in **My workspace**.

        See the `Import Large Files
        <https://github.com/microsoft/PowerBI-Developer-Samples/blob/master/PowerShell%20Scripts/Import%20Large%20Files>`_
        PowerShell script for an example of using this API.

        ..

           [!NOTE]
           Supported content:


           * Power BI .pbix files
           * JSON files (.json)
           * Excel files (.xlsx)
           * RDL files (.rdl)



        * To import a file, specify the content type **multipart/form-data** in the request headers and
        encode the file as `form data <https://www.w3.org/TR/html401/interact/forms.html>`_ in the
        request body.
        * To import an .rdl file, include the file extension in the name specified by
        ``datasetDisplayName``\ , as described in `URI parameters
        </rest/api/power-bi/imports/post-import-in-group#uri-parameters>`_.
        * To import an .xlsx file from OneDrive for Business, include the content type
        **application/json** in the request headers. Include `ImportInfo
        </rest/api/power-bi/imports/post-import-in-group#importinfo>`_ with ``filePath`` set to the
        .xlsx file path in the request body.
        * To import large Power BI .pbix files that are between 1 GB and 10 GB in size, see `Create
        Temporary Upload Location </rest/api/power-bi/imports/create-temporary-upload-location>`_. This
        is only supported for Premium capacity workspaces.
        * To create a dataflow from a model.json file, set ``datasetDisplayName`` to *model.json*\ , as
        described in `URI parameters
        </rest/api/power-bi/imports/post-import-in-group#uri-parameters>`_.

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------


        * Dataflows with service principal aren't supported.
        * Importing a Power BI .pbix file from OneDrive isn't supported.
        * Importing a file that has a **protected** sensitivity label isn't supported for service
        principals.
          :code:`<br>`:code:`<br>`.

        :param import_info: The import to post. Is either a JSON type or a IO type. Required.
        :type import_info: JSON or IO
        :keyword dataset_display_name: The display name of the dataset, should include file extension.
         Not supported when importing from OneDrive for Business. Required.
        :paramtype dataset_display_name: str
        :keyword name_conflict: Specifies what to do if a dataset with the same name already exists.
         The default value is ``Ignore``. For RDL files, ``Abort`` and ``Overwrite`` are the only
         supported options. Known values are: "Ignore", "Abort", "Overwrite", "CreateOrOverwrite", and
         "GenerateUniqueName". Default value is None.
        :paramtype name_conflict: str
        :keyword skip_report: Whether to skip report import. If specified, the value must be ``true``.
         Only supported for Power BI .pbix files. Default value is None.
        :paramtype skip_report: bool
        :keyword override_report_label: Whether to override the existing report label when republishing
         a Power BI .pbix file. The service default value is ``true``. Default value is None.
        :paramtype override_report_label: bool
        :keyword override_model_label: Whether to override the existing label on a model when
         republishing a Power BI .pbix file. The service default value is ``true``. Default value is
         None.
        :paramtype override_model_label: bool
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                import_info = {
                    "connectionType": "str",  # Optional. The import connection type for a
                      OneDrive for Business file. Known values are: "import" and "connect".
                    "filePath": "str",  # Optional. The path of the OneDrive for Business Excel
                      (.xlsx) file to import, which can be absolute or relative. Power BI .pbix files
                      aren't supported.
                    "fileUrl": "str"  # Optional. The shared access signature URL of the
                      temporary blob storage used to import large Power BI .pbix files between 1 GB and
                      10 GB in size.
                }

                # response body for status code(s): 200, 202
                response == {
                    "id": "str",  # The import ID. Required.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Import creation date
                      and time.
                    "datasets": [
                        {
                            "id": "str",  # The dataset ID. Required.
                            "ContentProviderType": "str",  # Optional. The content
                              provider type for the dataset.
                            "CreateReportEmbedURL": "str",  # Optional. The dataset
                              create report embed URL.
                            "CreatedDate": "2020-02-20 00:00:00",  # Optional. The
                              dataset creation date and time.
                            "Encryption": {
                                "EncryptionStatus": "str"  # Optional. Dataset
                                  encryption status. Known values are: "Unknown", "NotSupported",
                                  "InSyncWithWorkspace", and "NotInSyncWithWorkspace".
                            },
                            "IsEffectiveIdentityRequired": bool,  # Optional. Whether the
                              dataset requires an effective identity, which you must send in a
                              `GenerateToken </rest/api/power-bi/embed-token/generate-token>`_ API
                              call.
                            "IsEffectiveIdentityRolesRequired": bool,  # Optional.
                              Whether row-level security is defined inside the Power BI .pbix file. If
                              so, you must specify a role.
                            "IsInPlaceSharingEnabled": bool,  # Optional. Whether the
                              dataset can be shared with external users to be consumed in their own
                              tenant.
                            "IsOnPremGatewayRequired": bool,  # Optional. Whether the
                              dataset requires an on-premises data gateway.
                            "IsRefreshable": bool,  # Optional. Whether the dataset is
                              refreshable or not. A Power BI refreshable dataset is a dataset that has
                              been refreshed at least once, or for which a valid refresh schedule
                              exists.
                            "QnaEmbedURL": "str",  # Optional. The dataset Q&A embed URL.
                            "addRowsAPIEnabled": bool,  # Optional. Whether the dataset
                              allows adding new rows.
                            "configuredBy": "str",  # Optional. The dataset owner.
                            "description": "str",  # Optional. The dataset description.
                            "name": "str",  # Optional. The dataset name.
                            "queryScaleOutSettings": {
                                "autoSyncReadOnlyReplicas": bool,  # Optional.
                                  Whether the dataset automatically syncs read-only replicas.
                                "maxReadOnlyReplicas": 0  # Optional. Maximum number
                                  of read-only replicas for the dataset (0-64, -1 for automatic number
                                  of replicas).
                            },
                            "targetStorageMode": "str",  # Optional. The dataset storage
                              mode.
                            "upstreamDataflows": [
                                {
                                    "groupId": "str",  # Optional. The target
                                      group ID.
                                    "targetDataflowId": "str"  # Optional. The
                                      target dataflow ID.
                                }
                            ],
                            "users": [
                                {
                                    "datasetUserAccessRight": "str",  # The
                                      access right that the user has for the dataset (permission
                                      level). Required. Known values are: "None", "Read", "ReadWrite",
                                      "ReadReshare", "ReadWriteReshare", "ReadExplore",
                                      "ReadReshareExplore", "ReadWriteExplore", and
                                      "ReadWriteReshareExplore".
                                    "identifier": "str",  # Identifier of the
                                      principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "displayName": "str",  # Optional. Display
                                      name of the principal.
                                    "emailAddress": "str",  # Optional. Email
                                      address of the user.
                                    "graphId": "str",  # Optional. Identifier of
                                      the principal in Microsoft Graph. Only available for admin APIs.
                                    "profile": {
                                        "id": "str",  # The service principal
                                          profile ID. Required.
                                        "displayName": "str"  # Optional. The
                                          service principal profile name.
                                    },
                                    "userType": "str"  # Optional. Type of the
                                      user.
                                }
                            ],
                            "webUrl": "str"  # Optional. The web URL of the dataset.
                        }
                    ],
                    "importState": "str",  # Optional. The import upload state. Known values are:
                      "Publishing", "Succeeded", and "Failed".
                    "name": "str",  # Optional. The import name.
                    "reports": [
                        {
                            "id": "str",  # The report ID. Required.
                            "appId": "str",  # Optional. The app ID, returned only if the
                              report belongs to an app.
                            "datasetId": "str",  # Optional. The dataset ID of the
                              report.
                            "description": "str",  # Optional. The report description.
                            "embedUrl": "str",  # Optional. The embed URL of the report.
                            "name": "str",  # Optional. The name of the report.
                            "reportType": "str",  # Optional. The report type.
                              "PaginatedReport"
                            "subscriptions": [
                                {
                                    "id": "str",  # The subscription ID.
                                      Required.
                                    "artifactDisplayName": "str",  # Optional.
                                      The name of the subscribed Power BI item (such as a report or a
                                      dashboard).
                                    "artifactId": "str",  # Optional. The ID of
                                      the subscribed Power BI item (such as a report or a dashboard).
                                    "artifactType": "str",  # Optional. The type
                                      of Power BI item (for example a ``Report``"" , ``Dashboard``"" ,
                                      or ``Dataset``"" ).
                                    "attachmentFormat": "str",  # Optional.
                                      Format of the report attached in the email subscription.
                                    "endDate": "2020-02-20 00:00:00",  #
                                      Optional. The end date and time of the email subscription.
                                    "frequency": "str",  # Optional. The
                                      frequency of the email subscription.
                                    "isEnabled": bool,  # Optional. Whether the
                                      email subscription is enabled.
                                    "linkToContent": bool,  # Optional. Whether a
                                      subscription link exists in the email subscription.
                                    "previewImage": bool,  # Optional. Whether a
                                      screenshot of the report exists in the email subscription.
                                    "startDate": "2020-02-20 00:00:00",  #
                                      Optional. The start date and time of the email subscription.
                                    "subArtifactDisplayName": "str",  # Optional.
                                      The page name of the subscribed Power BI item, if it's a report.
                                    "title": "str",  # Optional. The app name.
                                    "users": [
                                        {
                                            "identifier": "str",  #
                                              Identifier of the principal. Required.
                                            "principalType": "str",  #
                                              The principal type. Required. Known values are: "None",
                                              "User", "Group", and "App".
                                            "displayName": "str",  #
                                              Optional. Display name of the principal.
                                            "emailAddress": "str",  #
                                              Optional. Email address of the user.
                                            "graphId": "str",  #
                                              Optional. Identifier of the principal in Microsoft Graph.
                                              Only available for admin APIs.
                                            "profile": {
                                                "id": "str",  # The
                                                  service principal profile ID. Required.
                                                "displayName": "str"
                                                  # Optional. The service principal profile name.
                                            },
                                            "userType": "str"  #
                                              Optional. Type of the user.
                                        }
                                    ]
                                }
                            ],
                            "users": [
                                {
                                    "identifier": "str",  # Identifier of the
                                      principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "reportUserAccessRight": "str",  # The access
                                      right that the user has for the report (permission level).
                                      Required. Known values are: "None", "Read", "ReadWrite",
                                      "ReadReshare", "ReadCopy", and "Owner".
                                    "displayName": "str",  # Optional. Display
                                      name of the principal.
                                    "emailAddress": "str",  # Optional. Email
                                      address of the user.
                                    "graphId": "str",  # Optional. Identifier of
                                      the principal in Microsoft Graph. Only available for admin APIs.
                                    "profile": {
                                        "id": "str",  # The service principal
                                          profile ID. Required.
                                        "displayName": "str"  # Optional. The
                                          service principal profile name.
                                    },
                                    "userType": "str"  # Optional. Type of the
                                      user.
                                }
                            ],
                            "webUrl": "str"  # Optional. The web URL of the report.
                        }
                    ],
                    "updatedDateTime": "2020-02-20 00:00:00"  # Optional. Import last update date
                      and time.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(import_info, (IOBase, bytes)):
            _content = import_info
        else:
            _json = import_info

        _request = build_imports_post_import_request(
            dataset_display_name=dataset_display_name,
            name_conflict=name_conflict,
            skip_report=skip_report,
            override_report_label=override_report_label,
            override_model_label=override_model_label,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 202:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_import(self, import_id: str, **kwargs: Any) -> JSON:
        """Returns the specified import from **My workspace**.

        Required Scope
        --------------

        Dataset.ReadWrite.All or Dataset.Read.All
        :code:`<br>`:code:`<br>`.

        :param import_id: The import ID. Required.
        :type import_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # The import ID. Required.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Import creation date
                      and time.
                    "datasets": [
                        {
                            "id": "str",  # The dataset ID. Required.
                            "ContentProviderType": "str",  # Optional. The content
                              provider type for the dataset.
                            "CreateReportEmbedURL": "str",  # Optional. The dataset
                              create report embed URL.
                            "CreatedDate": "2020-02-20 00:00:00",  # Optional. The
                              dataset creation date and time.
                            "Encryption": {
                                "EncryptionStatus": "str"  # Optional. Dataset
                                  encryption status. Known values are: "Unknown", "NotSupported",
                                  "InSyncWithWorkspace", and "NotInSyncWithWorkspace".
                            },
                            "IsEffectiveIdentityRequired": bool,  # Optional. Whether the
                              dataset requires an effective identity, which you must send in a
                              `GenerateToken </rest/api/power-bi/embed-token/generate-token>`_ API
                              call.
                            "IsEffectiveIdentityRolesRequired": bool,  # Optional.
                              Whether row-level security is defined inside the Power BI .pbix file. If
                              so, you must specify a role.
                            "IsInPlaceSharingEnabled": bool,  # Optional. Whether the
                              dataset can be shared with external users to be consumed in their own
                              tenant.
                            "IsOnPremGatewayRequired": bool,  # Optional. Whether the
                              dataset requires an on-premises data gateway.
                            "IsRefreshable": bool,  # Optional. Whether the dataset is
                              refreshable or not. A Power BI refreshable dataset is a dataset that has
                              been refreshed at least once, or for which a valid refresh schedule
                              exists.
                            "QnaEmbedURL": "str",  # Optional. The dataset Q&A embed URL.
                            "addRowsAPIEnabled": bool,  # Optional. Whether the dataset
                              allows adding new rows.
                            "configuredBy": "str",  # Optional. The dataset owner.
                            "description": "str",  # Optional. The dataset description.
                            "name": "str",  # Optional. The dataset name.
                            "queryScaleOutSettings": {
                                "autoSyncReadOnlyReplicas": bool,  # Optional.
                                  Whether the dataset automatically syncs read-only replicas.
                                "maxReadOnlyReplicas": 0  # Optional. Maximum number
                                  of read-only replicas for the dataset (0-64, -1 for automatic number
                                  of replicas).
                            },
                            "targetStorageMode": "str",  # Optional. The dataset storage
                              mode.
                            "upstreamDataflows": [
                                {
                                    "groupId": "str",  # Optional. The target
                                      group ID.
                                    "targetDataflowId": "str"  # Optional. The
                                      target dataflow ID.
                                }
                            ],
                            "users": [
                                {
                                    "datasetUserAccessRight": "str",  # The
                                      access right that the user has for the dataset (permission
                                      level). Required. Known values are: "None", "Read", "ReadWrite",
                                      "ReadReshare", "ReadWriteReshare", "ReadExplore",
                                      "ReadReshareExplore", "ReadWriteExplore", and
                                      "ReadWriteReshareExplore".
                                    "identifier": "str",  # Identifier of the
                                      principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "displayName": "str",  # Optional. Display
                                      name of the principal.
                                    "emailAddress": "str",  # Optional. Email
                                      address of the user.
                                    "graphId": "str",  # Optional. Identifier of
                                      the principal in Microsoft Graph. Only available for admin APIs.
                                    "profile": {
                                        "id": "str",  # The service principal
                                          profile ID. Required.
                                        "displayName": "str"  # Optional. The
                                          service principal profile name.
                                    },
                                    "userType": "str"  # Optional. Type of the
                                      user.
                                }
                            ],
                            "webUrl": "str"  # Optional. The web URL of the dataset.
                        }
                    ],
                    "importState": "str",  # Optional. The import upload state. Known values are:
                      "Publishing", "Succeeded", and "Failed".
                    "name": "str",  # Optional. The import name.
                    "reports": [
                        {
                            "id": "str",  # The report ID. Required.
                            "appId": "str",  # Optional. The app ID, returned only if the
                              report belongs to an app.
                            "datasetId": "str",  # Optional. The dataset ID of the
                              report.
                            "description": "str",  # Optional. The report description.
                            "embedUrl": "str",  # Optional. The embed URL of the report.
                            "name": "str",  # Optional. The name of the report.
                            "reportType": "str",  # Optional. The report type.
                              "PaginatedReport"
                            "subscriptions": [
                                {
                                    "id": "str",  # The subscription ID.
                                      Required.
                                    "artifactDisplayName": "str",  # Optional.
                                      The name of the subscribed Power BI item (such as a report or a
                                      dashboard).
                                    "artifactId": "str",  # Optional. The ID of
                                      the subscribed Power BI item (such as a report or a dashboard).
                                    "artifactType": "str",  # Optional. The type
                                      of Power BI item (for example a ``Report``"" , ``Dashboard``"" ,
                                      or ``Dataset``"" ).
                                    "attachmentFormat": "str",  # Optional.
                                      Format of the report attached in the email subscription.
                                    "endDate": "2020-02-20 00:00:00",  #
                                      Optional. The end date and time of the email subscription.
                                    "frequency": "str",  # Optional. The
                                      frequency of the email subscription.
                                    "isEnabled": bool,  # Optional. Whether the
                                      email subscription is enabled.
                                    "linkToContent": bool,  # Optional. Whether a
                                      subscription link exists in the email subscription.
                                    "previewImage": bool,  # Optional. Whether a
                                      screenshot of the report exists in the email subscription.
                                    "startDate": "2020-02-20 00:00:00",  #
                                      Optional. The start date and time of the email subscription.
                                    "subArtifactDisplayName": "str",  # Optional.
                                      The page name of the subscribed Power BI item, if it's a report.
                                    "title": "str",  # Optional. The app name.
                                    "users": [
                                        {
                                            "identifier": "str",  #
                                              Identifier of the principal. Required.
                                            "principalType": "str",  #
                                              The principal type. Required. Known values are: "None",
                                              "User", "Group", and "App".
                                            "displayName": "str",  #
                                              Optional. Display name of the principal.
                                            "emailAddress": "str",  #
                                              Optional. Email address of the user.
                                            "graphId": "str",  #
                                              Optional. Identifier of the principal in Microsoft Graph.
                                              Only available for admin APIs.
                                            "profile": {
                                                "id": "str",  # The
                                                  service principal profile ID. Required.
                                                "displayName": "str"
                                                  # Optional. The service principal profile name.
                                            },
                                            "userType": "str"  #
                                              Optional. Type of the user.
                                        }
                                    ]
                                }
                            ],
                            "users": [
                                {
                                    "identifier": "str",  # Identifier of the
                                      principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "reportUserAccessRight": "str",  # The access
                                      right that the user has for the report (permission level).
                                      Required. Known values are: "None", "Read", "ReadWrite",
                                      "ReadReshare", "ReadCopy", and "Owner".
                                    "displayName": "str",  # Optional. Display
                                      name of the principal.
                                    "emailAddress": "str",  # Optional. Email
                                      address of the user.
                                    "graphId": "str",  # Optional. Identifier of
                                      the principal in Microsoft Graph. Only available for admin APIs.
                                    "profile": {
                                        "id": "str",  # The service principal
                                          profile ID. Required.
                                        "displayName": "str"  # Optional. The
                                          service principal profile name.
                                    },
                                    "userType": "str"  # Optional. Type of the
                                      user.
                                }
                            ],
                            "webUrl": "str"  # Optional. The web URL of the report.
                        }
                    ],
                    "updatedDateTime": "2020-02-20 00:00:00"  # Optional. Import last update date
                      and time.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_imports_get_import_request(
            import_id=import_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def create_temporary_upload_location(self, **kwargs: Any) -> JSON:
        """Creates a temporary blob storage upload location for importing large Power BI .pbix files that
        are between 1 GB and 10 GB in size.

        To import large Power BI .pbix files:


        #. Create a temporary upload location using this API call.
        #. Upload the Power BI .pbix files using the *shared access signature* URL from the API call
        response.
        #. Call `Post Import In Group </rest/api/power-bi/imports/post-import>`_\ , specifying the
        *shared access signature* URL in the ``fileUrl`` parameter of the `request body
        </rest/api/power-bi/imports/post-import#request-body>`_.

        See the `Import Large Files
        <https://github.com/microsoft/PowerBI-Developer-Samples/blob/master/PowerShell%20Scripts/Import%20Large%20Files>`_
        PowerShell script for an example of using this API.

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------

        Importing large Power BI .pbix files between 1 GB and 10 GB in size is only available for
        Premium capacity workspaces.
        :code:`<br>`:code:`<br>`.

        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "ExpirationTime": "2020-02-20 00:00:00",  # The expiration date and time of
                      the shared access signature URL. Required.
                    "Url": "str"  # The shared access signature URL for the temporary blob
                      storage. Required.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_imports_create_temporary_upload_location_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_imports_in_group(self, group_id: str, **kwargs: Any) -> JSON:
        """Returns a list of imports from the specified workspace.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Dataset.ReadWrite.All or Dataset.Read.All

        Limitations
        -----------

        Importing Power BI .pbix files from OneDrive isn't supported.
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional. OData context.
                    "value": [
                        {
                            "id": "str",  # The import ID. Required.
                            "createdDateTime": "2020-02-20 00:00:00",  # Optional. Import
                              creation date and time.
                            "datasets": [
                                {
                                    "id": "str",  # The dataset ID. Required.
                                    "ContentProviderType": "str",  # Optional.
                                      The content provider type for the dataset.
                                    "CreateReportEmbedURL": "str",  # Optional.
                                      The dataset create report embed URL.
                                    "CreatedDate": "2020-02-20 00:00:00",  #
                                      Optional. The dataset creation date and time.
                                    "Encryption": {
                                        "EncryptionStatus": "str"  #
                                          Optional. Dataset encryption status. Known values are:
                                          "Unknown", "NotSupported", "InSyncWithWorkspace", and
                                          "NotInSyncWithWorkspace".
                                    },
                                    "IsEffectiveIdentityRequired": bool,  #
                                      Optional. Whether the dataset requires an effective identity,
                                      which you must send in a `GenerateToken
                                      </rest/api/power-bi/embed-token/generate-token>`_ API call.
                                    "IsEffectiveIdentityRolesRequired": bool,  #
                                      Optional. Whether row-level security is defined inside the Power
                                      BI .pbix file. If so, you must specify a role.
                                    "IsInPlaceSharingEnabled": bool,  # Optional.
                                      Whether the dataset can be shared with external users to be
                                      consumed in their own tenant.
                                    "IsOnPremGatewayRequired": bool,  # Optional.
                                      Whether the dataset requires an on-premises data gateway.
                                    "IsRefreshable": bool,  # Optional. Whether
                                      the dataset is refreshable or not. A Power BI refreshable dataset
                                      is a dataset that has been refreshed at least once, or for which
                                      a valid refresh schedule exists.
                                    "QnaEmbedURL": "str",  # Optional. The
                                      dataset Q&A embed URL.
                                    "addRowsAPIEnabled": bool,  # Optional.
                                      Whether the dataset allows adding new rows.
                                    "configuredBy": "str",  # Optional. The
                                      dataset owner.
                                    "description": "str",  # Optional. The
                                      dataset description.
                                    "name": "str",  # Optional. The dataset name.
                                    "queryScaleOutSettings": {
                                        "autoSyncReadOnlyReplicas": bool,  #
                                          Optional. Whether the dataset automatically syncs read-only
                                          replicas.
                                        "maxReadOnlyReplicas": 0  # Optional.
                                          Maximum number of read-only replicas for the dataset (0-64,
                                          -1 for automatic number of replicas).
                                    },
                                    "targetStorageMode": "str",  # Optional. The
                                      dataset storage mode.
                                    "upstreamDataflows": [
                                        {
                                            "groupId": "str",  #
                                              Optional. The target group ID.
                                            "targetDataflowId": "str"  #
                                              Optional. The target dataflow ID.
                                        }
                                    ],
                                    "users": [
                                        {
                                            "datasetUserAccessRight":
                                              "str",  # The access right that the user has for the
                                              dataset (permission level). Required. Known values are:
                                              "None", "Read", "ReadWrite", "ReadReshare",
                                              "ReadWriteReshare", "ReadExplore", "ReadReshareExplore",
                                              "ReadWriteExplore", and "ReadWriteReshareExplore".
                                            "identifier": "str",  #
                                              Identifier of the principal. Required.
                                            "principalType": "str",  #
                                              The principal type. Required. Known values are: "None",
                                              "User", "Group", and "App".
                                            "displayName": "str",  #
                                              Optional. Display name of the principal.
                                            "emailAddress": "str",  #
                                              Optional. Email address of the user.
                                            "graphId": "str",  #
                                              Optional. Identifier of the principal in Microsoft Graph.
                                              Only available for admin APIs.
                                            "profile": {
                                                "id": "str",  # The
                                                  service principal profile ID. Required.
                                                "displayName": "str"
                                                  # Optional. The service principal profile name.
                                            },
                                            "userType": "str"  #
                                              Optional. Type of the user.
                                        }
                                    ],
                                    "webUrl": "str"  # Optional. The web URL of
                                      the dataset.
                                }
                            ],
                            "importState": "str",  # Optional. The import upload state.
                              Known values are: "Publishing", "Succeeded", and "Failed".
                            "name": "str",  # Optional. The import name.
                            "reports": [
                                {
                                    "id": "str",  # The report ID. Required.
                                    "appId": "str",  # Optional. The app ID,
                                      returned only if the report belongs to an app.
                                    "datasetId": "str",  # Optional. The dataset
                                      ID of the report.
                                    "description": "str",  # Optional. The report
                                      description.
                                    "embedUrl": "str",  # Optional. The embed URL
                                      of the report.
                                    "name": "str",  # Optional. The name of the
                                      report.
                                    "reportType": "str",  # Optional. The report
                                      type. "PaginatedReport"
                                    "subscriptions": [
                                        {
                                            "id": "str",  # The
                                              subscription ID. Required.
                                            "artifactDisplayName": "str",
                                              # Optional. The name of the subscribed Power BI item
                                              (such as a report or a dashboard).
                                            "artifactId": "str",  #
                                              Optional. The ID of the subscribed Power BI item (such as
                                              a report or a dashboard).
                                            "artifactType": "str",  #
                                              Optional. The type of Power BI item (for example a
                                              ``Report``"" , ``Dashboard``"" , or ``Dataset``"" ).
                                            "attachmentFormat": "str",  #
                                              Optional. Format of the report attached in the email
                                              subscription.
                                            "endDate": "2020-02-20
                                              00:00:00",  # Optional. The end date and time of the
                                              email subscription.
                                            "frequency": "str",  #
                                              Optional. The frequency of the email subscription.
                                            "isEnabled": bool,  #
                                              Optional. Whether the email subscription is enabled.
                                            "linkToContent": bool,  #
                                              Optional. Whether a subscription link exists in the email
                                              subscription.
                                            "previewImage": bool,  #
                                              Optional. Whether a screenshot of the report exists in
                                              the email subscription.
                                            "startDate": "2020-02-20
                                              00:00:00",  # Optional. The start date and time of the
                                              email subscription.
                                            "subArtifactDisplayName":
                                              "str",  # Optional. The page name of the subscribed Power
                                              BI item, if it's a report.
                                            "title": "str",  # Optional.
                                              The app name.
                                            "users": [
                                                {
                                                    "identifier":
                                                      "str",  # Identifier of the principal. Required.
                "principalType": "str",  # The principal type.
                                                      Required. Known values are: "None", "User",
                                                      "Group", and "App".
                "displayName": "str",  # Optional. Display name
                                                      of the principal.
                "emailAddress": "str",  # Optional. Email address
                                                      of the user.
                                                    "graphId":
                                                      "str",  # Optional. Identifier of the principal
                                                      in Microsoft Graph. Only available for admin
                                                      APIs.
                                                    "profile": {
                                                        "id":
                                                          "str",  # The service principal profile ID.
                                                          Required.
                "displayName": "str"  # Optional. The service
                                                          principal profile name.
                                                    },
                                                    "userType":
                                                      "str"  # Optional. Type of the user.
                                                }
                                            ]
                                        }
                                    ],
                                    "users": [
                                        {
                                            "identifier": "str",  #
                                              Identifier of the principal. Required.
                                            "principalType": "str",  #
                                              The principal type. Required. Known values are: "None",
                                              "User", "Group", and "App".
                                            "reportUserAccessRight":
                                              "str",  # The access right that the user has for the
                                              report (permission level). Required. Known values are:
                                              "None", "Read", "ReadWrite", "ReadReshare", "ReadCopy",
                                              and "Owner".
                                            "displayName": "str",  #
                                              Optional. Display name of the principal.
                                            "emailAddress": "str",  #
                                              Optional. Email address of the user.
                                            "graphId": "str",  #
                                              Optional. Identifier of the principal in Microsoft Graph.
                                              Only available for admin APIs.
                                            "profile": {
                                                "id": "str",  # The
                                                  service principal profile ID. Required.
                                                "displayName": "str"
                                                  # Optional. The service principal profile name.
                                            },
                                            "userType": "str"  #
                                              Optional. Type of the user.
                                        }
                                    ],
                                    "webUrl": "str"  # Optional. The web URL of
                                      the report.
                                }
                            ],
                            "updatedDateTime": "2020-02-20 00:00:00"  # Optional. Import
                              last update date and time.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_imports_get_imports_in_group_request(
            group_id=group_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def post_import_in_group(
        self,
        group_id: str,
        import_info: JSON,
        *,
        dataset_display_name: str,
        name_conflict: Optional[str] = None,
        skip_report: Optional[bool] = None,
        override_report_label: Optional[bool] = None,
        override_model_label: Optional[bool] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Creates new content in the specified workspace.

        ..

           [!NOTE]
           Supported content:


           * Power BI .pbix files
           * JSON files (.json)
           * Excel files (.xlsx)
           * SQL Server Report Definition Language files (.rdl)



        * To import a file, specify the content type **multipart/form-data** in the request headers and
        encode the file as `form data <https://www.w3.org/TR/html401/interact/forms.html>`_ in the
        request body.
        * To import an .rdl file, include the file extension in the name specified by
        ``datasetDisplayName``\ , as described in `URI parameters
        </rest/api/power-bi/imports/post-import-in-group#uri-parameters>`_.
        * To import an .xlsx file from OneDrive for Business, include the content type
        **application/json** in the request headers. Include `ImportInfo
        </rest/api/power-bi/imports/post-import-in-group#importinfo>`_ with ``filePath`` set to the
        .xlsx file path in the request body.
        * To import large Power BI .pbix files that are between 1 GB and 10 GB in size, see `Create
        Temporary Upload Location In Group
        </rest/api/power-bi/imports/create-temporary-upload-location-in-group>`_ and the `Import Large
        Files
        <https://github.com/microsoft/PowerBI-Developer-Samples/blob/master/PowerShell%20Scripts/Import%20Large%20Files>`_
        PowerShell script. This is only supported for Premium capacity workspaces.
        * To create a dataflow from a model.json file, set ``datasetDisplayName`` to *model.json*\ , as
        described in `URI parameters
        </rest/api/power-bi/imports/post-import-in-group#uri-parameters>`_.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------


        * Dataflows with service principal aren't supported.
        * Importing a Power BI .pbix file from OneDrive isn't supported.
        * Importing a file that has a **protected** sensitivity label isn't supported for service
        principals.
          :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param import_info: The import to post. Required.
        :type import_info: JSON
        :keyword dataset_display_name: The display name of the dataset should include file extension.
         Not supported when importing from OneDrive for Business. For importing or creating dataflows,
         this parameter should be hardcoded to model.json. Required.
        :paramtype dataset_display_name: str
        :keyword name_conflict: Specifies what to do if a dataset with the same name already exists.
         The default value is ``Ignore``. For RDL files, ``Abort`` and ``Overwrite`` are the only
         supported options. For dataflow model.json files, ``Abort`` and ``GenerateUniqueName`` are the
         only supported options. Known values are: "Ignore", "Abort", "Overwrite", "CreateOrOverwrite",
         and "GenerateUniqueName". Default value is None.
        :paramtype name_conflict: str
        :keyword skip_report: Whether to skip report import. If specified, the value must be ``true``.
         Only supported for Power BI .pbix files. Default value is None.
        :paramtype skip_report: bool
        :keyword override_report_label: Whether to override the existing label on a report when
         republishing a Power BI .pbix file. The service default value is ``true``. Default value is
         None.
        :paramtype override_report_label: bool
        :keyword override_model_label: Determines whether to override the existing label on a model
         when republishing a Power BI .pbix file. The service default value is ``true``. Default value
         is None.
        :paramtype override_model_label: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                import_info = {
                    "connectionType": "str",  # Optional. The import connection type for a
                      OneDrive for Business file. Known values are: "import" and "connect".
                    "filePath": "str",  # Optional. The path of the OneDrive for Business Excel
                      (.xlsx) file to import, which can be absolute or relative. Power BI .pbix files
                      aren't supported.
                    "fileUrl": "str"  # Optional. The shared access signature URL of the
                      temporary blob storage used to import large Power BI .pbix files between 1 GB and
                      10 GB in size.
                }

                # response body for status code(s): 200, 202
                response == {
                    "id": "str",  # The import ID. Required.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Import creation date
                      and time.
                    "datasets": [
                        {
                            "id": "str",  # The dataset ID. Required.
                            "ContentProviderType": "str",  # Optional. The content
                              provider type for the dataset.
                            "CreateReportEmbedURL": "str",  # Optional. The dataset
                              create report embed URL.
                            "CreatedDate": "2020-02-20 00:00:00",  # Optional. The
                              dataset creation date and time.
                            "Encryption": {
                                "EncryptionStatus": "str"  # Optional. Dataset
                                  encryption status. Known values are: "Unknown", "NotSupported",
                                  "InSyncWithWorkspace", and "NotInSyncWithWorkspace".
                            },
                            "IsEffectiveIdentityRequired": bool,  # Optional. Whether the
                              dataset requires an effective identity, which you must send in a
                              `GenerateToken </rest/api/power-bi/embed-token/generate-token>`_ API
                              call.
                            "IsEffectiveIdentityRolesRequired": bool,  # Optional.
                              Whether row-level security is defined inside the Power BI .pbix file. If
                              so, you must specify a role.
                            "IsInPlaceSharingEnabled": bool,  # Optional. Whether the
                              dataset can be shared with external users to be consumed in their own
                              tenant.
                            "IsOnPremGatewayRequired": bool,  # Optional. Whether the
                              dataset requires an on-premises data gateway.
                            "IsRefreshable": bool,  # Optional. Whether the dataset is
                              refreshable or not. A Power BI refreshable dataset is a dataset that has
                              been refreshed at least once, or for which a valid refresh schedule
                              exists.
                            "QnaEmbedURL": "str",  # Optional. The dataset Q&A embed URL.
                            "addRowsAPIEnabled": bool,  # Optional. Whether the dataset
                              allows adding new rows.
                            "configuredBy": "str",  # Optional. The dataset owner.
                            "description": "str",  # Optional. The dataset description.
                            "name": "str",  # Optional. The dataset name.
                            "queryScaleOutSettings": {
                                "autoSyncReadOnlyReplicas": bool,  # Optional.
                                  Whether the dataset automatically syncs read-only replicas.
                                "maxReadOnlyReplicas": 0  # Optional. Maximum number
                                  of read-only replicas for the dataset (0-64, -1 for automatic number
                                  of replicas).
                            },
                            "targetStorageMode": "str",  # Optional. The dataset storage
                              mode.
                            "upstreamDataflows": [
                                {
                                    "groupId": "str",  # Optional. The target
                                      group ID.
                                    "targetDataflowId": "str"  # Optional. The
                                      target dataflow ID.
                                }
                            ],
                            "users": [
                                {
                                    "datasetUserAccessRight": "str",  # The
                                      access right that the user has for the dataset (permission
                                      level). Required. Known values are: "None", "Read", "ReadWrite",
                                      "ReadReshare", "ReadWriteReshare", "ReadExplore",
                                      "ReadReshareExplore", "ReadWriteExplore", and
                                      "ReadWriteReshareExplore".
                                    "identifier": "str",  # Identifier of the
                                      principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "displayName": "str",  # Optional. Display
                                      name of the principal.
                                    "emailAddress": "str",  # Optional. Email
                                      address of the user.
                                    "graphId": "str",  # Optional. Identifier of
                                      the principal in Microsoft Graph. Only available for admin APIs.
                                    "profile": {
                                        "id": "str",  # The service principal
                                          profile ID. Required.
                                        "displayName": "str"  # Optional. The
                                          service principal profile name.
                                    },
                                    "userType": "str"  # Optional. Type of the
                                      user.
                                }
                            ],
                            "webUrl": "str"  # Optional. The web URL of the dataset.
                        }
                    ],
                    "importState": "str",  # Optional. The import upload state. Known values are:
                      "Publishing", "Succeeded", and "Failed".
                    "name": "str",  # Optional. The import name.
                    "reports": [
                        {
                            "id": "str",  # The report ID. Required.
                            "appId": "str",  # Optional. The app ID, returned only if the
                              report belongs to an app.
                            "datasetId": "str",  # Optional. The dataset ID of the
                              report.
                            "description": "str",  # Optional. The report description.
                            "embedUrl": "str",  # Optional. The embed URL of the report.
                            "name": "str",  # Optional. The name of the report.
                            "reportType": "str",  # Optional. The report type.
                              "PaginatedReport"
                            "subscriptions": [
                                {
                                    "id": "str",  # The subscription ID.
                                      Required.
                                    "artifactDisplayName": "str",  # Optional.
                                      The name of the subscribed Power BI item (such as a report or a
                                      dashboard).
                                    "artifactId": "str",  # Optional. The ID of
                                      the subscribed Power BI item (such as a report or a dashboard).
                                    "artifactType": "str",  # Optional. The type
                                      of Power BI item (for example a ``Report``"" , ``Dashboard``"" ,
                                      or ``Dataset``"" ).
                                    "attachmentFormat": "str",  # Optional.
                                      Format of the report attached in the email subscription.
                                    "endDate": "2020-02-20 00:00:00",  #
                                      Optional. The end date and time of the email subscription.
                                    "frequency": "str",  # Optional. The
                                      frequency of the email subscription.
                                    "isEnabled": bool,  # Optional. Whether the
                                      email subscription is enabled.
                                    "linkToContent": bool,  # Optional. Whether a
                                      subscription link exists in the email subscription.
                                    "previewImage": bool,  # Optional. Whether a
                                      screenshot of the report exists in the email subscription.
                                    "startDate": "2020-02-20 00:00:00",  #
                                      Optional. The start date and time of the email subscription.
                                    "subArtifactDisplayName": "str",  # Optional.
                                      The page name of the subscribed Power BI item, if it's a report.
                                    "title": "str",  # Optional. The app name.
                                    "users": [
                                        {
                                            "identifier": "str",  #
                                              Identifier of the principal. Required.
                                            "principalType": "str",  #
                                              The principal type. Required. Known values are: "None",
                                              "User", "Group", and "App".
                                            "displayName": "str",  #
                                              Optional. Display name of the principal.
                                            "emailAddress": "str",  #
                                              Optional. Email address of the user.
                                            "graphId": "str",  #
                                              Optional. Identifier of the principal in Microsoft Graph.
                                              Only available for admin APIs.
                                            "profile": {
                                                "id": "str",  # The
                                                  service principal profile ID. Required.
                                                "displayName": "str"
                                                  # Optional. The service principal profile name.
                                            },
                                            "userType": "str"  #
                                              Optional. Type of the user.
                                        }
                                    ]
                                }
                            ],
                            "users": [
                                {
                                    "identifier": "str",  # Identifier of the
                                      principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "reportUserAccessRight": "str",  # The access
                                      right that the user has for the report (permission level).
                                      Required. Known values are: "None", "Read", "ReadWrite",
                                      "ReadReshare", "ReadCopy", and "Owner".
                                    "displayName": "str",  # Optional. Display
                                      name of the principal.
                                    "emailAddress": "str",  # Optional. Email
                                      address of the user.
                                    "graphId": "str",  # Optional. Identifier of
                                      the principal in Microsoft Graph. Only available for admin APIs.
                                    "profile": {
                                        "id": "str",  # The service principal
                                          profile ID. Required.
                                        "displayName": "str"  # Optional. The
                                          service principal profile name.
                                    },
                                    "userType": "str"  # Optional. Type of the
                                      user.
                                }
                            ],
                            "webUrl": "str"  # Optional. The web URL of the report.
                        }
                    ],
                    "updatedDateTime": "2020-02-20 00:00:00"  # Optional. Import last update date
                      and time.
                }
        """

    @overload
    async def post_import_in_group(
        self,
        group_id: str,
        import_info: IO,
        *,
        dataset_display_name: str,
        name_conflict: Optional[str] = None,
        skip_report: Optional[bool] = None,
        override_report_label: Optional[bool] = None,
        override_model_label: Optional[bool] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Creates new content in the specified workspace.

        ..

           [!NOTE]
           Supported content:


           * Power BI .pbix files
           * JSON files (.json)
           * Excel files (.xlsx)
           * SQL Server Report Definition Language files (.rdl)



        * To import a file, specify the content type **multipart/form-data** in the request headers and
        encode the file as `form data <https://www.w3.org/TR/html401/interact/forms.html>`_ in the
        request body.
        * To import an .rdl file, include the file extension in the name specified by
        ``datasetDisplayName``\ , as described in `URI parameters
        </rest/api/power-bi/imports/post-import-in-group#uri-parameters>`_.
        * To import an .xlsx file from OneDrive for Business, include the content type
        **application/json** in the request headers. Include `ImportInfo
        </rest/api/power-bi/imports/post-import-in-group#importinfo>`_ with ``filePath`` set to the
        .xlsx file path in the request body.
        * To import large Power BI .pbix files that are between 1 GB and 10 GB in size, see `Create
        Temporary Upload Location In Group
        </rest/api/power-bi/imports/create-temporary-upload-location-in-group>`_ and the `Import Large
        Files
        <https://github.com/microsoft/PowerBI-Developer-Samples/blob/master/PowerShell%20Scripts/Import%20Large%20Files>`_
        PowerShell script. This is only supported for Premium capacity workspaces.
        * To create a dataflow from a model.json file, set ``datasetDisplayName`` to *model.json*\ , as
        described in `URI parameters
        </rest/api/power-bi/imports/post-import-in-group#uri-parameters>`_.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------


        * Dataflows with service principal aren't supported.
        * Importing a Power BI .pbix file from OneDrive isn't supported.
        * Importing a file that has a **protected** sensitivity label isn't supported for service
        principals.
          :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param import_info: The import to post. Required.
        :type import_info: IO
        :keyword dataset_display_name: The display name of the dataset should include file extension.
         Not supported when importing from OneDrive for Business. For importing or creating dataflows,
         this parameter should be hardcoded to model.json. Required.
        :paramtype dataset_display_name: str
        :keyword name_conflict: Specifies what to do if a dataset with the same name already exists.
         The default value is ``Ignore``. For RDL files, ``Abort`` and ``Overwrite`` are the only
         supported options. For dataflow model.json files, ``Abort`` and ``GenerateUniqueName`` are the
         only supported options. Known values are: "Ignore", "Abort", "Overwrite", "CreateOrOverwrite",
         and "GenerateUniqueName". Default value is None.
        :paramtype name_conflict: str
        :keyword skip_report: Whether to skip report import. If specified, the value must be ``true``.
         Only supported for Power BI .pbix files. Default value is None.
        :paramtype skip_report: bool
        :keyword override_report_label: Whether to override the existing label on a report when
         republishing a Power BI .pbix file. The service default value is ``true``. Default value is
         None.
        :paramtype override_report_label: bool
        :keyword override_model_label: Determines whether to override the existing label on a model
         when republishing a Power BI .pbix file. The service default value is ``true``. Default value
         is None.
        :paramtype override_model_label: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 202
                response == {
                    "id": "str",  # The import ID. Required.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Import creation date
                      and time.
                    "datasets": [
                        {
                            "id": "str",  # The dataset ID. Required.
                            "ContentProviderType": "str",  # Optional. The content
                              provider type for the dataset.
                            "CreateReportEmbedURL": "str",  # Optional. The dataset
                              create report embed URL.
                            "CreatedDate": "2020-02-20 00:00:00",  # Optional. The
                              dataset creation date and time.
                            "Encryption": {
                                "EncryptionStatus": "str"  # Optional. Dataset
                                  encryption status. Known values are: "Unknown", "NotSupported",
                                  "InSyncWithWorkspace", and "NotInSyncWithWorkspace".
                            },
                            "IsEffectiveIdentityRequired": bool,  # Optional. Whether the
                              dataset requires an effective identity, which you must send in a
                              `GenerateToken </rest/api/power-bi/embed-token/generate-token>`_ API
                              call.
                            "IsEffectiveIdentityRolesRequired": bool,  # Optional.
                              Whether row-level security is defined inside the Power BI .pbix file. If
                              so, you must specify a role.
                            "IsInPlaceSharingEnabled": bool,  # Optional. Whether the
                              dataset can be shared with external users to be consumed in their own
                              tenant.
                            "IsOnPremGatewayRequired": bool,  # Optional. Whether the
                              dataset requires an on-premises data gateway.
                            "IsRefreshable": bool,  # Optional. Whether the dataset is
                              refreshable or not. A Power BI refreshable dataset is a dataset that has
                              been refreshed at least once, or for which a valid refresh schedule
                              exists.
                            "QnaEmbedURL": "str",  # Optional. The dataset Q&A embed URL.
                            "addRowsAPIEnabled": bool,  # Optional. Whether the dataset
                              allows adding new rows.
                            "configuredBy": "str",  # Optional. The dataset owner.
                            "description": "str",  # Optional. The dataset description.
                            "name": "str",  # Optional. The dataset name.
                            "queryScaleOutSettings": {
                                "autoSyncReadOnlyReplicas": bool,  # Optional.
                                  Whether the dataset automatically syncs read-only replicas.
                                "maxReadOnlyReplicas": 0  # Optional. Maximum number
                                  of read-only replicas for the dataset (0-64, -1 for automatic number
                                  of replicas).
                            },
                            "targetStorageMode": "str",  # Optional. The dataset storage
                              mode.
                            "upstreamDataflows": [
                                {
                                    "groupId": "str",  # Optional. The target
                                      group ID.
                                    "targetDataflowId": "str"  # Optional. The
                                      target dataflow ID.
                                }
                            ],
                            "users": [
                                {
                                    "datasetUserAccessRight": "str",  # The
                                      access right that the user has for the dataset (permission
                                      level). Required. Known values are: "None", "Read", "ReadWrite",
                                      "ReadReshare", "ReadWriteReshare", "ReadExplore",
                                      "ReadReshareExplore", "ReadWriteExplore", and
                                      "ReadWriteReshareExplore".
                                    "identifier": "str",  # Identifier of the
                                      principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "displayName": "str",  # Optional. Display
                                      name of the principal.
                                    "emailAddress": "str",  # Optional. Email
                                      address of the user.
                                    "graphId": "str",  # Optional. Identifier of
                                      the principal in Microsoft Graph. Only available for admin APIs.
                                    "profile": {
                                        "id": "str",  # The service principal
                                          profile ID. Required.
                                        "displayName": "str"  # Optional. The
                                          service principal profile name.
                                    },
                                    "userType": "str"  # Optional. Type of the
                                      user.
                                }
                            ],
                            "webUrl": "str"  # Optional. The web URL of the dataset.
                        }
                    ],
                    "importState": "str",  # Optional. The import upload state. Known values are:
                      "Publishing", "Succeeded", and "Failed".
                    "name": "str",  # Optional. The import name.
                    "reports": [
                        {
                            "id": "str",  # The report ID. Required.
                            "appId": "str",  # Optional. The app ID, returned only if the
                              report belongs to an app.
                            "datasetId": "str",  # Optional. The dataset ID of the
                              report.
                            "description": "str",  # Optional. The report description.
                            "embedUrl": "str",  # Optional. The embed URL of the report.
                            "name": "str",  # Optional. The name of the report.
                            "reportType": "str",  # Optional. The report type.
                              "PaginatedReport"
                            "subscriptions": [
                                {
                                    "id": "str",  # The subscription ID.
                                      Required.
                                    "artifactDisplayName": "str",  # Optional.
                                      The name of the subscribed Power BI item (such as a report or a
                                      dashboard).
                                    "artifactId": "str",  # Optional. The ID of
                                      the subscribed Power BI item (such as a report or a dashboard).
                                    "artifactType": "str",  # Optional. The type
                                      of Power BI item (for example a ``Report``"" , ``Dashboard``"" ,
                                      or ``Dataset``"" ).
                                    "attachmentFormat": "str",  # Optional.
                                      Format of the report attached in the email subscription.
                                    "endDate": "2020-02-20 00:00:00",  #
                                      Optional. The end date and time of the email subscription.
                                    "frequency": "str",  # Optional. The
                                      frequency of the email subscription.
                                    "isEnabled": bool,  # Optional. Whether the
                                      email subscription is enabled.
                                    "linkToContent": bool,  # Optional. Whether a
                                      subscription link exists in the email subscription.
                                    "previewImage": bool,  # Optional. Whether a
                                      screenshot of the report exists in the email subscription.
                                    "startDate": "2020-02-20 00:00:00",  #
                                      Optional. The start date and time of the email subscription.
                                    "subArtifactDisplayName": "str",  # Optional.
                                      The page name of the subscribed Power BI item, if it's a report.
                                    "title": "str",  # Optional. The app name.
                                    "users": [
                                        {
                                            "identifier": "str",  #
                                              Identifier of the principal. Required.
                                            "principalType": "str",  #
                                              The principal type. Required. Known values are: "None",
                                              "User", "Group", and "App".
                                            "displayName": "str",  #
                                              Optional. Display name of the principal.
                                            "emailAddress": "str",  #
                                              Optional. Email address of the user.
                                            "graphId": "str",  #
                                              Optional. Identifier of the principal in Microsoft Graph.
                                              Only available for admin APIs.
                                            "profile": {
                                                "id": "str",  # The
                                                  service principal profile ID. Required.
                                                "displayName": "str"
                                                  # Optional. The service principal profile name.
                                            },
                                            "userType": "str"  #
                                              Optional. Type of the user.
                                        }
                                    ]
                                }
                            ],
                            "users": [
                                {
                                    "identifier": "str",  # Identifier of the
                                      principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "reportUserAccessRight": "str",  # The access
                                      right that the user has for the report (permission level).
                                      Required. Known values are: "None", "Read", "ReadWrite",
                                      "ReadReshare", "ReadCopy", and "Owner".
                                    "displayName": "str",  # Optional. Display
                                      name of the principal.
                                    "emailAddress": "str",  # Optional. Email
                                      address of the user.
                                    "graphId": "str",  # Optional. Identifier of
                                      the principal in Microsoft Graph. Only available for admin APIs.
                                    "profile": {
                                        "id": "str",  # The service principal
                                          profile ID. Required.
                                        "displayName": "str"  # Optional. The
                                          service principal profile name.
                                    },
                                    "userType": "str"  # Optional. Type of the
                                      user.
                                }
                            ],
                            "webUrl": "str"  # Optional. The web URL of the report.
                        }
                    ],
                    "updatedDateTime": "2020-02-20 00:00:00"  # Optional. Import last update date
                      and time.
                }
        """

    @distributed_trace_async
    async def post_import_in_group(
        self,
        group_id: str,
        import_info: Union[JSON, IO],
        *,
        dataset_display_name: str,
        name_conflict: Optional[str] = None,
        skip_report: Optional[bool] = None,
        override_report_label: Optional[bool] = None,
        override_model_label: Optional[bool] = None,
        **kwargs: Any
    ) -> JSON:
        """Creates new content in the specified workspace.

        ..

           [!NOTE]
           Supported content:


           * Power BI .pbix files
           * JSON files (.json)
           * Excel files (.xlsx)
           * SQL Server Report Definition Language files (.rdl)



        * To import a file, specify the content type **multipart/form-data** in the request headers and
        encode the file as `form data <https://www.w3.org/TR/html401/interact/forms.html>`_ in the
        request body.
        * To import an .rdl file, include the file extension in the name specified by
        ``datasetDisplayName``\ , as described in `URI parameters
        </rest/api/power-bi/imports/post-import-in-group#uri-parameters>`_.
        * To import an .xlsx file from OneDrive for Business, include the content type
        **application/json** in the request headers. Include `ImportInfo
        </rest/api/power-bi/imports/post-import-in-group#importinfo>`_ with ``filePath`` set to the
        .xlsx file path in the request body.
        * To import large Power BI .pbix files that are between 1 GB and 10 GB in size, see `Create
        Temporary Upload Location In Group
        </rest/api/power-bi/imports/create-temporary-upload-location-in-group>`_ and the `Import Large
        Files
        <https://github.com/microsoft/PowerBI-Developer-Samples/blob/master/PowerShell%20Scripts/Import%20Large%20Files>`_
        PowerShell script. This is only supported for Premium capacity workspaces.
        * To create a dataflow from a model.json file, set ``datasetDisplayName`` to *model.json*\ , as
        described in `URI parameters
        </rest/api/power-bi/imports/post-import-in-group#uri-parameters>`_.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------


        * Dataflows with service principal aren't supported.
        * Importing a Power BI .pbix file from OneDrive isn't supported.
        * Importing a file that has a **protected** sensitivity label isn't supported for service
        principals.
          :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param import_info: The import to post. Is either a JSON type or a IO type. Required.
        :type import_info: JSON or IO
        :keyword dataset_display_name: The display name of the dataset should include file extension.
         Not supported when importing from OneDrive for Business. For importing or creating dataflows,
         this parameter should be hardcoded to model.json. Required.
        :paramtype dataset_display_name: str
        :keyword name_conflict: Specifies what to do if a dataset with the same name already exists.
         The default value is ``Ignore``. For RDL files, ``Abort`` and ``Overwrite`` are the only
         supported options. For dataflow model.json files, ``Abort`` and ``GenerateUniqueName`` are the
         only supported options. Known values are: "Ignore", "Abort", "Overwrite", "CreateOrOverwrite",
         and "GenerateUniqueName". Default value is None.
        :paramtype name_conflict: str
        :keyword skip_report: Whether to skip report import. If specified, the value must be ``true``.
         Only supported for Power BI .pbix files. Default value is None.
        :paramtype skip_report: bool
        :keyword override_report_label: Whether to override the existing label on a report when
         republishing a Power BI .pbix file. The service default value is ``true``. Default value is
         None.
        :paramtype override_report_label: bool
        :keyword override_model_label: Determines whether to override the existing label on a model
         when republishing a Power BI .pbix file. The service default value is ``true``. Default value
         is None.
        :paramtype override_model_label: bool
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                import_info = {
                    "connectionType": "str",  # Optional. The import connection type for a
                      OneDrive for Business file. Known values are: "import" and "connect".
                    "filePath": "str",  # Optional. The path of the OneDrive for Business Excel
                      (.xlsx) file to import, which can be absolute or relative. Power BI .pbix files
                      aren't supported.
                    "fileUrl": "str"  # Optional. The shared access signature URL of the
                      temporary blob storage used to import large Power BI .pbix files between 1 GB and
                      10 GB in size.
                }

                # response body for status code(s): 200, 202
                response == {
                    "id": "str",  # The import ID. Required.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Import creation date
                      and time.
                    "datasets": [
                        {
                            "id": "str",  # The dataset ID. Required.
                            "ContentProviderType": "str",  # Optional. The content
                              provider type for the dataset.
                            "CreateReportEmbedURL": "str",  # Optional. The dataset
                              create report embed URL.
                            "CreatedDate": "2020-02-20 00:00:00",  # Optional. The
                              dataset creation date and time.
                            "Encryption": {
                                "EncryptionStatus": "str"  # Optional. Dataset
                                  encryption status. Known values are: "Unknown", "NotSupported",
                                  "InSyncWithWorkspace", and "NotInSyncWithWorkspace".
                            },
                            "IsEffectiveIdentityRequired": bool,  # Optional. Whether the
                              dataset requires an effective identity, which you must send in a
                              `GenerateToken </rest/api/power-bi/embed-token/generate-token>`_ API
                              call.
                            "IsEffectiveIdentityRolesRequired": bool,  # Optional.
                              Whether row-level security is defined inside the Power BI .pbix file. If
                              so, you must specify a role.
                            "IsInPlaceSharingEnabled": bool,  # Optional. Whether the
                              dataset can be shared with external users to be consumed in their own
                              tenant.
                            "IsOnPremGatewayRequired": bool,  # Optional. Whether the
                              dataset requires an on-premises data gateway.
                            "IsRefreshable": bool,  # Optional. Whether the dataset is
                              refreshable or not. A Power BI refreshable dataset is a dataset that has
                              been refreshed at least once, or for which a valid refresh schedule
                              exists.
                            "QnaEmbedURL": "str",  # Optional. The dataset Q&A embed URL.
                            "addRowsAPIEnabled": bool,  # Optional. Whether the dataset
                              allows adding new rows.
                            "configuredBy": "str",  # Optional. The dataset owner.
                            "description": "str",  # Optional. The dataset description.
                            "name": "str",  # Optional. The dataset name.
                            "queryScaleOutSettings": {
                                "autoSyncReadOnlyReplicas": bool,  # Optional.
                                  Whether the dataset automatically syncs read-only replicas.
                                "maxReadOnlyReplicas": 0  # Optional. Maximum number
                                  of read-only replicas for the dataset (0-64, -1 for automatic number
                                  of replicas).
                            },
                            "targetStorageMode": "str",  # Optional. The dataset storage
                              mode.
                            "upstreamDataflows": [
                                {
                                    "groupId": "str",  # Optional. The target
                                      group ID.
                                    "targetDataflowId": "str"  # Optional. The
                                      target dataflow ID.
                                }
                            ],
                            "users": [
                                {
                                    "datasetUserAccessRight": "str",  # The
                                      access right that the user has for the dataset (permission
                                      level). Required. Known values are: "None", "Read", "ReadWrite",
                                      "ReadReshare", "ReadWriteReshare", "ReadExplore",
                                      "ReadReshareExplore", "ReadWriteExplore", and
                                      "ReadWriteReshareExplore".
                                    "identifier": "str",  # Identifier of the
                                      principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "displayName": "str",  # Optional. Display
                                      name of the principal.
                                    "emailAddress": "str",  # Optional. Email
                                      address of the user.
                                    "graphId": "str",  # Optional. Identifier of
                                      the principal in Microsoft Graph. Only available for admin APIs.
                                    "profile": {
                                        "id": "str",  # The service principal
                                          profile ID. Required.
                                        "displayName": "str"  # Optional. The
                                          service principal profile name.
                                    },
                                    "userType": "str"  # Optional. Type of the
                                      user.
                                }
                            ],
                            "webUrl": "str"  # Optional. The web URL of the dataset.
                        }
                    ],
                    "importState": "str",  # Optional. The import upload state. Known values are:
                      "Publishing", "Succeeded", and "Failed".
                    "name": "str",  # Optional. The import name.
                    "reports": [
                        {
                            "id": "str",  # The report ID. Required.
                            "appId": "str",  # Optional. The app ID, returned only if the
                              report belongs to an app.
                            "datasetId": "str",  # Optional. The dataset ID of the
                              report.
                            "description": "str",  # Optional. The report description.
                            "embedUrl": "str",  # Optional. The embed URL of the report.
                            "name": "str",  # Optional. The name of the report.
                            "reportType": "str",  # Optional. The report type.
                              "PaginatedReport"
                            "subscriptions": [
                                {
                                    "id": "str",  # The subscription ID.
                                      Required.
                                    "artifactDisplayName": "str",  # Optional.
                                      The name of the subscribed Power BI item (such as a report or a
                                      dashboard).
                                    "artifactId": "str",  # Optional. The ID of
                                      the subscribed Power BI item (such as a report or a dashboard).
                                    "artifactType": "str",  # Optional. The type
                                      of Power BI item (for example a ``Report``"" , ``Dashboard``"" ,
                                      or ``Dataset``"" ).
                                    "attachmentFormat": "str",  # Optional.
                                      Format of the report attached in the email subscription.
                                    "endDate": "2020-02-20 00:00:00",  #
                                      Optional. The end date and time of the email subscription.
                                    "frequency": "str",  # Optional. The
                                      frequency of the email subscription.
                                    "isEnabled": bool,  # Optional. Whether the
                                      email subscription is enabled.
                                    "linkToContent": bool,  # Optional. Whether a
                                      subscription link exists in the email subscription.
                                    "previewImage": bool,  # Optional. Whether a
                                      screenshot of the report exists in the email subscription.
                                    "startDate": "2020-02-20 00:00:00",  #
                                      Optional. The start date and time of the email subscription.
                                    "subArtifactDisplayName": "str",  # Optional.
                                      The page name of the subscribed Power BI item, if it's a report.
                                    "title": "str",  # Optional. The app name.
                                    "users": [
                                        {
                                            "identifier": "str",  #
                                              Identifier of the principal. Required.
                                            "principalType": "str",  #
                                              The principal type. Required. Known values are: "None",
                                              "User", "Group", and "App".
                                            "displayName": "str",  #
                                              Optional. Display name of the principal.
                                            "emailAddress": "str",  #
                                              Optional. Email address of the user.
                                            "graphId": "str",  #
                                              Optional. Identifier of the principal in Microsoft Graph.
                                              Only available for admin APIs.
                                            "profile": {
                                                "id": "str",  # The
                                                  service principal profile ID. Required.
                                                "displayName": "str"
                                                  # Optional. The service principal profile name.
                                            },
                                            "userType": "str"  #
                                              Optional. Type of the user.
                                        }
                                    ]
                                }
                            ],
                            "users": [
                                {
                                    "identifier": "str",  # Identifier of the
                                      principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "reportUserAccessRight": "str",  # The access
                                      right that the user has for the report (permission level).
                                      Required. Known values are: "None", "Read", "ReadWrite",
                                      "ReadReshare", "ReadCopy", and "Owner".
                                    "displayName": "str",  # Optional. Display
                                      name of the principal.
                                    "emailAddress": "str",  # Optional. Email
                                      address of the user.
                                    "graphId": "str",  # Optional. Identifier of
                                      the principal in Microsoft Graph. Only available for admin APIs.
                                    "profile": {
                                        "id": "str",  # The service principal
                                          profile ID. Required.
                                        "displayName": "str"  # Optional. The
                                          service principal profile name.
                                    },
                                    "userType": "str"  # Optional. Type of the
                                      user.
                                }
                            ],
                            "webUrl": "str"  # Optional. The web URL of the report.
                        }
                    ],
                    "updatedDateTime": "2020-02-20 00:00:00"  # Optional. Import last update date
                      and time.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(import_info, (IOBase, bytes)):
            _content = import_info
        else:
            _json = import_info

        _request = build_imports_post_import_in_group_request(
            group_id=group_id,
            dataset_display_name=dataset_display_name,
            name_conflict=name_conflict,
            skip_report=skip_report,
            override_report_label=override_report_label,
            override_model_label=override_model_label,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 202:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_import_in_group(self, group_id: str, import_id: str, **kwargs: Any) -> JSON:
        """Returns the specified import from the specified workspace.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Dataset.ReadWrite.All or Dataset.Read.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param import_id: The import ID. Required.
        :type import_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # The import ID. Required.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Import creation date
                      and time.
                    "datasets": [
                        {
                            "id": "str",  # The dataset ID. Required.
                            "ContentProviderType": "str",  # Optional. The content
                              provider type for the dataset.
                            "CreateReportEmbedURL": "str",  # Optional. The dataset
                              create report embed URL.
                            "CreatedDate": "2020-02-20 00:00:00",  # Optional. The
                              dataset creation date and time.
                            "Encryption": {
                                "EncryptionStatus": "str"  # Optional. Dataset
                                  encryption status. Known values are: "Unknown", "NotSupported",
                                  "InSyncWithWorkspace", and "NotInSyncWithWorkspace".
                            },
                            "IsEffectiveIdentityRequired": bool,  # Optional. Whether the
                              dataset requires an effective identity, which you must send in a
                              `GenerateToken </rest/api/power-bi/embed-token/generate-token>`_ API
                              call.
                            "IsEffectiveIdentityRolesRequired": bool,  # Optional.
                              Whether row-level security is defined inside the Power BI .pbix file. If
                              so, you must specify a role.
                            "IsInPlaceSharingEnabled": bool,  # Optional. Whether the
                              dataset can be shared with external users to be consumed in their own
                              tenant.
                            "IsOnPremGatewayRequired": bool,  # Optional. Whether the
                              dataset requires an on-premises data gateway.
                            "IsRefreshable": bool,  # Optional. Whether the dataset is
                              refreshable or not. A Power BI refreshable dataset is a dataset that has
                              been refreshed at least once, or for which a valid refresh schedule
                              exists.
                            "QnaEmbedURL": "str",  # Optional. The dataset Q&A embed URL.
                            "addRowsAPIEnabled": bool,  # Optional. Whether the dataset
                              allows adding new rows.
                            "configuredBy": "str",  # Optional. The dataset owner.
                            "description": "str",  # Optional. The dataset description.
                            "name": "str",  # Optional. The dataset name.
                            "queryScaleOutSettings": {
                                "autoSyncReadOnlyReplicas": bool,  # Optional.
                                  Whether the dataset automatically syncs read-only replicas.
                                "maxReadOnlyReplicas": 0  # Optional. Maximum number
                                  of read-only replicas for the dataset (0-64, -1 for automatic number
                                  of replicas).
                            },
                            "targetStorageMode": "str",  # Optional. The dataset storage
                              mode.
                            "upstreamDataflows": [
                                {
                                    "groupId": "str",  # Optional. The target
                                      group ID.
                                    "targetDataflowId": "str"  # Optional. The
                                      target dataflow ID.
                                }
                            ],
                            "users": [
                                {
                                    "datasetUserAccessRight": "str",  # The
                                      access right that the user has for the dataset (permission
                                      level). Required. Known values are: "None", "Read", "ReadWrite",
                                      "ReadReshare", "ReadWriteReshare", "ReadExplore",
                                      "ReadReshareExplore", "ReadWriteExplore", and
                                      "ReadWriteReshareExplore".
                                    "identifier": "str",  # Identifier of the
                                      principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "displayName": "str",  # Optional. Display
                                      name of the principal.
                                    "emailAddress": "str",  # Optional. Email
                                      address of the user.
                                    "graphId": "str",  # Optional. Identifier of
                                      the principal in Microsoft Graph. Only available for admin APIs.
                                    "profile": {
                                        "id": "str",  # The service principal
                                          profile ID. Required.
                                        "displayName": "str"  # Optional. The
                                          service principal profile name.
                                    },
                                    "userType": "str"  # Optional. Type of the
                                      user.
                                }
                            ],
                            "webUrl": "str"  # Optional. The web URL of the dataset.
                        }
                    ],
                    "importState": "str",  # Optional. The import upload state. Known values are:
                      "Publishing", "Succeeded", and "Failed".
                    "name": "str",  # Optional. The import name.
                    "reports": [
                        {
                            "id": "str",  # The report ID. Required.
                            "appId": "str",  # Optional. The app ID, returned only if the
                              report belongs to an app.
                            "datasetId": "str",  # Optional. The dataset ID of the
                              report.
                            "description": "str",  # Optional. The report description.
                            "embedUrl": "str",  # Optional. The embed URL of the report.
                            "name": "str",  # Optional. The name of the report.
                            "reportType": "str",  # Optional. The report type.
                              "PaginatedReport"
                            "subscriptions": [
                                {
                                    "id": "str",  # The subscription ID.
                                      Required.
                                    "artifactDisplayName": "str",  # Optional.
                                      The name of the subscribed Power BI item (such as a report or a
                                      dashboard).
                                    "artifactId": "str",  # Optional. The ID of
                                      the subscribed Power BI item (such as a report or a dashboard).
                                    "artifactType": "str",  # Optional. The type
                                      of Power BI item (for example a ``Report``"" , ``Dashboard``"" ,
                                      or ``Dataset``"" ).
                                    "attachmentFormat": "str",  # Optional.
                                      Format of the report attached in the email subscription.
                                    "endDate": "2020-02-20 00:00:00",  #
                                      Optional. The end date and time of the email subscription.
                                    "frequency": "str",  # Optional. The
                                      frequency of the email subscription.
                                    "isEnabled": bool,  # Optional. Whether the
                                      email subscription is enabled.
                                    "linkToContent": bool,  # Optional. Whether a
                                      subscription link exists in the email subscription.
                                    "previewImage": bool,  # Optional. Whether a
                                      screenshot of the report exists in the email subscription.
                                    "startDate": "2020-02-20 00:00:00",  #
                                      Optional. The start date and time of the email subscription.
                                    "subArtifactDisplayName": "str",  # Optional.
                                      The page name of the subscribed Power BI item, if it's a report.
                                    "title": "str",  # Optional. The app name.
                                    "users": [
                                        {
                                            "identifier": "str",  #
                                              Identifier of the principal. Required.
                                            "principalType": "str",  #
                                              The principal type. Required. Known values are: "None",
                                              "User", "Group", and "App".
                                            "displayName": "str",  #
                                              Optional. Display name of the principal.
                                            "emailAddress": "str",  #
                                              Optional. Email address of the user.
                                            "graphId": "str",  #
                                              Optional. Identifier of the principal in Microsoft Graph.
                                              Only available for admin APIs.
                                            "profile": {
                                                "id": "str",  # The
                                                  service principal profile ID. Required.
                                                "displayName": "str"
                                                  # Optional. The service principal profile name.
                                            },
                                            "userType": "str"  #
                                              Optional. Type of the user.
                                        }
                                    ]
                                }
                            ],
                            "users": [
                                {
                                    "identifier": "str",  # Identifier of the
                                      principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "reportUserAccessRight": "str",  # The access
                                      right that the user has for the report (permission level).
                                      Required. Known values are: "None", "Read", "ReadWrite",
                                      "ReadReshare", "ReadCopy", and "Owner".
                                    "displayName": "str",  # Optional. Display
                                      name of the principal.
                                    "emailAddress": "str",  # Optional. Email
                                      address of the user.
                                    "graphId": "str",  # Optional. Identifier of
                                      the principal in Microsoft Graph. Only available for admin APIs.
                                    "profile": {
                                        "id": "str",  # The service principal
                                          profile ID. Required.
                                        "displayName": "str"  # Optional. The
                                          service principal profile name.
                                    },
                                    "userType": "str"  # Optional. Type of the
                                      user.
                                }
                            ],
                            "webUrl": "str"  # Optional. The web URL of the report.
                        }
                    ],
                    "updatedDateTime": "2020-02-20 00:00:00"  # Optional. Import last update date
                      and time.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_imports_get_import_in_group_request(
            group_id=group_id,
            import_id=import_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def create_temporary_upload_location_in_group(  # pylint: disable=name-too-long
        self, group_id: str, **kwargs: Any
    ) -> JSON:
        """Creates a temporary blob storage upload location for importing large Power BI .pbix files that
        are between 1 GB and 10 GB in size.

        To import large Power BI .pbix files:


        #. Create a temporary upload location using this API call.
        #. Upload the Power BI .pbix files using the *shared access signature* URL from the API call
        response.
        #. Call `Post Import In Group </rest/api/power-bi/imports/post-import-in-group>`_\ , specifying
        the *shared access signature* URL in the ``fileUrl`` parameter of the `request body
        </rest/api/power-bi/imports/post-import-in-group#request-body>`_.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------

        Importing large Power BI .pbix files between 1 GB and 10 GB in size is only available for
        Premium capacity workspaces.
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "ExpirationTime": "2020-02-20 00:00:00",  # The expiration date and time of
                      the shared access signature URL. Required.
                    "Url": "str"  # The shared access signature URL for the temporary blob
                      storage. Required.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_imports_create_temporary_upload_location_in_group_request(
            group_id=group_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_imports_as_admin(
        self,
        *,
        expand: Optional[str] = None,
        filter: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        **kwargs: Any
    ) -> JSON:
        """Returns a list of imports for the organization.

        Permissions
        -----------


        * The user must have administrator rights (such as Office 365 Global Administrator or Power BI
        Service Administrator) or authenticate using a service principal.
        * Delegated permissions are supported.

        When running under service prinicipal authentication, an app **must not** have any
        admin-consent required premissions for Power BI set on it in the Azure portal.

        Required Scope
        --------------

        Tenant.Read.All or Tenant.ReadWrite.All

        Relevant only when authenticating via a standard delegated admin access token. Must not be
        present when authentication via a service principal is used.

        Limitations
        -----------

        Maximum 200 requests per hour.
        :code:`<br>`:code:`<br>`.

        :keyword expand: Expands related entities inline. Default value is None.
        :paramtype expand: str
        :keyword filter: Filters the results, based on a boolean condition. Default value is None.
        :paramtype filter: str
        :keyword top: Returns only the first n results. Default value is None.
        :paramtype top: int
        :keyword skip: Skips the first n results. Default value is None.
        :paramtype skip: int
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional. OData context.
                    "value": [
                        {
                            "id": "str",  # The import ID. Required.
                            "createdDateTime": "2020-02-20 00:00:00",  # Optional. Import
                              creation date and time.
                            "datasets": [
                                {
                                    "id": "str",  # The dataset ID. Required.
                                    "ContentProviderType": "str",  # Optional.
                                      The content provider type for the dataset.
                                    "CreateReportEmbedURL": "str",  # Optional.
                                      The dataset create report embed URL.
                                    "CreatedDate": "2020-02-20 00:00:00",  #
                                      Optional. The dataset creation date and time.
                                    "Encryption": {
                                        "EncryptionStatus": "str"  #
                                          Optional. Dataset encryption status. Known values are:
                                          "Unknown", "NotSupported", "InSyncWithWorkspace", and
                                          "NotInSyncWithWorkspace".
                                    },
                                    "IsEffectiveIdentityRequired": bool,  #
                                      Optional. Whether the dataset requires an effective identity,
                                      which you must send in a `GenerateToken
                                      </rest/api/power-bi/embed-token/generate-token>`_ API call.
                                    "IsEffectiveIdentityRolesRequired": bool,  #
                                      Optional. Whether row-level security is defined inside the Power
                                      BI .pbix file. If so, you must specify a role.
                                    "IsInPlaceSharingEnabled": bool,  # Optional.
                                      Whether the dataset can be shared with external users to be
                                      consumed in their own tenant.
                                    "IsOnPremGatewayRequired": bool,  # Optional.
                                      Whether the dataset requires an on-premises data gateway.
                                    "IsRefreshable": bool,  # Optional. Whether
                                      the dataset is refreshable or not. A Power BI refreshable dataset
                                      is a dataset that has been refreshed at least once, or for which
                                      a valid refresh schedule exists.
                                    "QnaEmbedURL": "str",  # Optional. The
                                      dataset Q&A embed URL.
                                    "addRowsAPIEnabled": bool,  # Optional.
                                      Whether the dataset allows adding new rows.
                                    "configuredBy": "str",  # Optional. The
                                      dataset owner.
                                    "description": "str",  # Optional. The
                                      dataset description.
                                    "name": "str",  # Optional. The dataset name.
                                    "queryScaleOutSettings": {
                                        "autoSyncReadOnlyReplicas": bool,  #
                                          Optional. Whether the dataset automatically syncs read-only
                                          replicas.
                                        "maxReadOnlyReplicas": 0  # Optional.
                                          Maximum number of read-only replicas for the dataset (0-64,
                                          -1 for automatic number of replicas).
                                    },
                                    "targetStorageMode": "str",  # Optional. The
                                      dataset storage mode.
                                    "upstreamDataflows": [
                                        {
                                            "groupId": "str",  #
                                              Optional. The target group ID.
                                            "targetDataflowId": "str"  #
                                              Optional. The target dataflow ID.
                                        }
                                    ],
                                    "users": [
                                        {
                                            "datasetUserAccessRight":
                                              "str",  # The access right that the user has for the
                                              dataset (permission level). Required. Known values are:
                                              "None", "Read", "ReadWrite", "ReadReshare",
                                              "ReadWriteReshare", "ReadExplore", "ReadReshareExplore",
                                              "ReadWriteExplore", and "ReadWriteReshareExplore".
                                            "identifier": "str",  #
                                              Identifier of the principal. Required.
                                            "principalType": "str",  #
                                              The principal type. Required. Known values are: "None",
                                              "User", "Group", and "App".
                                            "displayName": "str",  #
                                              Optional. Display name of the principal.
                                            "emailAddress": "str",  #
                                              Optional. Email address of the user.
                                            "graphId": "str",  #
                                              Optional. Identifier of the principal in Microsoft Graph.
                                              Only available for admin APIs.
                                            "profile": {
                                                "id": "str",  # The
                                                  service principal profile ID. Required.
                                                "displayName": "str"
                                                  # Optional. The service principal profile name.
                                            },
                                            "userType": "str"  #
                                              Optional. Type of the user.
                                        }
                                    ],
                                    "webUrl": "str"  # Optional. The web URL of
                                      the dataset.
                                }
                            ],
                            "importState": "str",  # Optional. The import upload state.
                              Known values are: "Publishing", "Succeeded", and "Failed".
                            "name": "str",  # Optional. The import name.
                            "reports": [
                                {
                                    "id": "str",  # The report ID. Required.
                                    "appId": "str",  # Optional. The app ID,
                                      returned only if the report belongs to an app.
                                    "datasetId": "str",  # Optional. The dataset
                                      ID of the report.
                                    "description": "str",  # Optional. The report
                                      description.
                                    "embedUrl": "str",  # Optional. The embed URL
                                      of the report.
                                    "name": "str",  # Optional. The name of the
                                      report.
                                    "reportType": "str",  # Optional. The report
                                      type. "PaginatedReport"
                                    "subscriptions": [
                                        {
                                            "id": "str",  # The
                                              subscription ID. Required.
                                            "artifactDisplayName": "str",
                                              # Optional. The name of the subscribed Power BI item
                                              (such as a report or a dashboard).
                                            "artifactId": "str",  #
                                              Optional. The ID of the subscribed Power BI item (such as
                                              a report or a dashboard).
                                            "artifactType": "str",  #
                                              Optional. The type of Power BI item (for example a
                                              ``Report``"" , ``Dashboard``"" , or ``Dataset``"" ).
                                            "attachmentFormat": "str",  #
                                              Optional. Format of the report attached in the email
                                              subscription.
                                            "endDate": "2020-02-20
                                              00:00:00",  # Optional. The end date and time of the
                                              email subscription.
                                            "frequency": "str",  #
                                              Optional. The frequency of the email subscription.
                                            "isEnabled": bool,  #
                                              Optional. Whether the email subscription is enabled.
                                            "linkToContent": bool,  #
                                              Optional. Whether a subscription link exists in the email
                                              subscription.
                                            "previewImage": bool,  #
                                              Optional. Whether a screenshot of the report exists in
                                              the email subscription.
                                            "startDate": "2020-02-20
                                              00:00:00",  # Optional. The start date and time of the
                                              email subscription.
                                            "subArtifactDisplayName":
                                              "str",  # Optional. The page name of the subscribed Power
                                              BI item, if it's a report.
                                            "title": "str",  # Optional.
                                              The app name.
                                            "users": [
                                                {
                                                    "identifier":
                                                      "str",  # Identifier of the principal. Required.
                "principalType": "str",  # The principal type.
                                                      Required. Known values are: "None", "User",
                                                      "Group", and "App".
                "displayName": "str",  # Optional. Display name
                                                      of the principal.
                "emailAddress": "str",  # Optional. Email address
                                                      of the user.
                                                    "graphId":
                                                      "str",  # Optional. Identifier of the principal
                                                      in Microsoft Graph. Only available for admin
                                                      APIs.
                                                    "profile": {
                                                        "id":
                                                          "str",  # The service principal profile ID.
                                                          Required.
                "displayName": "str"  # Optional. The service
                                                          principal profile name.
                                                    },
                                                    "userType":
                                                      "str"  # Optional. Type of the user.
                                                }
                                            ]
                                        }
                                    ],
                                    "users": [
                                        {
                                            "identifier": "str",  #
                                              Identifier of the principal. Required.
                                            "principalType": "str",  #
                                              The principal type. Required. Known values are: "None",
                                              "User", "Group", and "App".
                                            "reportUserAccessRight":
                                              "str",  # The access right that the user has for the
                                              report (permission level). Required. Known values are:
                                              "None", "Read", "ReadWrite", "ReadReshare", "ReadCopy",
                                              and "Owner".
                                            "displayName": "str",  #
                                              Optional. Display name of the principal.
                                            "emailAddress": "str",  #
                                              Optional. Email address of the user.
                                            "graphId": "str",  #
                                              Optional. Identifier of the principal in Microsoft Graph.
                                              Only available for admin APIs.
                                            "profile": {
                                                "id": "str",  # The
                                                  service principal profile ID. Required.
                                                "displayName": "str"
                                                  # Optional. The service principal profile name.
                                            },
                                            "userType": "str"  #
                                              Optional. Type of the user.
                                        }
                                    ],
                                    "webUrl": "str"  # Optional. The web URL of
                                      the report.
                                }
                            ],
                            "updatedDateTime": "2020-02-20 00:00:00"  # Optional. Import
                              last update date and time.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_imports_get_imports_as_admin_request(
            expand=expand,
            filter=filter,
            top=top,
            skip=skip,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore


class ReportsOperations:  # pylint: disable=too-many-public-methods
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~power_bi_client.aio.PowerBIClient`'s
        :attr:`reports` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get_reports(self, **kwargs: Any) -> JSON:
        """Returns a list of reports from **My workspace**.

        This API also returns shared reports and reports from shared apps. Reports that reside in
        shared workspaces can be accessed using the `Get Reports In Group API
        </rest/api/power-bi/reports/get-reports-in-group>`_.

        Since paginated reports (RDL) don't have a dataset, the dataset ID value in the API response
        for paginated reports isn't displayed.

        Required Scope
        --------------

        Report.ReadWrite.All or Report.Read.All
        :code:`<br>`:code:`<br>`.

        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional. OData context.
                    "value": [
                        {
                            "id": "str",  # The report ID. Required.
                            "appId": "str",  # Optional. The app ID, returned only if the
                              report belongs to an app.
                            "datasetId": "str",  # Optional. The dataset ID of the
                              report.
                            "description": "str",  # Optional. The report description.
                            "embedUrl": "str",  # Optional. The embed URL of the report.
                            "name": "str",  # Optional. The name of the report.
                            "reportType": "str",  # Optional. The report type.
                              "PaginatedReport"
                            "subscriptions": [
                                {
                                    "id": "str",  # The subscription ID.
                                      Required.
                                    "artifactDisplayName": "str",  # Optional.
                                      The name of the subscribed Power BI item (such as a report or a
                                      dashboard).
                                    "artifactId": "str",  # Optional. The ID of
                                      the subscribed Power BI item (such as a report or a dashboard).
                                    "artifactType": "str",  # Optional. The type
                                      of Power BI item (for example a ``Report``"" , ``Dashboard``"" ,
                                      or ``Dataset``"" ).
                                    "attachmentFormat": "str",  # Optional.
                                      Format of the report attached in the email subscription.
                                    "endDate": "2020-02-20 00:00:00",  #
                                      Optional. The end date and time of the email subscription.
                                    "frequency": "str",  # Optional. The
                                      frequency of the email subscription.
                                    "isEnabled": bool,  # Optional. Whether the
                                      email subscription is enabled.
                                    "linkToContent": bool,  # Optional. Whether a
                                      subscription link exists in the email subscription.
                                    "previewImage": bool,  # Optional. Whether a
                                      screenshot of the report exists in the email subscription.
                                    "startDate": "2020-02-20 00:00:00",  #
                                      Optional. The start date and time of the email subscription.
                                    "subArtifactDisplayName": "str",  # Optional.
                                      The page name of the subscribed Power BI item, if it's a report.
                                    "title": "str",  # Optional. The app name.
                                    "users": [
                                        {
                                            "identifier": "str",  #
                                              Identifier of the principal. Required.
                                            "principalType": "str",  #
                                              The principal type. Required. Known values are: "None",
                                              "User", "Group", and "App".
                                            "displayName": "str",  #
                                              Optional. Display name of the principal.
                                            "emailAddress": "str",  #
                                              Optional. Email address of the user.
                                            "graphId": "str",  #
                                              Optional. Identifier of the principal in Microsoft Graph.
                                              Only available for admin APIs.
                                            "profile": {
                                                "id": "str",  # The
                                                  service principal profile ID. Required.
                                                "displayName": "str"
                                                  # Optional. The service principal profile name.
                                            },
                                            "userType": "str"  #
                                              Optional. Type of the user.
                                        }
                                    ]
                                }
                            ],
                            "users": [
                                {
                                    "identifier": "str",  # Identifier of the
                                      principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "reportUserAccessRight": "str",  # The access
                                      right that the user has for the report (permission level).
                                      Required. Known values are: "None", "Read", "ReadWrite",
                                      "ReadReshare", "ReadCopy", and "Owner".
                                    "displayName": "str",  # Optional. Display
                                      name of the principal.
                                    "emailAddress": "str",  # Optional. Email
                                      address of the user.
                                    "graphId": "str",  # Optional. Identifier of
                                      the principal in Microsoft Graph. Only available for admin APIs.
                                    "profile": {
                                        "id": "str",  # The service principal
                                          profile ID. Required.
                                        "displayName": "str"  # Optional. The
                                          service principal profile name.
                                    },
                                    "userType": "str"  # Optional. Type of the
                                      user.
                                }
                            ],
                            "webUrl": "str"  # Optional. The web URL of the report.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_reports_get_reports_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_report(self, report_id: str, **kwargs: Any) -> JSON:
        """Returns the specified report from **My workspace**.

        Required Scope
        --------------

        Report.ReadWrite.All or Report.Read.All
        :code:`<br>`:code:`<br>`.

        :param report_id: The report ID. Required.
        :type report_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # The report ID. Required.
                    "appId": "str",  # Optional. The app ID, returned only if the report belongs
                      to an app.
                    "datasetId": "str",  # Optional. The dataset ID of the report.
                    "description": "str",  # Optional. The report description.
                    "embedUrl": "str",  # Optional. The embed URL of the report.
                    "name": "str",  # Optional. The name of the report.
                    "reportType": "str",  # Optional. The report type. "PaginatedReport"
                    "subscriptions": [
                        {
                            "id": "str",  # The subscription ID. Required.
                            "artifactDisplayName": "str",  # Optional. The name of the
                              subscribed Power BI item (such as a report or a dashboard).
                            "artifactId": "str",  # Optional. The ID of the subscribed
                              Power BI item (such as a report or a dashboard).
                            "artifactType": "str",  # Optional. The type of Power BI item
                              (for example a ``Report``"" , ``Dashboard``"" , or ``Dataset``"" ).
                            "attachmentFormat": "str",  # Optional. Format of the report
                              attached in the email subscription.
                            "endDate": "2020-02-20 00:00:00",  # Optional. The end date
                              and time of the email subscription.
                            "frequency": "str",  # Optional. The frequency of the email
                              subscription.
                            "isEnabled": bool,  # Optional. Whether the email
                              subscription is enabled.
                            "linkToContent": bool,  # Optional. Whether a subscription
                              link exists in the email subscription.
                            "previewImage": bool,  # Optional. Whether a screenshot of
                              the report exists in the email subscription.
                            "startDate": "2020-02-20 00:00:00",  # Optional. The start
                              date and time of the email subscription.
                            "subArtifactDisplayName": "str",  # Optional. The page name
                              of the subscribed Power BI item, if it's a report.
                            "title": "str",  # Optional. The app name.
                            "users": [
                                {
                                    "identifier": "str",  # Identifier of the
                                      principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "displayName": "str",  # Optional. Display
                                      name of the principal.
                                    "emailAddress": "str",  # Optional. Email
                                      address of the user.
                                    "graphId": "str",  # Optional. Identifier of
                                      the principal in Microsoft Graph. Only available for admin APIs.
                                    "profile": {
                                        "id": "str",  # The service principal
                                          profile ID. Required.
                                        "displayName": "str"  # Optional. The
                                          service principal profile name.
                                    },
                                    "userType": "str"  # Optional. Type of the
                                      user.
                                }
                            ]
                        }
                    ],
                    "users": [
                        {
                            "identifier": "str",  # Identifier of the principal.
                              Required.
                            "principalType": "str",  # The principal type. Required.
                              Known values are: "None", "User", "Group", and "App".
                            "reportUserAccessRight": "str",  # The access right that the
                              user has for the report (permission level). Required. Known values are:
                              "None", "Read", "ReadWrite", "ReadReshare", "ReadCopy", and "Owner".
                            "displayName": "str",  # Optional. Display name of the
                              principal.
                            "emailAddress": "str",  # Optional. Email address of the
                              user.
                            "graphId": "str",  # Optional. Identifier of the principal in
                              Microsoft Graph. Only available for admin APIs.
                            "profile": {
                                "id": "str",  # The service principal profile ID.
                                  Required.
                                "displayName": "str"  # Optional. The service
                                  principal profile name.
                            },
                            "userType": "str"  # Optional. Type of the user.
                        }
                    ],
                    "webUrl": "str"  # Optional. The web URL of the report.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_reports_get_report_request(
            report_id=report_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def delete_report(  # pylint: disable=inconsistent-return-statements
        self, report_id: str, **kwargs: Any
    ) -> None:
        """Deletes the specified report from **My workspace**.

        Required Scope
        --------------

        Report.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param report_id: The report ID. Required.
        :type report_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_reports_delete_report_request(
            report_id=report_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def clone_report(
        self, report_id: str, request_parameters: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Clones the specified report from **My workspace**.

        * If the dataset for a cloned report resides in two different workspaces or in **My
        workspace**\ , then a shared dataset will be created in the report's workspace.
        * When cloned, reports with a `live connection </power-bi/desktop-report-lifecycle-datasets>`_
        will lose that connection and instead have a direct binding to the target dataset.

        Permissions
        -----------

        The user must have all of the following, unless a requirement doesn't apply:


        * **Write** permission on the specified report.
        * **Build** permission on the target dataset, required if the ``targetModelId`` parameter is
        used.

        Required Scope
        --------------

        Content.Create
        :code:`<br>`:code:`<br>`.

        :param report_id: The report ID. Required.
        :type report_id: str
        :param request_parameters: Clone report parameters. Required.
        :type request_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                request_parameters = {
                    "name": "str",  # The new report name. Required.
                    "targetModelId": "str",  # Optional. Optional. Parameter for specifying the
                      target associated dataset ID. If not provided, the new report will be associated
                      with the same dataset as the source report.
                    "targetWorkspaceId": "str"  # Optional. Optional. Parameter for specifying
                      the target workspace ID. An empty GUID (""
                      ``00000000-0000-0000-0000-000000000000``"" ) indicates **My workspace**. If this
                      parameter isn't provided, the new report will be cloned within the same workspace
                      as the source report.
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # The report ID. Required.
                    "appId": "str",  # Optional. The app ID, returned only if the report belongs
                      to an app.
                    "datasetId": "str",  # Optional. The dataset ID of the report.
                    "description": "str",  # Optional. The report description.
                    "embedUrl": "str",  # Optional. The embed URL of the report.
                    "name": "str",  # Optional. The name of the report.
                    "reportType": "str",  # Optional. The report type. "PaginatedReport"
                    "subscriptions": [
                        {
                            "id": "str",  # The subscription ID. Required.
                            "artifactDisplayName": "str",  # Optional. The name of the
                              subscribed Power BI item (such as a report or a dashboard).
                            "artifactId": "str",  # Optional. The ID of the subscribed
                              Power BI item (such as a report or a dashboard).
                            "artifactType": "str",  # Optional. The type of Power BI item
                              (for example a ``Report``"" , ``Dashboard``"" , or ``Dataset``"" ).
                            "attachmentFormat": "str",  # Optional. Format of the report
                              attached in the email subscription.
                            "endDate": "2020-02-20 00:00:00",  # Optional. The end date
                              and time of the email subscription.
                            "frequency": "str",  # Optional. The frequency of the email
                              subscription.
                            "isEnabled": bool,  # Optional. Whether the email
                              subscription is enabled.
                            "linkToContent": bool,  # Optional. Whether a subscription
                              link exists in the email subscription.
                            "previewImage": bool,  # Optional. Whether a screenshot of
                              the report exists in the email subscription.
                            "startDate": "2020-02-20 00:00:00",  # Optional. The start
                              date and time of the email subscription.
                            "subArtifactDisplayName": "str",  # Optional. The page name
                              of the subscribed Power BI item, if it's a report.
                            "title": "str",  # Optional. The app name.
                            "users": [
                                {
                                    "identifier": "str",  # Identifier of the
                                      principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "displayName": "str",  # Optional. Display
                                      name of the principal.
                                    "emailAddress": "str",  # Optional. Email
                                      address of the user.
                                    "graphId": "str",  # Optional. Identifier of
                                      the principal in Microsoft Graph. Only available for admin APIs.
                                    "profile": {
                                        "id": "str",  # The service principal
                                          profile ID. Required.
                                        "displayName": "str"  # Optional. The
                                          service principal profile name.
                                    },
                                    "userType": "str"  # Optional. Type of the
                                      user.
                                }
                            ]
                        }
                    ],
                    "users": [
                        {
                            "identifier": "str",  # Identifier of the principal.
                              Required.
                            "principalType": "str",  # The principal type. Required.
                              Known values are: "None", "User", "Group", and "App".
                            "reportUserAccessRight": "str",  # The access right that the
                              user has for the report (permission level). Required. Known values are:
                              "None", "Read", "ReadWrite", "ReadReshare", "ReadCopy", and "Owner".
                            "displayName": "str",  # Optional. Display name of the
                              principal.
                            "emailAddress": "str",  # Optional. Email address of the
                              user.
                            "graphId": "str",  # Optional. Identifier of the principal in
                              Microsoft Graph. Only available for admin APIs.
                            "profile": {
                                "id": "str",  # The service principal profile ID.
                                  Required.
                                "displayName": "str"  # Optional. The service
                                  principal profile name.
                            },
                            "userType": "str"  # Optional. Type of the user.
                        }
                    ],
                    "webUrl": "str"  # Optional. The web URL of the report.
                }
        """

    @overload
    async def clone_report(
        self, report_id: str, request_parameters: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Clones the specified report from **My workspace**.

        * If the dataset for a cloned report resides in two different workspaces or in **My
        workspace**\ , then a shared dataset will be created in the report's workspace.
        * When cloned, reports with a `live connection </power-bi/desktop-report-lifecycle-datasets>`_
        will lose that connection and instead have a direct binding to the target dataset.

        Permissions
        -----------

        The user must have all of the following, unless a requirement doesn't apply:


        * **Write** permission on the specified report.
        * **Build** permission on the target dataset, required if the ``targetModelId`` parameter is
        used.

        Required Scope
        --------------

        Content.Create
        :code:`<br>`:code:`<br>`.

        :param report_id: The report ID. Required.
        :type report_id: str
        :param request_parameters: Clone report parameters. Required.
        :type request_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # The report ID. Required.
                    "appId": "str",  # Optional. The app ID, returned only if the report belongs
                      to an app.
                    "datasetId": "str",  # Optional. The dataset ID of the report.
                    "description": "str",  # Optional. The report description.
                    "embedUrl": "str",  # Optional. The embed URL of the report.
                    "name": "str",  # Optional. The name of the report.
                    "reportType": "str",  # Optional. The report type. "PaginatedReport"
                    "subscriptions": [
                        {
                            "id": "str",  # The subscription ID. Required.
                            "artifactDisplayName": "str",  # Optional. The name of the
                              subscribed Power BI item (such as a report or a dashboard).
                            "artifactId": "str",  # Optional. The ID of the subscribed
                              Power BI item (such as a report or a dashboard).
                            "artifactType": "str",  # Optional. The type of Power BI item
                              (for example a ``Report``"" , ``Dashboard``"" , or ``Dataset``"" ).
                            "attachmentFormat": "str",  # Optional. Format of the report
                              attached in the email subscription.
                            "endDate": "2020-02-20 00:00:00",  # Optional. The end date
                              and time of the email subscription.
                            "frequency": "str",  # Optional. The frequency of the email
                              subscription.
                            "isEnabled": bool,  # Optional. Whether the email
                              subscription is enabled.
                            "linkToContent": bool,  # Optional. Whether a subscription
                              link exists in the email subscription.
                            "previewImage": bool,  # Optional. Whether a screenshot of
                              the report exists in the email subscription.
                            "startDate": "2020-02-20 00:00:00",  # Optional. The start
                              date and time of the email subscription.
                            "subArtifactDisplayName": "str",  # Optional. The page name
                              of the subscribed Power BI item, if it's a report.
                            "title": "str",  # Optional. The app name.
                            "users": [
                                {
                                    "identifier": "str",  # Identifier of the
                                      principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "displayName": "str",  # Optional. Display
                                      name of the principal.
                                    "emailAddress": "str",  # Optional. Email
                                      address of the user.
                                    "graphId": "str",  # Optional. Identifier of
                                      the principal in Microsoft Graph. Only available for admin APIs.
                                    "profile": {
                                        "id": "str",  # The service principal
                                          profile ID. Required.
                                        "displayName": "str"  # Optional. The
                                          service principal profile name.
                                    },
                                    "userType": "str"  # Optional. Type of the
                                      user.
                                }
                            ]
                        }
                    ],
                    "users": [
                        {
                            "identifier": "str",  # Identifier of the principal.
                              Required.
                            "principalType": "str",  # The principal type. Required.
                              Known values are: "None", "User", "Group", and "App".
                            "reportUserAccessRight": "str",  # The access right that the
                              user has for the report (permission level). Required. Known values are:
                              "None", "Read", "ReadWrite", "ReadReshare", "ReadCopy", and "Owner".
                            "displayName": "str",  # Optional. Display name of the
                              principal.
                            "emailAddress": "str",  # Optional. Email address of the
                              user.
                            "graphId": "str",  # Optional. Identifier of the principal in
                              Microsoft Graph. Only available for admin APIs.
                            "profile": {
                                "id": "str",  # The service principal profile ID.
                                  Required.
                                "displayName": "str"  # Optional. The service
                                  principal profile name.
                            },
                            "userType": "str"  # Optional. Type of the user.
                        }
                    ],
                    "webUrl": "str"  # Optional. The web URL of the report.
                }
        """

    @distributed_trace_async
    async def clone_report(self, report_id: str, request_parameters: Union[JSON, IO], **kwargs: Any) -> JSON:
        """Clones the specified report from **My workspace**.

        * If the dataset for a cloned report resides in two different workspaces or in **My
        workspace**\ , then a shared dataset will be created in the report's workspace.
        * When cloned, reports with a `live connection </power-bi/desktop-report-lifecycle-datasets>`_
        will lose that connection and instead have a direct binding to the target dataset.

        Permissions
        -----------

        The user must have all of the following, unless a requirement doesn't apply:


        * **Write** permission on the specified report.
        * **Build** permission on the target dataset, required if the ``targetModelId`` parameter is
        used.

        Required Scope
        --------------

        Content.Create
        :code:`<br>`:code:`<br>`.

        :param report_id: The report ID. Required.
        :type report_id: str
        :param request_parameters: Clone report parameters. Is either a JSON type or a IO type.
         Required.
        :type request_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                request_parameters = {
                    "name": "str",  # The new report name. Required.
                    "targetModelId": "str",  # Optional. Optional. Parameter for specifying the
                      target associated dataset ID. If not provided, the new report will be associated
                      with the same dataset as the source report.
                    "targetWorkspaceId": "str"  # Optional. Optional. Parameter for specifying
                      the target workspace ID. An empty GUID (""
                      ``00000000-0000-0000-0000-000000000000``"" ) indicates **My workspace**. If this
                      parameter isn't provided, the new report will be cloned within the same workspace
                      as the source report.
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # The report ID. Required.
                    "appId": "str",  # Optional. The app ID, returned only if the report belongs
                      to an app.
                    "datasetId": "str",  # Optional. The dataset ID of the report.
                    "description": "str",  # Optional. The report description.
                    "embedUrl": "str",  # Optional. The embed URL of the report.
                    "name": "str",  # Optional. The name of the report.
                    "reportType": "str",  # Optional. The report type. "PaginatedReport"
                    "subscriptions": [
                        {
                            "id": "str",  # The subscription ID. Required.
                            "artifactDisplayName": "str",  # Optional. The name of the
                              subscribed Power BI item (such as a report or a dashboard).
                            "artifactId": "str",  # Optional. The ID of the subscribed
                              Power BI item (such as a report or a dashboard).
                            "artifactType": "str",  # Optional. The type of Power BI item
                              (for example a ``Report``"" , ``Dashboard``"" , or ``Dataset``"" ).
                            "attachmentFormat": "str",  # Optional. Format of the report
                              attached in the email subscription.
                            "endDate": "2020-02-20 00:00:00",  # Optional. The end date
                              and time of the email subscription.
                            "frequency": "str",  # Optional. The frequency of the email
                              subscription.
                            "isEnabled": bool,  # Optional. Whether the email
                              subscription is enabled.
                            "linkToContent": bool,  # Optional. Whether a subscription
                              link exists in the email subscription.
                            "previewImage": bool,  # Optional. Whether a screenshot of
                              the report exists in the email subscription.
                            "startDate": "2020-02-20 00:00:00",  # Optional. The start
                              date and time of the email subscription.
                            "subArtifactDisplayName": "str",  # Optional. The page name
                              of the subscribed Power BI item, if it's a report.
                            "title": "str",  # Optional. The app name.
                            "users": [
                                {
                                    "identifier": "str",  # Identifier of the
                                      principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "displayName": "str",  # Optional. Display
                                      name of the principal.
                                    "emailAddress": "str",  # Optional. Email
                                      address of the user.
                                    "graphId": "str",  # Optional. Identifier of
                                      the principal in Microsoft Graph. Only available for admin APIs.
                                    "profile": {
                                        "id": "str",  # The service principal
                                          profile ID. Required.
                                        "displayName": "str"  # Optional. The
                                          service principal profile name.
                                    },
                                    "userType": "str"  # Optional. Type of the
                                      user.
                                }
                            ]
                        }
                    ],
                    "users": [
                        {
                            "identifier": "str",  # Identifier of the principal.
                              Required.
                            "principalType": "str",  # The principal type. Required.
                              Known values are: "None", "User", "Group", and "App".
                            "reportUserAccessRight": "str",  # The access right that the
                              user has for the report (permission level). Required. Known values are:
                              "None", "Read", "ReadWrite", "ReadReshare", "ReadCopy", and "Owner".
                            "displayName": "str",  # Optional. Display name of the
                              principal.
                            "emailAddress": "str",  # Optional. Email address of the
                              user.
                            "graphId": "str",  # Optional. Identifier of the principal in
                              Microsoft Graph. Only available for admin APIs.
                            "profile": {
                                "id": "str",  # The service principal profile ID.
                                  Required.
                                "displayName": "str"  # Optional. The service
                                  principal profile name.
                            },
                            "userType": "str"  # Optional. Type of the user.
                        }
                    ],
                    "webUrl": "str"  # Optional. The web URL of the report.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(request_parameters, (IOBase, bytes)):
            _content = request_parameters
        else:
            _json = request_parameters

        _request = build_reports_clone_report_request(
            report_id=report_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def export_report(self, report_id: str, **kwargs: Any) -> AsyncIterator[bytes]:
        """Exports the specified report from **My workspace** to a Power BI .pbix or .rdl file.

        * For .pbix reports -
          As a `workaround
        </power-bi/developer/embedded/troubleshoot-rest-api#fix-timeout-exceptions-when-using-import-and-export-apis>`_
        for timeout issues, set the ``preferClientRouting`` URL query parameter to ``true``.
        * Large files are downloaded to a temporary blob. Their URL is returned in the response, and
        stored in the locally downloaded Power BI .pbix file.
        * For more information on requirements and limitations, see `Download a report from the Power
        BI service to Power BI Desktop </power-bi/create-reports/service-export-to-pbix>`_.

        Required Scope
        --------------

        Report.ReadWrite.All or both Report.Read.All and Dataset.Read.All

        Limitations
        -----------

        For .pbix report, after calling `Rebind Report </rest/api/power-bi/reports/rebind-report>`_\ ,
        export of a report with a `Power BI service live connection
        </power-bi/desktop-report-lifecycle-datasets>`_ isn't supported.
        :code:`<br>`:code:`<br>`.

        :param report_id: The report ID. Required.
        :type report_id: str
        :return: Async iterator of the response bytes
        :rtype: AsyncIterator[bytes]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        _request = build_reports_export_report_request(
            report_id=report_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, cast(AsyncIterator[bytes], deserialized), {})  # type: ignore

        return cast(AsyncIterator[bytes], deserialized)  # type: ignore

    @overload
    async def update_report_content(
        self, report_id: str, request_parameters: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Updates the content of the specified report from **My workspace** with the content of a
        specified source report.

        Specify the source report in the request body.

        Required Scope
        --------------

        Report.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param report_id: The report ID. Required.
        :type report_id: str
        :param request_parameters: UpdateReportContent parameters. Required.
        :type request_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                request_parameters = {
                    "sourceReport": {
                        "sourceReportId": "str",  # The source report ID. Required.
                        "sourceWorkspaceId": "str"  # Optional. The source workspace ID.
                    },
                    "sourceType": "ExistingReport"  # Default value is "ExistingReport". The
                      source type of the content update. Required.
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # The report ID. Required.
                    "appId": "str",  # Optional. The app ID, returned only if the report belongs
                      to an app.
                    "datasetId": "str",  # Optional. The dataset ID of the report.
                    "description": "str",  # Optional. The report description.
                    "embedUrl": "str",  # Optional. The embed URL of the report.
                    "name": "str",  # Optional. The name of the report.
                    "reportType": "str",  # Optional. The report type. "PaginatedReport"
                    "subscriptions": [
                        {
                            "id": "str",  # The subscription ID. Required.
                            "artifactDisplayName": "str",  # Optional. The name of the
                              subscribed Power BI item (such as a report or a dashboard).
                            "artifactId": "str",  # Optional. The ID of the subscribed
                              Power BI item (such as a report or a dashboard).
                            "artifactType": "str",  # Optional. The type of Power BI item
                              (for example a ``Report``"" , ``Dashboard``"" , or ``Dataset``"" ).
                            "attachmentFormat": "str",  # Optional. Format of the report
                              attached in the email subscription.
                            "endDate": "2020-02-20 00:00:00",  # Optional. The end date
                              and time of the email subscription.
                            "frequency": "str",  # Optional. The frequency of the email
                              subscription.
                            "isEnabled": bool,  # Optional. Whether the email
                              subscription is enabled.
                            "linkToContent": bool,  # Optional. Whether a subscription
                              link exists in the email subscription.
                            "previewImage": bool,  # Optional. Whether a screenshot of
                              the report exists in the email subscription.
                            "startDate": "2020-02-20 00:00:00",  # Optional. The start
                              date and time of the email subscription.
                            "subArtifactDisplayName": "str",  # Optional. The page name
                              of the subscribed Power BI item, if it's a report.
                            "title": "str",  # Optional. The app name.
                            "users": [
                                {
                                    "identifier": "str",  # Identifier of the
                                      principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "displayName": "str",  # Optional. Display
                                      name of the principal.
                                    "emailAddress": "str",  # Optional. Email
                                      address of the user.
                                    "graphId": "str",  # Optional. Identifier of
                                      the principal in Microsoft Graph. Only available for admin APIs.
                                    "profile": {
                                        "id": "str",  # The service principal
                                          profile ID. Required.
                                        "displayName": "str"  # Optional. The
                                          service principal profile name.
                                    },
                                    "userType": "str"  # Optional. Type of the
                                      user.
                                }
                            ]
                        }
                    ],
                    "users": [
                        {
                            "identifier": "str",  # Identifier of the principal.
                              Required.
                            "principalType": "str",  # The principal type. Required.
                              Known values are: "None", "User", "Group", and "App".
                            "reportUserAccessRight": "str",  # The access right that the
                              user has for the report (permission level). Required. Known values are:
                              "None", "Read", "ReadWrite", "ReadReshare", "ReadCopy", and "Owner".
                            "displayName": "str",  # Optional. Display name of the
                              principal.
                            "emailAddress": "str",  # Optional. Email address of the
                              user.
                            "graphId": "str",  # Optional. Identifier of the principal in
                              Microsoft Graph. Only available for admin APIs.
                            "profile": {
                                "id": "str",  # The service principal profile ID.
                                  Required.
                                "displayName": "str"  # Optional. The service
                                  principal profile name.
                            },
                            "userType": "str"  # Optional. Type of the user.
                        }
                    ],
                    "webUrl": "str"  # Optional. The web URL of the report.
                }
        """

    @overload
    async def update_report_content(
        self, report_id: str, request_parameters: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Updates the content of the specified report from **My workspace** with the content of a
        specified source report.

        Specify the source report in the request body.

        Required Scope
        --------------

        Report.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param report_id: The report ID. Required.
        :type report_id: str
        :param request_parameters: UpdateReportContent parameters. Required.
        :type request_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # The report ID. Required.
                    "appId": "str",  # Optional. The app ID, returned only if the report belongs
                      to an app.
                    "datasetId": "str",  # Optional. The dataset ID of the report.
                    "description": "str",  # Optional. The report description.
                    "embedUrl": "str",  # Optional. The embed URL of the report.
                    "name": "str",  # Optional. The name of the report.
                    "reportType": "str",  # Optional. The report type. "PaginatedReport"
                    "subscriptions": [
                        {
                            "id": "str",  # The subscription ID. Required.
                            "artifactDisplayName": "str",  # Optional. The name of the
                              subscribed Power BI item (such as a report or a dashboard).
                            "artifactId": "str",  # Optional. The ID of the subscribed
                              Power BI item (such as a report or a dashboard).
                            "artifactType": "str",  # Optional. The type of Power BI item
                              (for example a ``Report``"" , ``Dashboard``"" , or ``Dataset``"" ).
                            "attachmentFormat": "str",  # Optional. Format of the report
                              attached in the email subscription.
                            "endDate": "2020-02-20 00:00:00",  # Optional. The end date
                              and time of the email subscription.
                            "frequency": "str",  # Optional. The frequency of the email
                              subscription.
                            "isEnabled": bool,  # Optional. Whether the email
                              subscription is enabled.
                            "linkToContent": bool,  # Optional. Whether a subscription
                              link exists in the email subscription.
                            "previewImage": bool,  # Optional. Whether a screenshot of
                              the report exists in the email subscription.
                            "startDate": "2020-02-20 00:00:00",  # Optional. The start
                              date and time of the email subscription.
                            "subArtifactDisplayName": "str",  # Optional. The page name
                              of the subscribed Power BI item, if it's a report.
                            "title": "str",  # Optional. The app name.
                            "users": [
                                {
                                    "identifier": "str",  # Identifier of the
                                      principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "displayName": "str",  # Optional. Display
                                      name of the principal.
                                    "emailAddress": "str",  # Optional. Email
                                      address of the user.
                                    "graphId": "str",  # Optional. Identifier of
                                      the principal in Microsoft Graph. Only available for admin APIs.
                                    "profile": {
                                        "id": "str",  # The service principal
                                          profile ID. Required.
                                        "displayName": "str"  # Optional. The
                                          service principal profile name.
                                    },
                                    "userType": "str"  # Optional. Type of the
                                      user.
                                }
                            ]
                        }
                    ],
                    "users": [
                        {
                            "identifier": "str",  # Identifier of the principal.
                              Required.
                            "principalType": "str",  # The principal type. Required.
                              Known values are: "None", "User", "Group", and "App".
                            "reportUserAccessRight": "str",  # The access right that the
                              user has for the report (permission level). Required. Known values are:
                              "None", "Read", "ReadWrite", "ReadReshare", "ReadCopy", and "Owner".
                            "displayName": "str",  # Optional. Display name of the
                              principal.
                            "emailAddress": "str",  # Optional. Email address of the
                              user.
                            "graphId": "str",  # Optional. Identifier of the principal in
                              Microsoft Graph. Only available for admin APIs.
                            "profile": {
                                "id": "str",  # The service principal profile ID.
                                  Required.
                                "displayName": "str"  # Optional. The service
                                  principal profile name.
                            },
                            "userType": "str"  # Optional. Type of the user.
                        }
                    ],
                    "webUrl": "str"  # Optional. The web URL of the report.
                }
        """

    @distributed_trace_async
    async def update_report_content(self, report_id: str, request_parameters: Union[JSON, IO], **kwargs: Any) -> JSON:
        """Updates the content of the specified report from **My workspace** with the content of a
        specified source report.

        Specify the source report in the request body.

        Required Scope
        --------------

        Report.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param report_id: The report ID. Required.
        :type report_id: str
        :param request_parameters: UpdateReportContent parameters. Is either a JSON type or a IO type.
         Required.
        :type request_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                request_parameters = {
                    "sourceReport": {
                        "sourceReportId": "str",  # The source report ID. Required.
                        "sourceWorkspaceId": "str"  # Optional. The source workspace ID.
                    },
                    "sourceType": "ExistingReport"  # Default value is "ExistingReport". The
                      source type of the content update. Required.
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # The report ID. Required.
                    "appId": "str",  # Optional. The app ID, returned only if the report belongs
                      to an app.
                    "datasetId": "str",  # Optional. The dataset ID of the report.
                    "description": "str",  # Optional. The report description.
                    "embedUrl": "str",  # Optional. The embed URL of the report.
                    "name": "str",  # Optional. The name of the report.
                    "reportType": "str",  # Optional. The report type. "PaginatedReport"
                    "subscriptions": [
                        {
                            "id": "str",  # The subscription ID. Required.
                            "artifactDisplayName": "str",  # Optional. The name of the
                              subscribed Power BI item (such as a report or a dashboard).
                            "artifactId": "str",  # Optional. The ID of the subscribed
                              Power BI item (such as a report or a dashboard).
                            "artifactType": "str",  # Optional. The type of Power BI item
                              (for example a ``Report``"" , ``Dashboard``"" , or ``Dataset``"" ).
                            "attachmentFormat": "str",  # Optional. Format of the report
                              attached in the email subscription.
                            "endDate": "2020-02-20 00:00:00",  # Optional. The end date
                              and time of the email subscription.
                            "frequency": "str",  # Optional. The frequency of the email
                              subscription.
                            "isEnabled": bool,  # Optional. Whether the email
                              subscription is enabled.
                            "linkToContent": bool,  # Optional. Whether a subscription
                              link exists in the email subscription.
                            "previewImage": bool,  # Optional. Whether a screenshot of
                              the report exists in the email subscription.
                            "startDate": "2020-02-20 00:00:00",  # Optional. The start
                              date and time of the email subscription.
                            "subArtifactDisplayName": "str",  # Optional. The page name
                              of the subscribed Power BI item, if it's a report.
                            "title": "str",  # Optional. The app name.
                            "users": [
                                {
                                    "identifier": "str",  # Identifier of the
                                      principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "displayName": "str",  # Optional. Display
                                      name of the principal.
                                    "emailAddress": "str",  # Optional. Email
                                      address of the user.
                                    "graphId": "str",  # Optional. Identifier of
                                      the principal in Microsoft Graph. Only available for admin APIs.
                                    "profile": {
                                        "id": "str",  # The service principal
                                          profile ID. Required.
                                        "displayName": "str"  # Optional. The
                                          service principal profile name.
                                    },
                                    "userType": "str"  # Optional. Type of the
                                      user.
                                }
                            ]
                        }
                    ],
                    "users": [
                        {
                            "identifier": "str",  # Identifier of the principal.
                              Required.
                            "principalType": "str",  # The principal type. Required.
                              Known values are: "None", "User", "Group", and "App".
                            "reportUserAccessRight": "str",  # The access right that the
                              user has for the report (permission level). Required. Known values are:
                              "None", "Read", "ReadWrite", "ReadReshare", "ReadCopy", and "Owner".
                            "displayName": "str",  # Optional. Display name of the
                              principal.
                            "emailAddress": "str",  # Optional. Email address of the
                              user.
                            "graphId": "str",  # Optional. Identifier of the principal in
                              Microsoft Graph. Only available for admin APIs.
                            "profile": {
                                "id": "str",  # The service principal profile ID.
                                  Required.
                                "displayName": "str"  # Optional. The service
                                  principal profile name.
                            },
                            "userType": "str"  # Optional. Type of the user.
                        }
                    ],
                    "webUrl": "str"  # Optional. The web URL of the report.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(request_parameters, (IOBase, bytes)):
            _content = request_parameters
        else:
            _json = request_parameters

        _request = build_reports_update_report_content_request(
            report_id=report_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def rebind_report(  # pylint: disable=inconsistent-return-statements
        self, report_id: str, request_parameters: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Rebinds the specified report from **My workspace** to the specified dataset.

        * If the specified dataset resides in a different workspace than the report, then a shared
        dataset will be created in **My workspace**.
        * On rebind, reports with a `live connection </power-bi/desktop-report-lifecycle-datasets>`_
        will lose that connection and instead have a direct binding to the target dataset.

        Permissions
        -----------

        The user must have all of the following:


        * **Write** permission on the specified report.
        * **Build** permission on the target dataset.

        Required Scope
        --------------

        Report.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param report_id: The report ID. Required.
        :type report_id: str
        :param request_parameters: Rebind report parameters. Required.
        :type request_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                request_parameters = {
                    "datasetId": "str"  # The new dataset for the rebound report. If the dataset
                      resides in a different workspace than the report, a shared dataset will be
                      created in the report's workspace. Required.
                }
        """

    @overload
    async def rebind_report(  # pylint: disable=inconsistent-return-statements
        self, report_id: str, request_parameters: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Rebinds the specified report from **My workspace** to the specified dataset.

        * If the specified dataset resides in a different workspace than the report, then a shared
        dataset will be created in **My workspace**.
        * On rebind, reports with a `live connection </power-bi/desktop-report-lifecycle-datasets>`_
        will lose that connection and instead have a direct binding to the target dataset.

        Permissions
        -----------

        The user must have all of the following:


        * **Write** permission on the specified report.
        * **Build** permission on the target dataset.

        Required Scope
        --------------

        Report.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param report_id: The report ID. Required.
        :type report_id: str
        :param request_parameters: Rebind report parameters. Required.
        :type request_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def rebind_report(  # pylint: disable=inconsistent-return-statements
        self, report_id: str, request_parameters: Union[JSON, IO], **kwargs: Any
    ) -> None:
        """Rebinds the specified report from **My workspace** to the specified dataset.

        * If the specified dataset resides in a different workspace than the report, then a shared
        dataset will be created in **My workspace**.
        * On rebind, reports with a `live connection </power-bi/desktop-report-lifecycle-datasets>`_
        will lose that connection and instead have a direct binding to the target dataset.

        Permissions
        -----------

        The user must have all of the following:


        * **Write** permission on the specified report.
        * **Build** permission on the target dataset.

        Required Scope
        --------------

        Report.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param report_id: The report ID. Required.
        :type report_id: str
        :param request_parameters: Rebind report parameters. Is either a JSON type or a IO type.
         Required.
        :type request_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                request_parameters = {
                    "datasetId": "str"  # The new dataset for the rebound report. If the dataset
                      resides in a different workspace than the report, a shared dataset will be
                      created in the report's workspace. Required.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(request_parameters, (IOBase, bytes)):
            _content = request_parameters
        else:
            _json = request_parameters

        _request = build_reports_rebind_report_request(
            report_id=report_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get_pages(self, report_id: str, **kwargs: Any) -> JSON:
        """Returns a list of pages within the specified report from **My workspace**.

        Required Scope
        --------------

        Report.ReadWrite.All or Report.Read.All
        :code:`<br>`:code:`<br>`.

        :param report_id: The report ID. Required.
        :type report_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional. OData context.
                    "value": [
                        {
                            "displayName": "str",  # Optional. The display name of the
                              report page.
                            "name": "str",  # Optional. The name of the report page.
                            "order": 0  # Optional. The order of the report page.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_reports_get_pages_request(
            report_id=report_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_page(self, report_id: str, page_name: str, **kwargs: Any) -> JSON:
        """Returns the specified page within the specified report from **My workspace**.

        Required Scope
        --------------

        Report.ReadWrite.All or Report.Read.All
        :code:`<br>`:code:`<br>`.

        :param report_id: The report ID. Required.
        :type report_id: str
        :param page_name: The page name. Required.
        :type page_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "displayName": "str",  # Optional. The display name of the report page.
                    "name": "str",  # Optional. The name of the report page.
                    "order": 0  # Optional. The order of the report page.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_reports_get_page_request(
            report_id=report_id,
            page_name=page_name,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_datasources(self, report_id: str, **kwargs: Any) -> JSON:
        """Returns a list of data sources for the specified paginated report (RDL) from **My workspace**.

        Required Scope
        --------------

        Report.ReadWrite.All or Report.Read.All
        :code:`<br>`:code:`<br>`.

        :param report_id: The report ID. Required.
        :type report_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional. OData context.
                    "value": [
                        {
                            "connectionDetails": {
                                "account": "str",  # Optional. The connection
                                  account.
                                "classInfo": "str",  # Optional. The connection class
                                  information.
                                "database": "str",  # Optional. The connection
                                  database.
                                "domain": "str",  # Optional. The connection domain.
                                "emailAddress": "str",  # Optional. The connection
                                  email address.
                                "kind": "str",  # Optional. The connection kind.
                                "loginServer": "str",  # Optional. The connection
                                  login server.
                                "path": "str",  # Optional. The connection path.
                                "server": "str",  # Optional. The connection server.
                                "url": "str"  # Optional. The connection URL.
                            },
                            "connectionString": "str",  # Optional. (Deprecated) The data
                              source connection string. Available only for DirectQuery.
                            "datasourceId": "str",  # Optional. The bound data source ID,
                              which is empty when not bound to a gateway.
                            "datasourceType": "str",  # Optional. The data source type.
                            "gatewayId": "str",  # Optional. The bound gateway ID, which
                              is empty when not bound to a gateway. When using a gateway cluster, the
                              gateway ID refers to the primary (first) gateway in the cluster and is
                              similar to the gateway cluster ID.
                            "name": "str"  # Optional. (Deprecated) The data source name.
                              Available only for DirectQuery.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_reports_get_datasources_request(
            report_id=report_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def update_datasources(  # pylint: disable=inconsistent-return-statements
        self,
        report_id: str,
        update_rdl_datasources_request: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Updates the data sources of the specified paginated report (RDL) from **My workspace**.

        ..

           [!IMPORTANT]
           Both the original data source and the new data source must have the exact same schema.


        Permissions
        -----------

        The user must be the data source owner.

        Required Scope
        --------------

        Reports.ReadWrite.All

        Limitations
        -----------


        * Only supports paginated reports.
        * Changing the data source type isn't supported.
          :code:`<br>`:code:`<br>`.

        :param report_id: The report ID. Required.
        :type report_id: str
        :param update_rdl_datasources_request: Required.
        :type update_rdl_datasources_request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                update_rdl_datasources_request = {
                    "updateDetails": [
                        {
                            "connectionDetails": {
                                "database": "str",  # Optional. The connection
                                  database.
                                "server": "str"  # Optional. The connection server.
                            },
                            "datasourceName": "str"  # The name of the paginated report
                              data source. Required.
                        }
                    ]
                }
        """

    @overload
    async def update_datasources(  # pylint: disable=inconsistent-return-statements
        self,
        report_id: str,
        update_rdl_datasources_request: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Updates the data sources of the specified paginated report (RDL) from **My workspace**.

        ..

           [!IMPORTANT]
           Both the original data source and the new data source must have the exact same schema.


        Permissions
        -----------

        The user must be the data source owner.

        Required Scope
        --------------

        Reports.ReadWrite.All

        Limitations
        -----------


        * Only supports paginated reports.
        * Changing the data source type isn't supported.
          :code:`<br>`:code:`<br>`.

        :param report_id: The report ID. Required.
        :type report_id: str
        :param update_rdl_datasources_request: Required.
        :type update_rdl_datasources_request: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_datasources(  # pylint: disable=inconsistent-return-statements
        self, report_id: str, update_rdl_datasources_request: Union[JSON, IO], **kwargs: Any
    ) -> None:
        """Updates the data sources of the specified paginated report (RDL) from **My workspace**.

        ..

           [!IMPORTANT]
           Both the original data source and the new data source must have the exact same schema.


        Permissions
        -----------

        The user must be the data source owner.

        Required Scope
        --------------

        Reports.ReadWrite.All

        Limitations
        -----------


        * Only supports paginated reports.
        * Changing the data source type isn't supported.
          :code:`<br>`:code:`<br>`.

        :param report_id: The report ID. Required.
        :type report_id: str
        :param update_rdl_datasources_request: Is either a JSON type or a IO type. Required.
        :type update_rdl_datasources_request: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                update_rdl_datasources_request = {
                    "updateDetails": [
                        {
                            "connectionDetails": {
                                "database": "str",  # Optional. The connection
                                  database.
                                "server": "str"  # Optional. The connection server.
                            },
                            "datasourceName": "str"  # The name of the paginated report
                              data source. Required.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(update_rdl_datasources_request, (IOBase, bytes)):
            _content = update_rdl_datasources_request
        else:
            _json = update_rdl_datasources_request

        _request = build_reports_update_datasources_request(
            report_id=report_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def export_to_file(
        self, report_id: str, request_parameters: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Exports the specified report from **My workspace** to the requested `file format
        </rest/api/power-bi/reports/export-to-file#fileformat>`_.

        The API is asynchronous. When the API is called, it triggers an export job. After triggering an
        export job, use `GetExportToFileStatus API
        </rest/api/power-bi/reports/get-export-to-file-status>`_ to track the job status.
        Read more about the entire flow: `Export Power BI reports
        </power-bi/developer/embedded/export-to>`_ and `Export Paginated reports
        </power-bi/developer/embedded/export-paginated-report>`_

        Required Scope
        --------------

        All of the following:


        * Report.ReadWrite.All or Report.Read.All
        * Dataset.ReadWrite.All or Dataset.Read.All

        Limitations
        -----------

        Check the limitations in `Export Power BI report to file
        </power-bi/developer/embedded/export-to#considerations-and-limitations>`_ and `Export paginated
        report to file
        </power-bi/developer/embedded/export-paginated-report#considerations-and-limitations>`_.
        :code:`<br>`:code:`<br>`.

        :param report_id: The report ID. Required.
        :type report_id: str
        :param request_parameters: Export to file request parameters. Required.
        :type request_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                request_parameters = {
                    "format": "str",  # The requested format for the exported file. Required.
                      Known values are: "PPTX", "PDF", "PNG", "IMAGE", "XLSX", "DOCX", "CSV", "XML",
                      "MHTML", and "ACCESSIBLEPDF".
                    "paginatedReportConfiguration": {
                        "formatSettings": {
                            "str": "str"  # Optional. A dictionary of format settings.
                              The keys are the device information property names for the requested file
                              format.
                        },
                        "identities": [
                            {
                                "username": "str",  # The effective username within a
                                  token that applies row-level security rules. For an on-premises
                                  model, the username can contain alphanumeric or any of the following
                                  characters '.', '-', '_', '!', '#', '^', '~', '""', '@'. For cloud
                                  models, the username can contain any ASCII character. For either
                                  model, the username length must not exceed 256 characters, and the
                                  username shouldn't contain spaces. Required.
                                "customData": "str",  # Optional. `Custom data
                                  </power-bi/developer/embedded/embedded-row-level-security#using-the-customdata-feature>`_
                                  that's used to apply row-level security rules. Supported for live
                                  connection to Azure Analysis Services models and cloud models only.
                                "datasets": [
                                    "str"  # Optional. An array of datasets for
                                      which this identity applies.
                                ],
                                "identityBlob": {
                                    "value": "str"  # An OAuth 2.0 access token
                                      for Azure SQL. Required.
                                },
                                "reports": [
                                    "str"  # Optional. An array of reports for
                                      which this identity applies. Only supported for paginated
                                      reports.
                                ],
                                "roles": [
                                    "str"  # Optional. An array of row-level
                                      security (RLS) roles within a token that applies RLS rules. An
                                      identity can contain up to 50 roles. A role can contain any
                                      character except ``,``"" , and its length must not exceed 50
                                      characters.
                                ]
                            }
                        ],
                        "parameterValues": [
                            {
                                "name": "str",  # Optional. The parameter name.
                                "value": "str"  # Optional. The parameter value.
                            }
                        ]
                    },
                    "powerBIReportConfiguration": {
                        "datasetToBind": "str",  # Optional. The dataset ID to export the
                          report with. Only needed if exporting with a dataset other than the report's
                          default dataset.
                        "defaultBookmark": {
                            "name": "str",  # Optional. The bookmark name.
                            "state": "str"  # Optional. The bookmark state.
                        },
                        "identities": [
                            {
                                "username": "str",  # The effective username within a
                                  token that applies row-level security rules. For an on-premises
                                  model, the username can contain alphanumeric or any of the following
                                  characters '.', '-', '_', '!', '#', '^', '~', '""', '@'. For cloud
                                  models, the username can contain any ASCII character. For either
                                  model, the username length must not exceed 256 characters, and the
                                  username shouldn't contain spaces. Required.
                                "customData": "str",  # Optional. `Custom data
                                  </power-bi/developer/embedded/embedded-row-level-security#using-the-customdata-feature>`_
                                  that's used to apply row-level security rules. Supported for live
                                  connection to Azure Analysis Services models and cloud models only.
                                "datasets": [
                                    "str"  # Optional. An array of datasets for
                                      which this identity applies.
                                ],
                                "identityBlob": {
                                    "value": "str"  # An OAuth 2.0 access token
                                      for Azure SQL. Required.
                                },
                                "reports": [
                                    "str"  # Optional. An array of reports for
                                      which this identity applies. Only supported for paginated
                                      reports.
                                ],
                                "roles": [
                                    "str"  # Optional. An array of row-level
                                      security (RLS) roles within a token that applies RLS rules. An
                                      identity can contain up to 50 roles. A role can contain any
                                      character except ``,``"" , and its length must not exceed 50
                                      characters.
                                ]
                            }
                        ],
                        "pages": [
                            {
                                "pageName": "str",  # The page name. Required.
                                "bookmark": {
                                    "name": "str",  # Optional. The bookmark
                                      name.
                                    "state": "str"  # Optional. The bookmark
                                      state.
                                },
                                "visualName": "str"  # Optional. The name of the
                                  visual to export. Specify a name, in case only a single visual from
                                  this page is exported.
                            }
                        ],
                        "reportLevelFilters": [
                            {
                                "filter": "str"  # Optional. The filter to apply. For
                                  information about the filter syntax, see `Filter a report
                                  </power-bi/collaborate-share/service-url-filters>`_.
                            }
                        ],
                        "settings": {
                            "includeHiddenPages": bool,  # Optional. Whether to include
                              hidden pages when exporting an entire report. If not provided, the
                              default behavior is to exclude hidden pages. This property will be
                              ignored when specific pages are exported.
                            "locale": "str"  # Optional. The locale to apply.
                        }
                    }
                }

                # response body for status code(s): 202
                response == {
                    "ResourceFileExtension": "str",  # Optional. The extension of the exported
                      file.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. The start date and
                      time of the export to file job.
                    "expirationTime": "2020-02-20 00:00:00",  # Optional. The expiration date and
                      time of the retrieval URL.
                    "id": "str",  # Optional. The export to file job ID.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                      of the last change to the export to file job.
                    "percentComplete": 0,  # Optional. Job progress as a percentage.
                    "reportId": "str",  # Optional. The ID of the exported report.
                    "reportName": "str",  # Optional. The name of the exported report.
                    "resourceLocation": "str",  # Optional. The retrieval URL for the exported
                      file.
                    "status": "str"  # Optional. The current state of the export to file job.
                      Known values are: "Undefined", "NotStarted", "Running", "Succeeded", and
                      "Failed".
                }
        """

    @overload
    async def export_to_file(
        self, report_id: str, request_parameters: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Exports the specified report from **My workspace** to the requested `file format
        </rest/api/power-bi/reports/export-to-file#fileformat>`_.

        The API is asynchronous. When the API is called, it triggers an export job. After triggering an
        export job, use `GetExportToFileStatus API
        </rest/api/power-bi/reports/get-export-to-file-status>`_ to track the job status.
        Read more about the entire flow: `Export Power BI reports
        </power-bi/developer/embedded/export-to>`_ and `Export Paginated reports
        </power-bi/developer/embedded/export-paginated-report>`_

        Required Scope
        --------------

        All of the following:


        * Report.ReadWrite.All or Report.Read.All
        * Dataset.ReadWrite.All or Dataset.Read.All

        Limitations
        -----------

        Check the limitations in `Export Power BI report to file
        </power-bi/developer/embedded/export-to#considerations-and-limitations>`_ and `Export paginated
        report to file
        </power-bi/developer/embedded/export-paginated-report#considerations-and-limitations>`_.
        :code:`<br>`:code:`<br>`.

        :param report_id: The report ID. Required.
        :type report_id: str
        :param request_parameters: Export to file request parameters. Required.
        :type request_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 202
                response == {
                    "ResourceFileExtension": "str",  # Optional. The extension of the exported
                      file.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. The start date and
                      time of the export to file job.
                    "expirationTime": "2020-02-20 00:00:00",  # Optional. The expiration date and
                      time of the retrieval URL.
                    "id": "str",  # Optional. The export to file job ID.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                      of the last change to the export to file job.
                    "percentComplete": 0,  # Optional. Job progress as a percentage.
                    "reportId": "str",  # Optional. The ID of the exported report.
                    "reportName": "str",  # Optional. The name of the exported report.
                    "resourceLocation": "str",  # Optional. The retrieval URL for the exported
                      file.
                    "status": "str"  # Optional. The current state of the export to file job.
                      Known values are: "Undefined", "NotStarted", "Running", "Succeeded", and
                      "Failed".
                }
        """

    @distributed_trace_async
    async def export_to_file(self, report_id: str, request_parameters: Union[JSON, IO], **kwargs: Any) -> JSON:
        """Exports the specified report from **My workspace** to the requested `file format
        </rest/api/power-bi/reports/export-to-file#fileformat>`_.

        The API is asynchronous. When the API is called, it triggers an export job. After triggering an
        export job, use `GetExportToFileStatus API
        </rest/api/power-bi/reports/get-export-to-file-status>`_ to track the job status.
        Read more about the entire flow: `Export Power BI reports
        </power-bi/developer/embedded/export-to>`_ and `Export Paginated reports
        </power-bi/developer/embedded/export-paginated-report>`_

        Required Scope
        --------------

        All of the following:


        * Report.ReadWrite.All or Report.Read.All
        * Dataset.ReadWrite.All or Dataset.Read.All

        Limitations
        -----------

        Check the limitations in `Export Power BI report to file
        </power-bi/developer/embedded/export-to#considerations-and-limitations>`_ and `Export paginated
        report to file
        </power-bi/developer/embedded/export-paginated-report#considerations-and-limitations>`_.
        :code:`<br>`:code:`<br>`.

        :param report_id: The report ID. Required.
        :type report_id: str
        :param request_parameters: Export to file request parameters. Is either a JSON type or a IO
         type. Required.
        :type request_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                request_parameters = {
                    "format": "str",  # The requested format for the exported file. Required.
                      Known values are: "PPTX", "PDF", "PNG", "IMAGE", "XLSX", "DOCX", "CSV", "XML",
                      "MHTML", and "ACCESSIBLEPDF".
                    "paginatedReportConfiguration": {
                        "formatSettings": {
                            "str": "str"  # Optional. A dictionary of format settings.
                              The keys are the device information property names for the requested file
                              format.
                        },
                        "identities": [
                            {
                                "username": "str",  # The effective username within a
                                  token that applies row-level security rules. For an on-premises
                                  model, the username can contain alphanumeric or any of the following
                                  characters '.', '-', '_', '!', '#', '^', '~', '""', '@'. For cloud
                                  models, the username can contain any ASCII character. For either
                                  model, the username length must not exceed 256 characters, and the
                                  username shouldn't contain spaces. Required.
                                "customData": "str",  # Optional. `Custom data
                                  </power-bi/developer/embedded/embedded-row-level-security#using-the-customdata-feature>`_
                                  that's used to apply row-level security rules. Supported for live
                                  connection to Azure Analysis Services models and cloud models only.
                                "datasets": [
                                    "str"  # Optional. An array of datasets for
                                      which this identity applies.
                                ],
                                "identityBlob": {
                                    "value": "str"  # An OAuth 2.0 access token
                                      for Azure SQL. Required.
                                },
                                "reports": [
                                    "str"  # Optional. An array of reports for
                                      which this identity applies. Only supported for paginated
                                      reports.
                                ],
                                "roles": [
                                    "str"  # Optional. An array of row-level
                                      security (RLS) roles within a token that applies RLS rules. An
                                      identity can contain up to 50 roles. A role can contain any
                                      character except ``,``"" , and its length must not exceed 50
                                      characters.
                                ]
                            }
                        ],
                        "parameterValues": [
                            {
                                "name": "str",  # Optional. The parameter name.
                                "value": "str"  # Optional. The parameter value.
                            }
                        ]
                    },
                    "powerBIReportConfiguration": {
                        "datasetToBind": "str",  # Optional. The dataset ID to export the
                          report with. Only needed if exporting with a dataset other than the report's
                          default dataset.
                        "defaultBookmark": {
                            "name": "str",  # Optional. The bookmark name.
                            "state": "str"  # Optional. The bookmark state.
                        },
                        "identities": [
                            {
                                "username": "str",  # The effective username within a
                                  token that applies row-level security rules. For an on-premises
                                  model, the username can contain alphanumeric or any of the following
                                  characters '.', '-', '_', '!', '#', '^', '~', '""', '@'. For cloud
                                  models, the username can contain any ASCII character. For either
                                  model, the username length must not exceed 256 characters, and the
                                  username shouldn't contain spaces. Required.
                                "customData": "str",  # Optional. `Custom data
                                  </power-bi/developer/embedded/embedded-row-level-security#using-the-customdata-feature>`_
                                  that's used to apply row-level security rules. Supported for live
                                  connection to Azure Analysis Services models and cloud models only.
                                "datasets": [
                                    "str"  # Optional. An array of datasets for
                                      which this identity applies.
                                ],
                                "identityBlob": {
                                    "value": "str"  # An OAuth 2.0 access token
                                      for Azure SQL. Required.
                                },
                                "reports": [
                                    "str"  # Optional. An array of reports for
                                      which this identity applies. Only supported for paginated
                                      reports.
                                ],
                                "roles": [
                                    "str"  # Optional. An array of row-level
                                      security (RLS) roles within a token that applies RLS rules. An
                                      identity can contain up to 50 roles. A role can contain any
                                      character except ``,``"" , and its length must not exceed 50
                                      characters.
                                ]
                            }
                        ],
                        "pages": [
                            {
                                "pageName": "str",  # The page name. Required.
                                "bookmark": {
                                    "name": "str",  # Optional. The bookmark
                                      name.
                                    "state": "str"  # Optional. The bookmark
                                      state.
                                },
                                "visualName": "str"  # Optional. The name of the
                                  visual to export. Specify a name, in case only a single visual from
                                  this page is exported.
                            }
                        ],
                        "reportLevelFilters": [
                            {
                                "filter": "str"  # Optional. The filter to apply. For
                                  information about the filter syntax, see `Filter a report
                                  </power-bi/collaborate-share/service-url-filters>`_.
                            }
                        ],
                        "settings": {
                            "includeHiddenPages": bool,  # Optional. Whether to include
                              hidden pages when exporting an entire report. If not provided, the
                              default behavior is to exclude hidden pages. This property will be
                              ignored when specific pages are exported.
                            "locale": "str"  # Optional. The locale to apply.
                        }
                    }
                }

                # response body for status code(s): 202
                response == {
                    "ResourceFileExtension": "str",  # Optional. The extension of the exported
                      file.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. The start date and
                      time of the export to file job.
                    "expirationTime": "2020-02-20 00:00:00",  # Optional. The expiration date and
                      time of the retrieval URL.
                    "id": "str",  # Optional. The export to file job ID.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                      of the last change to the export to file job.
                    "percentComplete": 0,  # Optional. Job progress as a percentage.
                    "reportId": "str",  # Optional. The ID of the exported report.
                    "reportName": "str",  # Optional. The name of the exported report.
                    "resourceLocation": "str",  # Optional. The retrieval URL for the exported
                      file.
                    "status": "str"  # Optional. The current state of the export to file job.
                      Known values are: "Undefined", "NotStarted", "Running", "Succeeded", and
                      "Failed".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(request_parameters, (IOBase, bytes)):
            _content = request_parameters
        else:
            _json = request_parameters

        _request = build_reports_export_to_file_request(
            report_id=report_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_export_to_file_status(self, report_id: str, export_id: str, **kwargs: Any) -> JSON:
        """Returns the current status of the `Export to File </rest/api/power-bi/reports/export-to-file>`_
        job for the specified report from **My workspace**.

        When the export job status is 'Succeeded' use the `GetFileOfExportToFile API
        </rest/api/power-bi/reports/get-file-of-export-to-file>`_ to retrieve the file.

        Required Scope
        --------------

        Report.ReadWrite.All or Report.Read.All
        :code:`<br>`:code:`<br>`.

        :param report_id: The report ID. Required.
        :type report_id: str
        :param export_id: The export ID. Required.
        :type export_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 202
                response == {
                    "ResourceFileExtension": "str",  # Optional. The extension of the exported
                      file.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. The start date and
                      time of the export to file job.
                    "expirationTime": "2020-02-20 00:00:00",  # Optional. The expiration date and
                      time of the retrieval URL.
                    "id": "str",  # Optional. The export to file job ID.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                      of the last change to the export to file job.
                    "percentComplete": 0,  # Optional. Job progress as a percentage.
                    "reportId": "str",  # Optional. The ID of the exported report.
                    "reportName": "str",  # Optional. The name of the exported report.
                    "resourceLocation": "str",  # Optional. The retrieval URL for the exported
                      file.
                    "status": "str"  # Optional. The current state of the export to file job.
                      Known values are: "Undefined", "NotStarted", "Running", "Succeeded", and
                      "Failed".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_reports_get_export_to_file_status_request(
            report_id=report_id,
            export_id=export_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 202:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_file_of_export_to_file(self, report_id: str, export_id: str, **kwargs: Any) -> AsyncIterator[bytes]:
        """Returns the file from the `Export to File </rest/api/power-bi/reports/export-to-file>`_ job for
        the specified report from **My workspace**.

        Required Scope
        --------------

        Report.ReadWrite.All or Report.Read.All
        :code:`<br>`:code:`<br>`.

        :param report_id: The report ID. Required.
        :type report_id: str
        :param export_id: The export ID. Required.
        :type export_id: str
        :return: Async iterator of the response bytes
        :rtype: AsyncIterator[bytes]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        _request = build_reports_get_file_of_export_to_file_request(
            report_id=report_id,
            export_id=export_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 200, 200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = response.iter_bytes()

        if response.status_code == 200:
            deserialized = response.iter_bytes()

        if response.status_code == 200:
            deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, cast(AsyncIterator[bytes], deserialized), {})  # type: ignore

        return cast(AsyncIterator[bytes], deserialized)  # type: ignore

    @distributed_trace_async
    async def get_reports_in_group(self, group_id: str, **kwargs: Any) -> JSON:
        """Returns a list of reports from the specified workspace.

        Since paginated reports (RDL) don't have a dataset, the dataset ID value in the API response
        for paginated reports isn't displayed.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Report.ReadWrite.All or Report.Read.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional. OData context.
                    "value": [
                        {
                            "id": "str",  # The report ID. Required.
                            "appId": "str",  # Optional. The app ID, returned only if the
                              report belongs to an app.
                            "datasetId": "str",  # Optional. The dataset ID of the
                              report.
                            "description": "str",  # Optional. The report description.
                            "embedUrl": "str",  # Optional. The embed URL of the report.
                            "name": "str",  # Optional. The name of the report.
                            "reportType": "str",  # Optional. The report type.
                              "PaginatedReport"
                            "subscriptions": [
                                {
                                    "id": "str",  # The subscription ID.
                                      Required.
                                    "artifactDisplayName": "str",  # Optional.
                                      The name of the subscribed Power BI item (such as a report or a
                                      dashboard).
                                    "artifactId": "str",  # Optional. The ID of
                                      the subscribed Power BI item (such as a report or a dashboard).
                                    "artifactType": "str",  # Optional. The type
                                      of Power BI item (for example a ``Report``"" , ``Dashboard``"" ,
                                      or ``Dataset``"" ).
                                    "attachmentFormat": "str",  # Optional.
                                      Format of the report attached in the email subscription.
                                    "endDate": "2020-02-20 00:00:00",  #
                                      Optional. The end date and time of the email subscription.
                                    "frequency": "str",  # Optional. The
                                      frequency of the email subscription.
                                    "isEnabled": bool,  # Optional. Whether the
                                      email subscription is enabled.
                                    "linkToContent": bool,  # Optional. Whether a
                                      subscription link exists in the email subscription.
                                    "previewImage": bool,  # Optional. Whether a
                                      screenshot of the report exists in the email subscription.
                                    "startDate": "2020-02-20 00:00:00",  #
                                      Optional. The start date and time of the email subscription.
                                    "subArtifactDisplayName": "str",  # Optional.
                                      The page name of the subscribed Power BI item, if it's a report.
                                    "title": "str",  # Optional. The app name.
                                    "users": [
                                        {
                                            "identifier": "str",  #
                                              Identifier of the principal. Required.
                                            "principalType": "str",  #
                                              The principal type. Required. Known values are: "None",
                                              "User", "Group", and "App".
                                            "displayName": "str",  #
                                              Optional. Display name of the principal.
                                            "emailAddress": "str",  #
                                              Optional. Email address of the user.
                                            "graphId": "str",  #
                                              Optional. Identifier of the principal in Microsoft Graph.
                                              Only available for admin APIs.
                                            "profile": {
                                                "id": "str",  # The
                                                  service principal profile ID. Required.
                                                "displayName": "str"
                                                  # Optional. The service principal profile name.
                                            },
                                            "userType": "str"  #
                                              Optional. Type of the user.
                                        }
                                    ]
                                }
                            ],
                            "users": [
                                {
                                    "identifier": "str",  # Identifier of the
                                      principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "reportUserAccessRight": "str",  # The access
                                      right that the user has for the report (permission level).
                                      Required. Known values are: "None", "Read", "ReadWrite",
                                      "ReadReshare", "ReadCopy", and "Owner".
                                    "displayName": "str",  # Optional. Display
                                      name of the principal.
                                    "emailAddress": "str",  # Optional. Email
                                      address of the user.
                                    "graphId": "str",  # Optional. Identifier of
                                      the principal in Microsoft Graph. Only available for admin APIs.
                                    "profile": {
                                        "id": "str",  # The service principal
                                          profile ID. Required.
                                        "displayName": "str"  # Optional. The
                                          service principal profile name.
                                    },
                                    "userType": "str"  # Optional. Type of the
                                      user.
                                }
                            ],
                            "webUrl": "str"  # Optional. The web URL of the report.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_reports_get_reports_in_group_request(
            group_id=group_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_report_in_group(self, group_id: str, report_id: str, **kwargs: Any) -> JSON:
        """Returns the specified report from the specified workspace.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Report.ReadWrite.All or Report.Read.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param report_id: The report ID. Required.
        :type report_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # The report ID. Required.
                    "appId": "str",  # Optional. The app ID, returned only if the report belongs
                      to an app.
                    "datasetId": "str",  # Optional. The dataset ID of the report.
                    "description": "str",  # Optional. The report description.
                    "embedUrl": "str",  # Optional. The embed URL of the report.
                    "name": "str",  # Optional. The name of the report.
                    "reportType": "str",  # Optional. The report type. "PaginatedReport"
                    "subscriptions": [
                        {
                            "id": "str",  # The subscription ID. Required.
                            "artifactDisplayName": "str",  # Optional. The name of the
                              subscribed Power BI item (such as a report or a dashboard).
                            "artifactId": "str",  # Optional. The ID of the subscribed
                              Power BI item (such as a report or a dashboard).
                            "artifactType": "str",  # Optional. The type of Power BI item
                              (for example a ``Report``"" , ``Dashboard``"" , or ``Dataset``"" ).
                            "attachmentFormat": "str",  # Optional. Format of the report
                              attached in the email subscription.
                            "endDate": "2020-02-20 00:00:00",  # Optional. The end date
                              and time of the email subscription.
                            "frequency": "str",  # Optional. The frequency of the email
                              subscription.
                            "isEnabled": bool,  # Optional. Whether the email
                              subscription is enabled.
                            "linkToContent": bool,  # Optional. Whether a subscription
                              link exists in the email subscription.
                            "previewImage": bool,  # Optional. Whether a screenshot of
                              the report exists in the email subscription.
                            "startDate": "2020-02-20 00:00:00",  # Optional. The start
                              date and time of the email subscription.
                            "subArtifactDisplayName": "str",  # Optional. The page name
                              of the subscribed Power BI item, if it's a report.
                            "title": "str",  # Optional. The app name.
                            "users": [
                                {
                                    "identifier": "str",  # Identifier of the
                                      principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "displayName": "str",  # Optional. Display
                                      name of the principal.
                                    "emailAddress": "str",  # Optional. Email
                                      address of the user.
                                    "graphId": "str",  # Optional. Identifier of
                                      the principal in Microsoft Graph. Only available for admin APIs.
                                    "profile": {
                                        "id": "str",  # The service principal
                                          profile ID. Required.
                                        "displayName": "str"  # Optional. The
                                          service principal profile name.
                                    },
                                    "userType": "str"  # Optional. Type of the
                                      user.
                                }
                            ]
                        }
                    ],
                    "users": [
                        {
                            "identifier": "str",  # Identifier of the principal.
                              Required.
                            "principalType": "str",  # The principal type. Required.
                              Known values are: "None", "User", "Group", and "App".
                            "reportUserAccessRight": "str",  # The access right that the
                              user has for the report (permission level). Required. Known values are:
                              "None", "Read", "ReadWrite", "ReadReshare", "ReadCopy", and "Owner".
                            "displayName": "str",  # Optional. Display name of the
                              principal.
                            "emailAddress": "str",  # Optional. Email address of the
                              user.
                            "graphId": "str",  # Optional. Identifier of the principal in
                              Microsoft Graph. Only available for admin APIs.
                            "profile": {
                                "id": "str",  # The service principal profile ID.
                                  Required.
                                "displayName": "str"  # Optional. The service
                                  principal profile name.
                            },
                            "userType": "str"  # Optional. Type of the user.
                        }
                    ],
                    "webUrl": "str"  # Optional. The web URL of the report.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_reports_get_report_in_group_request(
            group_id=group_id,
            report_id=report_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def delete_report_in_group(  # pylint: disable=inconsistent-return-statements
        self, group_id: str, report_id: str, **kwargs: Any
    ) -> None:
        """Deletes the specified report from the specified workspace.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Report.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param report_id: The report ID. Required.
        :type report_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_reports_delete_report_in_group_request(
            group_id=group_id,
            report_id=report_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def clone_report_in_group(
        self,
        group_id: str,
        report_id: str,
        request_parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Clones the specified report from the specified workspace.

        * If the dataset for a cloned report resides in two different workspaces or in **My
        workspace**\ , then a shared dataset will be created in the report's workspace.
        * When cloned, reports with a `live connection </power-bi/desktop-report-lifecycle-datasets>`_
        will lose that connection and instead have a direct binding to the target dataset.

        Permissions
        -----------


        *
          The user must have all of the following, unless a requirement doesn't apply:


          * **Write** permission on the specified report.
          * **Build** permission on the target dataset, required if the ``targetModelId`` parameter is
        used.

        *
          This API call can be called by a service principal profile. For more information see:
        `Service principal profiles in Power BI Embedded
        </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Content.Create
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param report_id: The report ID. Required.
        :type report_id: str
        :param request_parameters: Clone report parameters. Required.
        :type request_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                request_parameters = {
                    "name": "str",  # The new report name. Required.
                    "targetModelId": "str",  # Optional. Optional. Parameter for specifying the
                      target associated dataset ID. If not provided, the new report will be associated
                      with the same dataset as the source report.
                    "targetWorkspaceId": "str"  # Optional. Optional. Parameter for specifying
                      the target workspace ID. An empty GUID (""
                      ``00000000-0000-0000-0000-000000000000``"" ) indicates **My workspace**. If this
                      parameter isn't provided, the new report will be cloned within the same workspace
                      as the source report.
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # The report ID. Required.
                    "appId": "str",  # Optional. The app ID, returned only if the report belongs
                      to an app.
                    "datasetId": "str",  # Optional. The dataset ID of the report.
                    "description": "str",  # Optional. The report description.
                    "embedUrl": "str",  # Optional. The embed URL of the report.
                    "name": "str",  # Optional. The name of the report.
                    "reportType": "str",  # Optional. The report type. "PaginatedReport"
                    "subscriptions": [
                        {
                            "id": "str",  # The subscription ID. Required.
                            "artifactDisplayName": "str",  # Optional. The name of the
                              subscribed Power BI item (such as a report or a dashboard).
                            "artifactId": "str",  # Optional. The ID of the subscribed
                              Power BI item (such as a report or a dashboard).
                            "artifactType": "str",  # Optional. The type of Power BI item
                              (for example a ``Report``"" , ``Dashboard``"" , or ``Dataset``"" ).
                            "attachmentFormat": "str",  # Optional. Format of the report
                              attached in the email subscription.
                            "endDate": "2020-02-20 00:00:00",  # Optional. The end date
                              and time of the email subscription.
                            "frequency": "str",  # Optional. The frequency of the email
                              subscription.
                            "isEnabled": bool,  # Optional. Whether the email
                              subscription is enabled.
                            "linkToContent": bool,  # Optional. Whether a subscription
                              link exists in the email subscription.
                            "previewImage": bool,  # Optional. Whether a screenshot of
                              the report exists in the email subscription.
                            "startDate": "2020-02-20 00:00:00",  # Optional. The start
                              date and time of the email subscription.
                            "subArtifactDisplayName": "str",  # Optional. The page name
                              of the subscribed Power BI item, if it's a report.
                            "title": "str",  # Optional. The app name.
                            "users": [
                                {
                                    "identifier": "str",  # Identifier of the
                                      principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "displayName": "str",  # Optional. Display
                                      name of the principal.
                                    "emailAddress": "str",  # Optional. Email
                                      address of the user.
                                    "graphId": "str",  # Optional. Identifier of
                                      the principal in Microsoft Graph. Only available for admin APIs.
                                    "profile": {
                                        "id": "str",  # The service principal
                                          profile ID. Required.
                                        "displayName": "str"  # Optional. The
                                          service principal profile name.
                                    },
                                    "userType": "str"  # Optional. Type of the
                                      user.
                                }
                            ]
                        }
                    ],
                    "users": [
                        {
                            "identifier": "str",  # Identifier of the principal.
                              Required.
                            "principalType": "str",  # The principal type. Required.
                              Known values are: "None", "User", "Group", and "App".
                            "reportUserAccessRight": "str",  # The access right that the
                              user has for the report (permission level). Required. Known values are:
                              "None", "Read", "ReadWrite", "ReadReshare", "ReadCopy", and "Owner".
                            "displayName": "str",  # Optional. Display name of the
                              principal.
                            "emailAddress": "str",  # Optional. Email address of the
                              user.
                            "graphId": "str",  # Optional. Identifier of the principal in
                              Microsoft Graph. Only available for admin APIs.
                            "profile": {
                                "id": "str",  # The service principal profile ID.
                                  Required.
                                "displayName": "str"  # Optional. The service
                                  principal profile name.
                            },
                            "userType": "str"  # Optional. Type of the user.
                        }
                    ],
                    "webUrl": "str"  # Optional. The web URL of the report.
                }
        """

    @overload
    async def clone_report_in_group(
        self,
        group_id: str,
        report_id: str,
        request_parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Clones the specified report from the specified workspace.

        * If the dataset for a cloned report resides in two different workspaces or in **My
        workspace**\ , then a shared dataset will be created in the report's workspace.
        * When cloned, reports with a `live connection </power-bi/desktop-report-lifecycle-datasets>`_
        will lose that connection and instead have a direct binding to the target dataset.

        Permissions
        -----------


        *
          The user must have all of the following, unless a requirement doesn't apply:


          * **Write** permission on the specified report.
          * **Build** permission on the target dataset, required if the ``targetModelId`` parameter is
        used.

        *
          This API call can be called by a service principal profile. For more information see:
        `Service principal profiles in Power BI Embedded
        </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Content.Create
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param report_id: The report ID. Required.
        :type report_id: str
        :param request_parameters: Clone report parameters. Required.
        :type request_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # The report ID. Required.
                    "appId": "str",  # Optional. The app ID, returned only if the report belongs
                      to an app.
                    "datasetId": "str",  # Optional. The dataset ID of the report.
                    "description": "str",  # Optional. The report description.
                    "embedUrl": "str",  # Optional. The embed URL of the report.
                    "name": "str",  # Optional. The name of the report.
                    "reportType": "str",  # Optional. The report type. "PaginatedReport"
                    "subscriptions": [
                        {
                            "id": "str",  # The subscription ID. Required.
                            "artifactDisplayName": "str",  # Optional. The name of the
                              subscribed Power BI item (such as a report or a dashboard).
                            "artifactId": "str",  # Optional. The ID of the subscribed
                              Power BI item (such as a report or a dashboard).
                            "artifactType": "str",  # Optional. The type of Power BI item
                              (for example a ``Report``"" , ``Dashboard``"" , or ``Dataset``"" ).
                            "attachmentFormat": "str",  # Optional. Format of the report
                              attached in the email subscription.
                            "endDate": "2020-02-20 00:00:00",  # Optional. The end date
                              and time of the email subscription.
                            "frequency": "str",  # Optional. The frequency of the email
                              subscription.
                            "isEnabled": bool,  # Optional. Whether the email
                              subscription is enabled.
                            "linkToContent": bool,  # Optional. Whether a subscription
                              link exists in the email subscription.
                            "previewImage": bool,  # Optional. Whether a screenshot of
                              the report exists in the email subscription.
                            "startDate": "2020-02-20 00:00:00",  # Optional. The start
                              date and time of the email subscription.
                            "subArtifactDisplayName": "str",  # Optional. The page name
                              of the subscribed Power BI item, if it's a report.
                            "title": "str",  # Optional. The app name.
                            "users": [
                                {
                                    "identifier": "str",  # Identifier of the
                                      principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "displayName": "str",  # Optional. Display
                                      name of the principal.
                                    "emailAddress": "str",  # Optional. Email
                                      address of the user.
                                    "graphId": "str",  # Optional. Identifier of
                                      the principal in Microsoft Graph. Only available for admin APIs.
                                    "profile": {
                                        "id": "str",  # The service principal
                                          profile ID. Required.
                                        "displayName": "str"  # Optional. The
                                          service principal profile name.
                                    },
                                    "userType": "str"  # Optional. Type of the
                                      user.
                                }
                            ]
                        }
                    ],
                    "users": [
                        {
                            "identifier": "str",  # Identifier of the principal.
                              Required.
                            "principalType": "str",  # The principal type. Required.
                              Known values are: "None", "User", "Group", and "App".
                            "reportUserAccessRight": "str",  # The access right that the
                              user has for the report (permission level). Required. Known values are:
                              "None", "Read", "ReadWrite", "ReadReshare", "ReadCopy", and "Owner".
                            "displayName": "str",  # Optional. Display name of the
                              principal.
                            "emailAddress": "str",  # Optional. Email address of the
                              user.
                            "graphId": "str",  # Optional. Identifier of the principal in
                              Microsoft Graph. Only available for admin APIs.
                            "profile": {
                                "id": "str",  # The service principal profile ID.
                                  Required.
                                "displayName": "str"  # Optional. The service
                                  principal profile name.
                            },
                            "userType": "str"  # Optional. Type of the user.
                        }
                    ],
                    "webUrl": "str"  # Optional. The web URL of the report.
                }
        """

    @distributed_trace_async
    async def clone_report_in_group(
        self, group_id: str, report_id: str, request_parameters: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Clones the specified report from the specified workspace.

        * If the dataset for a cloned report resides in two different workspaces or in **My
        workspace**\ , then a shared dataset will be created in the report's workspace.
        * When cloned, reports with a `live connection </power-bi/desktop-report-lifecycle-datasets>`_
        will lose that connection and instead have a direct binding to the target dataset.

        Permissions
        -----------


        *
          The user must have all of the following, unless a requirement doesn't apply:


          * **Write** permission on the specified report.
          * **Build** permission on the target dataset, required if the ``targetModelId`` parameter is
        used.

        *
          This API call can be called by a service principal profile. For more information see:
        `Service principal profiles in Power BI Embedded
        </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Content.Create
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param report_id: The report ID. Required.
        :type report_id: str
        :param request_parameters: Clone report parameters. Is either a JSON type or a IO type.
         Required.
        :type request_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                request_parameters = {
                    "name": "str",  # The new report name. Required.
                    "targetModelId": "str",  # Optional. Optional. Parameter for specifying the
                      target associated dataset ID. If not provided, the new report will be associated
                      with the same dataset as the source report.
                    "targetWorkspaceId": "str"  # Optional. Optional. Parameter for specifying
                      the target workspace ID. An empty GUID (""
                      ``00000000-0000-0000-0000-000000000000``"" ) indicates **My workspace**. If this
                      parameter isn't provided, the new report will be cloned within the same workspace
                      as the source report.
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # The report ID. Required.
                    "appId": "str",  # Optional. The app ID, returned only if the report belongs
                      to an app.
                    "datasetId": "str",  # Optional. The dataset ID of the report.
                    "description": "str",  # Optional. The report description.
                    "embedUrl": "str",  # Optional. The embed URL of the report.
                    "name": "str",  # Optional. The name of the report.
                    "reportType": "str",  # Optional. The report type. "PaginatedReport"
                    "subscriptions": [
                        {
                            "id": "str",  # The subscription ID. Required.
                            "artifactDisplayName": "str",  # Optional. The name of the
                              subscribed Power BI item (such as a report or a dashboard).
                            "artifactId": "str",  # Optional. The ID of the subscribed
                              Power BI item (such as a report or a dashboard).
                            "artifactType": "str",  # Optional. The type of Power BI item
                              (for example a ``Report``"" , ``Dashboard``"" , or ``Dataset``"" ).
                            "attachmentFormat": "str",  # Optional. Format of the report
                              attached in the email subscription.
                            "endDate": "2020-02-20 00:00:00",  # Optional. The end date
                              and time of the email subscription.
                            "frequency": "str",  # Optional. The frequency of the email
                              subscription.
                            "isEnabled": bool,  # Optional. Whether the email
                              subscription is enabled.
                            "linkToContent": bool,  # Optional. Whether a subscription
                              link exists in the email subscription.
                            "previewImage": bool,  # Optional. Whether a screenshot of
                              the report exists in the email subscription.
                            "startDate": "2020-02-20 00:00:00",  # Optional. The start
                              date and time of the email subscription.
                            "subArtifactDisplayName": "str",  # Optional. The page name
                              of the subscribed Power BI item, if it's a report.
                            "title": "str",  # Optional. The app name.
                            "users": [
                                {
                                    "identifier": "str",  # Identifier of the
                                      principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "displayName": "str",  # Optional. Display
                                      name of the principal.
                                    "emailAddress": "str",  # Optional. Email
                                      address of the user.
                                    "graphId": "str",  # Optional. Identifier of
                                      the principal in Microsoft Graph. Only available for admin APIs.
                                    "profile": {
                                        "id": "str",  # The service principal
                                          profile ID. Required.
                                        "displayName": "str"  # Optional. The
                                          service principal profile name.
                                    },
                                    "userType": "str"  # Optional. Type of the
                                      user.
                                }
                            ]
                        }
                    ],
                    "users": [
                        {
                            "identifier": "str",  # Identifier of the principal.
                              Required.
                            "principalType": "str",  # The principal type. Required.
                              Known values are: "None", "User", "Group", and "App".
                            "reportUserAccessRight": "str",  # The access right that the
                              user has for the report (permission level). Required. Known values are:
                              "None", "Read", "ReadWrite", "ReadReshare", "ReadCopy", and "Owner".
                            "displayName": "str",  # Optional. Display name of the
                              principal.
                            "emailAddress": "str",  # Optional. Email address of the
                              user.
                            "graphId": "str",  # Optional. Identifier of the principal in
                              Microsoft Graph. Only available for admin APIs.
                            "profile": {
                                "id": "str",  # The service principal profile ID.
                                  Required.
                                "displayName": "str"  # Optional. The service
                                  principal profile name.
                            },
                            "userType": "str"  # Optional. Type of the user.
                        }
                    ],
                    "webUrl": "str"  # Optional. The web URL of the report.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(request_parameters, (IOBase, bytes)):
            _content = request_parameters
        else:
            _json = request_parameters

        _request = build_reports_clone_report_in_group_request(
            group_id=group_id,
            report_id=report_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def export_report_in_group(self, group_id: str, report_id: str, **kwargs: Any) -> AsyncIterator[bytes]:
        """Exports the specified report from the specified workspace to a Power BI .pbix or .rdl file.

        * For .pbix reports -
          You can set the ``preferClientRouting`` URL query parameter to ``true`` as a `workaround
        </power-bi/developer/embedded/troubleshoot-rest-api#fix-timeout-exceptions-when-using-import-and-export-apis>`_
        for timeout issues.
        * Large files are downloaded to a temporary blob. Their URL is returned in the response and
        stored in the locally downloaded Power BI .pbix file.
        * For more information on requirements and limitations, see `Download a report from the Power
        BI service to Power BI Desktop </power-bi/create-reports/service-export-to-pbix>`_.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Report.ReadWrite.All or both Report.Read.All and Dataset.Read.All

        Limitations
        -----------

        For .pbix reports, exporting a report with a `Power BI service live connection
        </power-bi/desktop-report-lifecycle-datasets>`_ isn't supported after calling `Rebind Report
        </rest/api/power-bi/reports/rebind-report>`_.
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param report_id: The report ID. Required.
        :type report_id: str
        :return: Async iterator of the response bytes
        :rtype: AsyncIterator[bytes]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        _request = build_reports_export_report_in_group_request(
            group_id=group_id,
            report_id=report_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, cast(AsyncIterator[bytes], deserialized), {})  # type: ignore

        return cast(AsyncIterator[bytes], deserialized)  # type: ignore

    @overload
    async def update_report_content_in_group(
        self,
        group_id: str,
        report_id: str,
        request_parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Updates the content of the specified report from the specified workspace with the content of a
        specified source report.

        Specify the source report in the request body.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Report.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param report_id: The report ID. Required.
        :type report_id: str
        :param request_parameters: UpdateReportContent parameters. Required.
        :type request_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                request_parameters = {
                    "sourceReport": {
                        "sourceReportId": "str",  # The source report ID. Required.
                        "sourceWorkspaceId": "str"  # Optional. The source workspace ID.
                    },
                    "sourceType": "ExistingReport"  # Default value is "ExistingReport". The
                      source type of the content update. Required.
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # The report ID. Required.
                    "appId": "str",  # Optional. The app ID, returned only if the report belongs
                      to an app.
                    "datasetId": "str",  # Optional. The dataset ID of the report.
                    "description": "str",  # Optional. The report description.
                    "embedUrl": "str",  # Optional. The embed URL of the report.
                    "name": "str",  # Optional. The name of the report.
                    "reportType": "str",  # Optional. The report type. "PaginatedReport"
                    "subscriptions": [
                        {
                            "id": "str",  # The subscription ID. Required.
                            "artifactDisplayName": "str",  # Optional. The name of the
                              subscribed Power BI item (such as a report or a dashboard).
                            "artifactId": "str",  # Optional. The ID of the subscribed
                              Power BI item (such as a report or a dashboard).
                            "artifactType": "str",  # Optional. The type of Power BI item
                              (for example a ``Report``"" , ``Dashboard``"" , or ``Dataset``"" ).
                            "attachmentFormat": "str",  # Optional. Format of the report
                              attached in the email subscription.
                            "endDate": "2020-02-20 00:00:00",  # Optional. The end date
                              and time of the email subscription.
                            "frequency": "str",  # Optional. The frequency of the email
                              subscription.
                            "isEnabled": bool,  # Optional. Whether the email
                              subscription is enabled.
                            "linkToContent": bool,  # Optional. Whether a subscription
                              link exists in the email subscription.
                            "previewImage": bool,  # Optional. Whether a screenshot of
                              the report exists in the email subscription.
                            "startDate": "2020-02-20 00:00:00",  # Optional. The start
                              date and time of the email subscription.
                            "subArtifactDisplayName": "str",  # Optional. The page name
                              of the subscribed Power BI item, if it's a report.
                            "title": "str",  # Optional. The app name.
                            "users": [
                                {
                                    "identifier": "str",  # Identifier of the
                                      principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "displayName": "str",  # Optional. Display
                                      name of the principal.
                                    "emailAddress": "str",  # Optional. Email
                                      address of the user.
                                    "graphId": "str",  # Optional. Identifier of
                                      the principal in Microsoft Graph. Only available for admin APIs.
                                    "profile": {
                                        "id": "str",  # The service principal
                                          profile ID. Required.
                                        "displayName": "str"  # Optional. The
                                          service principal profile name.
                                    },
                                    "userType": "str"  # Optional. Type of the
                                      user.
                                }
                            ]
                        }
                    ],
                    "users": [
                        {
                            "identifier": "str",  # Identifier of the principal.
                              Required.
                            "principalType": "str",  # The principal type. Required.
                              Known values are: "None", "User", "Group", and "App".
                            "reportUserAccessRight": "str",  # The access right that the
                              user has for the report (permission level). Required. Known values are:
                              "None", "Read", "ReadWrite", "ReadReshare", "ReadCopy", and "Owner".
                            "displayName": "str",  # Optional. Display name of the
                              principal.
                            "emailAddress": "str",  # Optional. Email address of the
                              user.
                            "graphId": "str",  # Optional. Identifier of the principal in
                              Microsoft Graph. Only available for admin APIs.
                            "profile": {
                                "id": "str",  # The service principal profile ID.
                                  Required.
                                "displayName": "str"  # Optional. The service
                                  principal profile name.
                            },
                            "userType": "str"  # Optional. Type of the user.
                        }
                    ],
                    "webUrl": "str"  # Optional. The web URL of the report.
                }
        """

    @overload
    async def update_report_content_in_group(
        self,
        group_id: str,
        report_id: str,
        request_parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Updates the content of the specified report from the specified workspace with the content of a
        specified source report.

        Specify the source report in the request body.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Report.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param report_id: The report ID. Required.
        :type report_id: str
        :param request_parameters: UpdateReportContent parameters. Required.
        :type request_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # The report ID. Required.
                    "appId": "str",  # Optional. The app ID, returned only if the report belongs
                      to an app.
                    "datasetId": "str",  # Optional. The dataset ID of the report.
                    "description": "str",  # Optional. The report description.
                    "embedUrl": "str",  # Optional. The embed URL of the report.
                    "name": "str",  # Optional. The name of the report.
                    "reportType": "str",  # Optional. The report type. "PaginatedReport"
                    "subscriptions": [
                        {
                            "id": "str",  # The subscription ID. Required.
                            "artifactDisplayName": "str",  # Optional. The name of the
                              subscribed Power BI item (such as a report or a dashboard).
                            "artifactId": "str",  # Optional. The ID of the subscribed
                              Power BI item (such as a report or a dashboard).
                            "artifactType": "str",  # Optional. The type of Power BI item
                              (for example a ``Report``"" , ``Dashboard``"" , or ``Dataset``"" ).
                            "attachmentFormat": "str",  # Optional. Format of the report
                              attached in the email subscription.
                            "endDate": "2020-02-20 00:00:00",  # Optional. The end date
                              and time of the email subscription.
                            "frequency": "str",  # Optional. The frequency of the email
                              subscription.
                            "isEnabled": bool,  # Optional. Whether the email
                              subscription is enabled.
                            "linkToContent": bool,  # Optional. Whether a subscription
                              link exists in the email subscription.
                            "previewImage": bool,  # Optional. Whether a screenshot of
                              the report exists in the email subscription.
                            "startDate": "2020-02-20 00:00:00",  # Optional. The start
                              date and time of the email subscription.
                            "subArtifactDisplayName": "str",  # Optional. The page name
                              of the subscribed Power BI item, if it's a report.
                            "title": "str",  # Optional. The app name.
                            "users": [
                                {
                                    "identifier": "str",  # Identifier of the
                                      principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "displayName": "str",  # Optional. Display
                                      name of the principal.
                                    "emailAddress": "str",  # Optional. Email
                                      address of the user.
                                    "graphId": "str",  # Optional. Identifier of
                                      the principal in Microsoft Graph. Only available for admin APIs.
                                    "profile": {
                                        "id": "str",  # The service principal
                                          profile ID. Required.
                                        "displayName": "str"  # Optional. The
                                          service principal profile name.
                                    },
                                    "userType": "str"  # Optional. Type of the
                                      user.
                                }
                            ]
                        }
                    ],
                    "users": [
                        {
                            "identifier": "str",  # Identifier of the principal.
                              Required.
                            "principalType": "str",  # The principal type. Required.
                              Known values are: "None", "User", "Group", and "App".
                            "reportUserAccessRight": "str",  # The access right that the
                              user has for the report (permission level). Required. Known values are:
                              "None", "Read", "ReadWrite", "ReadReshare", "ReadCopy", and "Owner".
                            "displayName": "str",  # Optional. Display name of the
                              principal.
                            "emailAddress": "str",  # Optional. Email address of the
                              user.
                            "graphId": "str",  # Optional. Identifier of the principal in
                              Microsoft Graph. Only available for admin APIs.
                            "profile": {
                                "id": "str",  # The service principal profile ID.
                                  Required.
                                "displayName": "str"  # Optional. The service
                                  principal profile name.
                            },
                            "userType": "str"  # Optional. Type of the user.
                        }
                    ],
                    "webUrl": "str"  # Optional. The web URL of the report.
                }
        """

    @distributed_trace_async
    async def update_report_content_in_group(
        self, group_id: str, report_id: str, request_parameters: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Updates the content of the specified report from the specified workspace with the content of a
        specified source report.

        Specify the source report in the request body.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Report.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param report_id: The report ID. Required.
        :type report_id: str
        :param request_parameters: UpdateReportContent parameters. Is either a JSON type or a IO type.
         Required.
        :type request_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                request_parameters = {
                    "sourceReport": {
                        "sourceReportId": "str",  # The source report ID. Required.
                        "sourceWorkspaceId": "str"  # Optional. The source workspace ID.
                    },
                    "sourceType": "ExistingReport"  # Default value is "ExistingReport". The
                      source type of the content update. Required.
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # The report ID. Required.
                    "appId": "str",  # Optional. The app ID, returned only if the report belongs
                      to an app.
                    "datasetId": "str",  # Optional. The dataset ID of the report.
                    "description": "str",  # Optional. The report description.
                    "embedUrl": "str",  # Optional. The embed URL of the report.
                    "name": "str",  # Optional. The name of the report.
                    "reportType": "str",  # Optional. The report type. "PaginatedReport"
                    "subscriptions": [
                        {
                            "id": "str",  # The subscription ID. Required.
                            "artifactDisplayName": "str",  # Optional. The name of the
                              subscribed Power BI item (such as a report or a dashboard).
                            "artifactId": "str",  # Optional. The ID of the subscribed
                              Power BI item (such as a report or a dashboard).
                            "artifactType": "str",  # Optional. The type of Power BI item
                              (for example a ``Report``"" , ``Dashboard``"" , or ``Dataset``"" ).
                            "attachmentFormat": "str",  # Optional. Format of the report
                              attached in the email subscription.
                            "endDate": "2020-02-20 00:00:00",  # Optional. The end date
                              and time of the email subscription.
                            "frequency": "str",  # Optional. The frequency of the email
                              subscription.
                            "isEnabled": bool,  # Optional. Whether the email
                              subscription is enabled.
                            "linkToContent": bool,  # Optional. Whether a subscription
                              link exists in the email subscription.
                            "previewImage": bool,  # Optional. Whether a screenshot of
                              the report exists in the email subscription.
                            "startDate": "2020-02-20 00:00:00",  # Optional. The start
                              date and time of the email subscription.
                            "subArtifactDisplayName": "str",  # Optional. The page name
                              of the subscribed Power BI item, if it's a report.
                            "title": "str",  # Optional. The app name.
                            "users": [
                                {
                                    "identifier": "str",  # Identifier of the
                                      principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "displayName": "str",  # Optional. Display
                                      name of the principal.
                                    "emailAddress": "str",  # Optional. Email
                                      address of the user.
                                    "graphId": "str",  # Optional. Identifier of
                                      the principal in Microsoft Graph. Only available for admin APIs.
                                    "profile": {
                                        "id": "str",  # The service principal
                                          profile ID. Required.
                                        "displayName": "str"  # Optional. The
                                          service principal profile name.
                                    },
                                    "userType": "str"  # Optional. Type of the
                                      user.
                                }
                            ]
                        }
                    ],
                    "users": [
                        {
                            "identifier": "str",  # Identifier of the principal.
                              Required.
                            "principalType": "str",  # The principal type. Required.
                              Known values are: "None", "User", "Group", and "App".
                            "reportUserAccessRight": "str",  # The access right that the
                              user has for the report (permission level). Required. Known values are:
                              "None", "Read", "ReadWrite", "ReadReshare", "ReadCopy", and "Owner".
                            "displayName": "str",  # Optional. Display name of the
                              principal.
                            "emailAddress": "str",  # Optional. Email address of the
                              user.
                            "graphId": "str",  # Optional. Identifier of the principal in
                              Microsoft Graph. Only available for admin APIs.
                            "profile": {
                                "id": "str",  # The service principal profile ID.
                                  Required.
                                "displayName": "str"  # Optional. The service
                                  principal profile name.
                            },
                            "userType": "str"  # Optional. Type of the user.
                        }
                    ],
                    "webUrl": "str"  # Optional. The web URL of the report.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(request_parameters, (IOBase, bytes)):
            _content = request_parameters
        else:
            _json = request_parameters

        _request = build_reports_update_report_content_in_group_request(
            group_id=group_id,
            report_id=report_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def rebind_report_in_group(  # pylint: disable=inconsistent-return-statements
        self,
        group_id: str,
        report_id: str,
        request_parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Rebinds the specified report from the specified workspace to the specified dataset.

        * If the specified dataset resides in a different workspace than the report or in **My
        workspace**\ , then a shared dataset will be created in the report's workspace.
        * On rebind, reports with a `live connection </power-bi/desktop-report-lifecycle-datasets>`_
        will lose that connection and instead have a direct binding to the target dataset.

        Permissions
        -----------


        *
          The user must have all of the following:


          * **Write** permission on the specified report.
          * **Build** permission on the target dataset.

        *
          This API call can be called by a service principal profile. For more information see:
        `Service principal profiles in Power BI Embedded
        </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Report.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param report_id: The report ID. Required.
        :type report_id: str
        :param request_parameters: Rebind report parameters. Required.
        :type request_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                request_parameters = {
                    "datasetId": "str"  # The new dataset for the rebound report. If the dataset
                      resides in a different workspace than the report, a shared dataset will be
                      created in the report's workspace. Required.
                }
        """

    @overload
    async def rebind_report_in_group(  # pylint: disable=inconsistent-return-statements
        self,
        group_id: str,
        report_id: str,
        request_parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Rebinds the specified report from the specified workspace to the specified dataset.

        * If the specified dataset resides in a different workspace than the report or in **My
        workspace**\ , then a shared dataset will be created in the report's workspace.
        * On rebind, reports with a `live connection </power-bi/desktop-report-lifecycle-datasets>`_
        will lose that connection and instead have a direct binding to the target dataset.

        Permissions
        -----------


        *
          The user must have all of the following:


          * **Write** permission on the specified report.
          * **Build** permission on the target dataset.

        *
          This API call can be called by a service principal profile. For more information see:
        `Service principal profiles in Power BI Embedded
        </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Report.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param report_id: The report ID. Required.
        :type report_id: str
        :param request_parameters: Rebind report parameters. Required.
        :type request_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def rebind_report_in_group(  # pylint: disable=inconsistent-return-statements
        self, group_id: str, report_id: str, request_parameters: Union[JSON, IO], **kwargs: Any
    ) -> None:
        """Rebinds the specified report from the specified workspace to the specified dataset.

        * If the specified dataset resides in a different workspace than the report or in **My
        workspace**\ , then a shared dataset will be created in the report's workspace.
        * On rebind, reports with a `live connection </power-bi/desktop-report-lifecycle-datasets>`_
        will lose that connection and instead have a direct binding to the target dataset.

        Permissions
        -----------


        *
          The user must have all of the following:


          * **Write** permission on the specified report.
          * **Build** permission on the target dataset.

        *
          This API call can be called by a service principal profile. For more information see:
        `Service principal profiles in Power BI Embedded
        </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Report.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param report_id: The report ID. Required.
        :type report_id: str
        :param request_parameters: Rebind report parameters. Is either a JSON type or a IO type.
         Required.
        :type request_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                request_parameters = {
                    "datasetId": "str"  # The new dataset for the rebound report. If the dataset
                      resides in a different workspace than the report, a shared dataset will be
                      created in the report's workspace. Required.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(request_parameters, (IOBase, bytes)):
            _content = request_parameters
        else:
            _json = request_parameters

        _request = build_reports_rebind_report_in_group_request(
            group_id=group_id,
            report_id=report_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get_pages_in_group(self, group_id: str, report_id: str, **kwargs: Any) -> JSON:
        """Returns a list of pages within the specified report from the specified workspace.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Report.ReadWrite.All or Report.Read.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param report_id: The report ID. Required.
        :type report_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional. OData context.
                    "value": [
                        {
                            "displayName": "str",  # Optional. The display name of the
                              report page.
                            "name": "str",  # Optional. The name of the report page.
                            "order": 0  # Optional. The order of the report page.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_reports_get_pages_in_group_request(
            group_id=group_id,
            report_id=report_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_page_in_group(self, group_id: str, report_id: str, page_name: str, **kwargs: Any) -> JSON:
        """Returns the specified page within the specified report from the specified workspace.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Report.ReadWrite.All or Report.Read.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param report_id: The report ID. Required.
        :type report_id: str
        :param page_name: The page name. Required.
        :type page_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "displayName": "str",  # Optional. The display name of the report page.
                    "name": "str",  # Optional. The name of the report page.
                    "order": 0  # Optional. The order of the report page.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_reports_get_page_in_group_request(
            group_id=group_id,
            report_id=report_id,
            page_name=page_name,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_datasources_in_group(self, group_id: str, report_id: str, **kwargs: Any) -> JSON:
        """Returns a list of data sources for the specified paginated report (RDL) from the specified
        workspace.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Report.ReadWrite.All or Report.Read.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param report_id: Required.
        :type report_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional. OData context.
                    "value": [
                        {
                            "connectionDetails": {
                                "account": "str",  # Optional. The connection
                                  account.
                                "classInfo": "str",  # Optional. The connection class
                                  information.
                                "database": "str",  # Optional. The connection
                                  database.
                                "domain": "str",  # Optional. The connection domain.
                                "emailAddress": "str",  # Optional. The connection
                                  email address.
                                "kind": "str",  # Optional. The connection kind.
                                "loginServer": "str",  # Optional. The connection
                                  login server.
                                "path": "str",  # Optional. The connection path.
                                "server": "str",  # Optional. The connection server.
                                "url": "str"  # Optional. The connection URL.
                            },
                            "connectionString": "str",  # Optional. (Deprecated) The data
                              source connection string. Available only for DirectQuery.
                            "datasourceId": "str",  # Optional. The bound data source ID,
                              which is empty when not bound to a gateway.
                            "datasourceType": "str",  # Optional. The data source type.
                            "gatewayId": "str",  # Optional. The bound gateway ID, which
                              is empty when not bound to a gateway. When using a gateway cluster, the
                              gateway ID refers to the primary (first) gateway in the cluster and is
                              similar to the gateway cluster ID.
                            "name": "str"  # Optional. (Deprecated) The data source name.
                              Available only for DirectQuery.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_reports_get_datasources_in_group_request(
            group_id=group_id,
            report_id=report_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def update_datasources_in_group(  # pylint: disable=inconsistent-return-statements
        self,
        group_id: str,
        report_id: str,
        update_rdl_datasources_request: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Updates the data sources of the specified paginated report (RDL) from the specified workspace.

        ..

           [!IMPORTANT]
           Both the original data source and the new data source must have the exact same schema.


        Permissions
        -----------


        * The user must be the data source owner.
        * This API call can be called by a service principal profile. For more information see:
        `Service principal profiles in Power BI Embedded
        </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Reports.ReadWrite.All

        Limitations
        -----------


        * Only supports paginated reports.
        * Changing the data source type isn't supported.
          :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param report_id: The report ID. Required.
        :type report_id: str
        :param update_rdl_datasources_request: Required.
        :type update_rdl_datasources_request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                update_rdl_datasources_request = {
                    "updateDetails": [
                        {
                            "connectionDetails": {
                                "database": "str",  # Optional. The connection
                                  database.
                                "server": "str"  # Optional. The connection server.
                            },
                            "datasourceName": "str"  # The name of the paginated report
                              data source. Required.
                        }
                    ]
                }
        """

    @overload
    async def update_datasources_in_group(  # pylint: disable=inconsistent-return-statements
        self,
        group_id: str,
        report_id: str,
        update_rdl_datasources_request: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Updates the data sources of the specified paginated report (RDL) from the specified workspace.

        ..

           [!IMPORTANT]
           Both the original data source and the new data source must have the exact same schema.


        Permissions
        -----------


        * The user must be the data source owner.
        * This API call can be called by a service principal profile. For more information see:
        `Service principal profiles in Power BI Embedded
        </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Reports.ReadWrite.All

        Limitations
        -----------


        * Only supports paginated reports.
        * Changing the data source type isn't supported.
          :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param report_id: The report ID. Required.
        :type report_id: str
        :param update_rdl_datasources_request: Required.
        :type update_rdl_datasources_request: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_datasources_in_group(  # pylint: disable=inconsistent-return-statements
        self, group_id: str, report_id: str, update_rdl_datasources_request: Union[JSON, IO], **kwargs: Any
    ) -> None:
        """Updates the data sources of the specified paginated report (RDL) from the specified workspace.

        ..

           [!IMPORTANT]
           Both the original data source and the new data source must have the exact same schema.


        Permissions
        -----------


        * The user must be the data source owner.
        * This API call can be called by a service principal profile. For more information see:
        `Service principal profiles in Power BI Embedded
        </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Reports.ReadWrite.All

        Limitations
        -----------


        * Only supports paginated reports.
        * Changing the data source type isn't supported.
          :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param report_id: The report ID. Required.
        :type report_id: str
        :param update_rdl_datasources_request: Is either a JSON type or a IO type. Required.
        :type update_rdl_datasources_request: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                update_rdl_datasources_request = {
                    "updateDetails": [
                        {
                            "connectionDetails": {
                                "database": "str",  # Optional. The connection
                                  database.
                                "server": "str"  # Optional. The connection server.
                            },
                            "datasourceName": "str"  # The name of the paginated report
                              data source. Required.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(update_rdl_datasources_request, (IOBase, bytes)):
            _content = update_rdl_datasources_request
        else:
            _json = update_rdl_datasources_request

        _request = build_reports_update_datasources_in_group_request(
            group_id=group_id,
            report_id=report_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def export_to_file_in_group(
        self,
        group_id: str,
        report_id: str,
        request_parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Exports the specified report from the specified workspace to the requested `file format
        </rest/api/power-bi/reports/export-to-file-in-group#fileformat>`_.

        The API is asynchronous. When the API is called, it triggers an export job. After triggering an
        export job, use `GetExportToFileStatus API
        </rest/api/power-bi/reports/get-export-to-file-status-in-group>`_ to track the job status.
        Read more about the entire flow: `Export Power BI reports
        </power-bi/developer/embedded/export-to>`_ and `Export Paginated reports
        </power-bi/developer/embedded/export-paginated-report>`_

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        All of the following:


        * Report.ReadWrite.All or Report.Read.All
        * Dataset.ReadWrite.All or Dataset.Read.All

        Limitations
        -----------

        Check the limitations in `Export Power BI report to file
        </power-bi/developer/embedded/export-to#considerations-and-limitations>`_ and `Export paginated
        report to file
        </power-bi/developer/embedded/export-paginated-report#considerations-and-limitations>`_.
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param report_id: The report ID. Required.
        :type report_id: str
        :param request_parameters: Export to file request parameters. Required.
        :type request_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                request_parameters = {
                    "format": "str",  # The requested format for the exported file. Required.
                      Known values are: "PPTX", "PDF", "PNG", "IMAGE", "XLSX", "DOCX", "CSV", "XML",
                      "MHTML", and "ACCESSIBLEPDF".
                    "paginatedReportConfiguration": {
                        "formatSettings": {
                            "str": "str"  # Optional. A dictionary of format settings.
                              The keys are the device information property names for the requested file
                              format.
                        },
                        "identities": [
                            {
                                "username": "str",  # The effective username within a
                                  token that applies row-level security rules. For an on-premises
                                  model, the username can contain alphanumeric or any of the following
                                  characters '.', '-', '_', '!', '#', '^', '~', '""', '@'. For cloud
                                  models, the username can contain any ASCII character. For either
                                  model, the username length must not exceed 256 characters, and the
                                  username shouldn't contain spaces. Required.
                                "customData": "str",  # Optional. `Custom data
                                  </power-bi/developer/embedded/embedded-row-level-security#using-the-customdata-feature>`_
                                  that's used to apply row-level security rules. Supported for live
                                  connection to Azure Analysis Services models and cloud models only.
                                "datasets": [
                                    "str"  # Optional. An array of datasets for
                                      which this identity applies.
                                ],
                                "identityBlob": {
                                    "value": "str"  # An OAuth 2.0 access token
                                      for Azure SQL. Required.
                                },
                                "reports": [
                                    "str"  # Optional. An array of reports for
                                      which this identity applies. Only supported for paginated
                                      reports.
                                ],
                                "roles": [
                                    "str"  # Optional. An array of row-level
                                      security (RLS) roles within a token that applies RLS rules. An
                                      identity can contain up to 50 roles. A role can contain any
                                      character except ``,``"" , and its length must not exceed 50
                                      characters.
                                ]
                            }
                        ],
                        "parameterValues": [
                            {
                                "name": "str",  # Optional. The parameter name.
                                "value": "str"  # Optional. The parameter value.
                            }
                        ]
                    },
                    "powerBIReportConfiguration": {
                        "datasetToBind": "str",  # Optional. The dataset ID to export the
                          report with. Only needed if exporting with a dataset other than the report's
                          default dataset.
                        "defaultBookmark": {
                            "name": "str",  # Optional. The bookmark name.
                            "state": "str"  # Optional. The bookmark state.
                        },
                        "identities": [
                            {
                                "username": "str",  # The effective username within a
                                  token that applies row-level security rules. For an on-premises
                                  model, the username can contain alphanumeric or any of the following
                                  characters '.', '-', '_', '!', '#', '^', '~', '""', '@'. For cloud
                                  models, the username can contain any ASCII character. For either
                                  model, the username length must not exceed 256 characters, and the
                                  username shouldn't contain spaces. Required.
                                "customData": "str",  # Optional. `Custom data
                                  </power-bi/developer/embedded/embedded-row-level-security#using-the-customdata-feature>`_
                                  that's used to apply row-level security rules. Supported for live
                                  connection to Azure Analysis Services models and cloud models only.
                                "datasets": [
                                    "str"  # Optional. An array of datasets for
                                      which this identity applies.
                                ],
                                "identityBlob": {
                                    "value": "str"  # An OAuth 2.0 access token
                                      for Azure SQL. Required.
                                },
                                "reports": [
                                    "str"  # Optional. An array of reports for
                                      which this identity applies. Only supported for paginated
                                      reports.
                                ],
                                "roles": [
                                    "str"  # Optional. An array of row-level
                                      security (RLS) roles within a token that applies RLS rules. An
                                      identity can contain up to 50 roles. A role can contain any
                                      character except ``,``"" , and its length must not exceed 50
                                      characters.
                                ]
                            }
                        ],
                        "pages": [
                            {
                                "pageName": "str",  # The page name. Required.
                                "bookmark": {
                                    "name": "str",  # Optional. The bookmark
                                      name.
                                    "state": "str"  # Optional. The bookmark
                                      state.
                                },
                                "visualName": "str"  # Optional. The name of the
                                  visual to export. Specify a name, in case only a single visual from
                                  this page is exported.
                            }
                        ],
                        "reportLevelFilters": [
                            {
                                "filter": "str"  # Optional. The filter to apply. For
                                  information about the filter syntax, see `Filter a report
                                  </power-bi/collaborate-share/service-url-filters>`_.
                            }
                        ],
                        "settings": {
                            "includeHiddenPages": bool,  # Optional. Whether to include
                              hidden pages when exporting an entire report. If not provided, the
                              default behavior is to exclude hidden pages. This property will be
                              ignored when specific pages are exported.
                            "locale": "str"  # Optional. The locale to apply.
                        }
                    }
                }

                # response body for status code(s): 202
                response == {
                    "ResourceFileExtension": "str",  # Optional. The extension of the exported
                      file.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. The start date and
                      time of the export to file job.
                    "expirationTime": "2020-02-20 00:00:00",  # Optional. The expiration date and
                      time of the retrieval URL.
                    "id": "str",  # Optional. The export to file job ID.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                      of the last change to the export to file job.
                    "percentComplete": 0,  # Optional. Job progress as a percentage.
                    "reportId": "str",  # Optional. The ID of the exported report.
                    "reportName": "str",  # Optional. The name of the exported report.
                    "resourceLocation": "str",  # Optional. The retrieval URL for the exported
                      file.
                    "status": "str"  # Optional. The current state of the export to file job.
                      Known values are: "Undefined", "NotStarted", "Running", "Succeeded", and
                      "Failed".
                }
        """

    @overload
    async def export_to_file_in_group(
        self,
        group_id: str,
        report_id: str,
        request_parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Exports the specified report from the specified workspace to the requested `file format
        </rest/api/power-bi/reports/export-to-file-in-group#fileformat>`_.

        The API is asynchronous. When the API is called, it triggers an export job. After triggering an
        export job, use `GetExportToFileStatus API
        </rest/api/power-bi/reports/get-export-to-file-status-in-group>`_ to track the job status.
        Read more about the entire flow: `Export Power BI reports
        </power-bi/developer/embedded/export-to>`_ and `Export Paginated reports
        </power-bi/developer/embedded/export-paginated-report>`_

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        All of the following:


        * Report.ReadWrite.All or Report.Read.All
        * Dataset.ReadWrite.All or Dataset.Read.All

        Limitations
        -----------

        Check the limitations in `Export Power BI report to file
        </power-bi/developer/embedded/export-to#considerations-and-limitations>`_ and `Export paginated
        report to file
        </power-bi/developer/embedded/export-paginated-report#considerations-and-limitations>`_.
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param report_id: The report ID. Required.
        :type report_id: str
        :param request_parameters: Export to file request parameters. Required.
        :type request_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 202
                response == {
                    "ResourceFileExtension": "str",  # Optional. The extension of the exported
                      file.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. The start date and
                      time of the export to file job.
                    "expirationTime": "2020-02-20 00:00:00",  # Optional. The expiration date and
                      time of the retrieval URL.
                    "id": "str",  # Optional. The export to file job ID.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                      of the last change to the export to file job.
                    "percentComplete": 0,  # Optional. Job progress as a percentage.
                    "reportId": "str",  # Optional. The ID of the exported report.
                    "reportName": "str",  # Optional. The name of the exported report.
                    "resourceLocation": "str",  # Optional. The retrieval URL for the exported
                      file.
                    "status": "str"  # Optional. The current state of the export to file job.
                      Known values are: "Undefined", "NotStarted", "Running", "Succeeded", and
                      "Failed".
                }
        """

    @distributed_trace_async
    async def export_to_file_in_group(
        self, group_id: str, report_id: str, request_parameters: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Exports the specified report from the specified workspace to the requested `file format
        </rest/api/power-bi/reports/export-to-file-in-group#fileformat>`_.

        The API is asynchronous. When the API is called, it triggers an export job. After triggering an
        export job, use `GetExportToFileStatus API
        </rest/api/power-bi/reports/get-export-to-file-status-in-group>`_ to track the job status.
        Read more about the entire flow: `Export Power BI reports
        </power-bi/developer/embedded/export-to>`_ and `Export Paginated reports
        </power-bi/developer/embedded/export-paginated-report>`_

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        All of the following:


        * Report.ReadWrite.All or Report.Read.All
        * Dataset.ReadWrite.All or Dataset.Read.All

        Limitations
        -----------

        Check the limitations in `Export Power BI report to file
        </power-bi/developer/embedded/export-to#considerations-and-limitations>`_ and `Export paginated
        report to file
        </power-bi/developer/embedded/export-paginated-report#considerations-and-limitations>`_.
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param report_id: The report ID. Required.
        :type report_id: str
        :param request_parameters: Export to file request parameters. Is either a JSON type or a IO
         type. Required.
        :type request_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                request_parameters = {
                    "format": "str",  # The requested format for the exported file. Required.
                      Known values are: "PPTX", "PDF", "PNG", "IMAGE", "XLSX", "DOCX", "CSV", "XML",
                      "MHTML", and "ACCESSIBLEPDF".
                    "paginatedReportConfiguration": {
                        "formatSettings": {
                            "str": "str"  # Optional. A dictionary of format settings.
                              The keys are the device information property names for the requested file
                              format.
                        },
                        "identities": [
                            {
                                "username": "str",  # The effective username within a
                                  token that applies row-level security rules. For an on-premises
                                  model, the username can contain alphanumeric or any of the following
                                  characters '.', '-', '_', '!', '#', '^', '~', '""', '@'. For cloud
                                  models, the username can contain any ASCII character. For either
                                  model, the username length must not exceed 256 characters, and the
                                  username shouldn't contain spaces. Required.
                                "customData": "str",  # Optional. `Custom data
                                  </power-bi/developer/embedded/embedded-row-level-security#using-the-customdata-feature>`_
                                  that's used to apply row-level security rules. Supported for live
                                  connection to Azure Analysis Services models and cloud models only.
                                "datasets": [
                                    "str"  # Optional. An array of datasets for
                                      which this identity applies.
                                ],
                                "identityBlob": {
                                    "value": "str"  # An OAuth 2.0 access token
                                      for Azure SQL. Required.
                                },
                                "reports": [
                                    "str"  # Optional. An array of reports for
                                      which this identity applies. Only supported for paginated
                                      reports.
                                ],
                                "roles": [
                                    "str"  # Optional. An array of row-level
                                      security (RLS) roles within a token that applies RLS rules. An
                                      identity can contain up to 50 roles. A role can contain any
                                      character except ``,``"" , and its length must not exceed 50
                                      characters.
                                ]
                            }
                        ],
                        "parameterValues": [
                            {
                                "name": "str",  # Optional. The parameter name.
                                "value": "str"  # Optional. The parameter value.
                            }
                        ]
                    },
                    "powerBIReportConfiguration": {
                        "datasetToBind": "str",  # Optional. The dataset ID to export the
                          report with. Only needed if exporting with a dataset other than the report's
                          default dataset.
                        "defaultBookmark": {
                            "name": "str",  # Optional. The bookmark name.
                            "state": "str"  # Optional. The bookmark state.
                        },
                        "identities": [
                            {
                                "username": "str",  # The effective username within a
                                  token that applies row-level security rules. For an on-premises
                                  model, the username can contain alphanumeric or any of the following
                                  characters '.', '-', '_', '!', '#', '^', '~', '""', '@'. For cloud
                                  models, the username can contain any ASCII character. For either
                                  model, the username length must not exceed 256 characters, and the
                                  username shouldn't contain spaces. Required.
                                "customData": "str",  # Optional. `Custom data
                                  </power-bi/developer/embedded/embedded-row-level-security#using-the-customdata-feature>`_
                                  that's used to apply row-level security rules. Supported for live
                                  connection to Azure Analysis Services models and cloud models only.
                                "datasets": [
                                    "str"  # Optional. An array of datasets for
                                      which this identity applies.
                                ],
                                "identityBlob": {
                                    "value": "str"  # An OAuth 2.0 access token
                                      for Azure SQL. Required.
                                },
                                "reports": [
                                    "str"  # Optional. An array of reports for
                                      which this identity applies. Only supported for paginated
                                      reports.
                                ],
                                "roles": [
                                    "str"  # Optional. An array of row-level
                                      security (RLS) roles within a token that applies RLS rules. An
                                      identity can contain up to 50 roles. A role can contain any
                                      character except ``,``"" , and its length must not exceed 50
                                      characters.
                                ]
                            }
                        ],
                        "pages": [
                            {
                                "pageName": "str",  # The page name. Required.
                                "bookmark": {
                                    "name": "str",  # Optional. The bookmark
                                      name.
                                    "state": "str"  # Optional. The bookmark
                                      state.
                                },
                                "visualName": "str"  # Optional. The name of the
                                  visual to export. Specify a name, in case only a single visual from
                                  this page is exported.
                            }
                        ],
                        "reportLevelFilters": [
                            {
                                "filter": "str"  # Optional. The filter to apply. For
                                  information about the filter syntax, see `Filter a report
                                  </power-bi/collaborate-share/service-url-filters>`_.
                            }
                        ],
                        "settings": {
                            "includeHiddenPages": bool,  # Optional. Whether to include
                              hidden pages when exporting an entire report. If not provided, the
                              default behavior is to exclude hidden pages. This property will be
                              ignored when specific pages are exported.
                            "locale": "str"  # Optional. The locale to apply.
                        }
                    }
                }

                # response body for status code(s): 202
                response == {
                    "ResourceFileExtension": "str",  # Optional. The extension of the exported
                      file.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. The start date and
                      time of the export to file job.
                    "expirationTime": "2020-02-20 00:00:00",  # Optional. The expiration date and
                      time of the retrieval URL.
                    "id": "str",  # Optional. The export to file job ID.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                      of the last change to the export to file job.
                    "percentComplete": 0,  # Optional. Job progress as a percentage.
                    "reportId": "str",  # Optional. The ID of the exported report.
                    "reportName": "str",  # Optional. The name of the exported report.
                    "resourceLocation": "str",  # Optional. The retrieval URL for the exported
                      file.
                    "status": "str"  # Optional. The current state of the export to file job.
                      Known values are: "Undefined", "NotStarted", "Running", "Succeeded", and
                      "Failed".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(request_parameters, (IOBase, bytes)):
            _content = request_parameters
        else:
            _json = request_parameters

        _request = build_reports_export_to_file_in_group_request(
            group_id=group_id,
            report_id=report_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_export_to_file_status_in_group(
        self, group_id: str, report_id: str, export_id: str, **kwargs: Any
    ) -> JSON:
        """Returns the current status of the `Export to File In Group
        </rest/api/power-bi/reports/export-to-file-in-group>`_ job for the specified report from the
        specified workspace.

        When the export job status is 'Succeeded' use the `GetFileOfExportToFile API
        </rest/api/power-bi/reports/get-file-of-export-to-file-in-group>`_ to retrieve the file.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Report.ReadWrite.All or Report.Read.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param report_id: The report ID. Required.
        :type report_id: str
        :param export_id: The export ID. Required.
        :type export_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 202
                response == {
                    "ResourceFileExtension": "str",  # Optional. The extension of the exported
                      file.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. The start date and
                      time of the export to file job.
                    "expirationTime": "2020-02-20 00:00:00",  # Optional. The expiration date and
                      time of the retrieval URL.
                    "id": "str",  # Optional. The export to file job ID.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. The date and time
                      of the last change to the export to file job.
                    "percentComplete": 0,  # Optional. Job progress as a percentage.
                    "reportId": "str",  # Optional. The ID of the exported report.
                    "reportName": "str",  # Optional. The name of the exported report.
                    "resourceLocation": "str",  # Optional. The retrieval URL for the exported
                      file.
                    "status": "str"  # Optional. The current state of the export to file job.
                      Known values are: "Undefined", "NotStarted", "Running", "Succeeded", and
                      "Failed".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_reports_get_export_to_file_status_in_group_request(
            group_id=group_id,
            report_id=report_id,
            export_id=export_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 202:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_file_of_export_to_file_in_group(
        self, group_id: str, report_id: str, export_id: str, **kwargs: Any
    ) -> AsyncIterator[bytes]:
        """Returns the file from the `Export to File In Group
        </rest/api/power-bi/reports/export-to-file-in-group>`_ job for the specified report from the
        specified workspace.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Report.ReadWrite.All or Report.Read.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param report_id: The report ID. Required.
        :type report_id: str
        :param export_id: The export ID. Required.
        :type export_id: str
        :return: Async iterator of the response bytes
        :rtype: AsyncIterator[bytes]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        _request = build_reports_get_file_of_export_to_file_in_group_request(
            group_id=group_id,
            report_id=report_id,
            export_id=export_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 200, 200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = response.iter_bytes()

        if response.status_code == 200:
            deserialized = response.iter_bytes()

        if response.status_code == 200:
            deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, cast(AsyncIterator[bytes], deserialized), {})  # type: ignore

        return cast(AsyncIterator[bytes], deserialized)  # type: ignore

    @overload
    async def generate_token_for_create_in_group(
        self, group_id: str, request_parameters: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Generates an embed token to allow report creation in the specified workspace based on the
        specified dataset.

        ..

           [!TIP]
           To create embed tokens, it's recommended to use the latest API, `Generate Token
        </rest/api/power-bi/embed-token/generate-token>`_. Generate token supports additional
        functions, such as creating a token for multiple items.

           [!IMPORTANT]
           This API call is only relevant to the `embed for your customers
        </power-bi/developer/embed-sample-for-customers>`_ scenario. To learn more about using this
        API, see `Considerations when generating an embed token
        </power-bi/developer/embedded/generate-embed-token>`_.


        Permissions
        -----------


        * When using a service principal for authentication, refer to `Embed Power BI content with
        service principal </power-bi/developer/embed-service-principal>`_ and `Considerations and
        limitations
        </power-bi/developer/embedded/embed-service-principal#considerations-and-limitations>`_.
        * This API call can be called by a service principal profile. For more information see:
        `Service principal profiles in Power BI Embedded
        </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        All of the following:


        * Content.Create
        * Report.ReadWrite.All or Report.Read.All
        * Dataset.ReadWrite.All or Dataset.Read.All

        Limitations
        -----------

        For Azure Analysis Services or Analysis Services on-premises live connection reports,
        generating an embed token with row-level security may not work for several minutes after a
        `Rebind Report </rest/api/power-bi/reports/rebind-report>`_ api call.
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param request_parameters: Generate token parameters. Required.
        :type request_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                request_parameters = {
                    "accessLevel": "str",  # Optional. The required access level for embed token
                      generation. Known values are: "View", "Edit", and "Create".
                    "allowSaveAs": bool,  # Optional. Whether an embedded report can be saved as
                      a new report. The default value is ``false``. Only applies when you generate an
                      embed token for report embedding.
                    "datasetId": "str",  # Optional. The dataset ID used for report creation.
                      Only applies when you generate an embed token for report creation.
                    "identities": [
                        {
                            "username": "str",  # The effective username within a token
                              that applies row-level security rules. For an on-premises model, the
                              username can contain alphanumeric or any of the following characters '.',
                              '-', '_', '!', '#', '^', '~', '""', '@'. For cloud models, the username
                              can contain any ASCII character. For either model, the username length
                              must not exceed 256 characters, and the username shouldn't contain
                              spaces. Required.
                            "customData": "str",  # Optional. `Custom data
                              </power-bi/developer/embedded/embedded-row-level-security#using-the-customdata-feature>`_
                              that's used to apply row-level security rules. Supported for live
                              connection to Azure Analysis Services models and cloud models only.
                            "datasets": [
                                "str"  # Optional. An array of datasets for which
                                  this identity applies.
                            ],
                            "identityBlob": {
                                "value": "str"  # An OAuth 2.0 access token for Azure
                                  SQL. Required.
                            },
                            "reports": [
                                "str"  # Optional. An array of reports for which this
                                  identity applies. Only supported for paginated reports.
                            ],
                            "roles": [
                                "str"  # Optional. An array of row-level security
                                  (RLS) roles within a token that applies RLS rules. An identity can
                                  contain up to 50 roles. A role can contain any character except
                                  ``,``"" , and its length must not exceed 50 characters.
                            ]
                        }
                    ],
                    "lifetimeInMinutes": 0  # Optional. The maximum lifetime of the token in
                      minutes, starting from the time it was generated. Can be used to shorten the
                      expiration time of a token, but not to extend it. The value must be a positive
                      integer. Zero (0) is equivalent to null and will be ignored, resulting in the
                      default expiration time.
                }

                # response body for status code(s): 200
                response == {
                    "expiration": "2020-02-20 00:00:00",  # The date and time (UTC) of token
                      expiration. Required.
                    "token": "str",  # The embed token. Required.
                    "tokenId": "str"  # The unique token ID. Through audit logs, the token ID can
                      be used to correlate operations that use the token with the generate operation.
                      Required.
                }
        """

    @overload
    async def generate_token_for_create_in_group(
        self, group_id: str, request_parameters: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Generates an embed token to allow report creation in the specified workspace based on the
        specified dataset.

        ..

           [!TIP]
           To create embed tokens, it's recommended to use the latest API, `Generate Token
        </rest/api/power-bi/embed-token/generate-token>`_. Generate token supports additional
        functions, such as creating a token for multiple items.

           [!IMPORTANT]
           This API call is only relevant to the `embed for your customers
        </power-bi/developer/embed-sample-for-customers>`_ scenario. To learn more about using this
        API, see `Considerations when generating an embed token
        </power-bi/developer/embedded/generate-embed-token>`_.


        Permissions
        -----------


        * When using a service principal for authentication, refer to `Embed Power BI content with
        service principal </power-bi/developer/embed-service-principal>`_ and `Considerations and
        limitations
        </power-bi/developer/embedded/embed-service-principal#considerations-and-limitations>`_.
        * This API call can be called by a service principal profile. For more information see:
        `Service principal profiles in Power BI Embedded
        </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        All of the following:


        * Content.Create
        * Report.ReadWrite.All or Report.Read.All
        * Dataset.ReadWrite.All or Dataset.Read.All

        Limitations
        -----------

        For Azure Analysis Services or Analysis Services on-premises live connection reports,
        generating an embed token with row-level security may not work for several minutes after a
        `Rebind Report </rest/api/power-bi/reports/rebind-report>`_ api call.
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param request_parameters: Generate token parameters. Required.
        :type request_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "expiration": "2020-02-20 00:00:00",  # The date and time (UTC) of token
                      expiration. Required.
                    "token": "str",  # The embed token. Required.
                    "tokenId": "str"  # The unique token ID. Through audit logs, the token ID can
                      be used to correlate operations that use the token with the generate operation.
                      Required.
                }
        """

    @distributed_trace_async
    async def generate_token_for_create_in_group(
        self, group_id: str, request_parameters: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Generates an embed token to allow report creation in the specified workspace based on the
        specified dataset.

        ..

           [!TIP]
           To create embed tokens, it's recommended to use the latest API, `Generate Token
        </rest/api/power-bi/embed-token/generate-token>`_. Generate token supports additional
        functions, such as creating a token for multiple items.

           [!IMPORTANT]
           This API call is only relevant to the `embed for your customers
        </power-bi/developer/embed-sample-for-customers>`_ scenario. To learn more about using this
        API, see `Considerations when generating an embed token
        </power-bi/developer/embedded/generate-embed-token>`_.


        Permissions
        -----------


        * When using a service principal for authentication, refer to `Embed Power BI content with
        service principal </power-bi/developer/embed-service-principal>`_ and `Considerations and
        limitations
        </power-bi/developer/embedded/embed-service-principal#considerations-and-limitations>`_.
        * This API call can be called by a service principal profile. For more information see:
        `Service principal profiles in Power BI Embedded
        </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        All of the following:


        * Content.Create
        * Report.ReadWrite.All or Report.Read.All
        * Dataset.ReadWrite.All or Dataset.Read.All

        Limitations
        -----------

        For Azure Analysis Services or Analysis Services on-premises live connection reports,
        generating an embed token with row-level security may not work for several minutes after a
        `Rebind Report </rest/api/power-bi/reports/rebind-report>`_ api call.
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param request_parameters: Generate token parameters. Is either a JSON type or a IO type.
         Required.
        :type request_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                request_parameters = {
                    "accessLevel": "str",  # Optional. The required access level for embed token
                      generation. Known values are: "View", "Edit", and "Create".
                    "allowSaveAs": bool,  # Optional. Whether an embedded report can be saved as
                      a new report. The default value is ``false``. Only applies when you generate an
                      embed token for report embedding.
                    "datasetId": "str",  # Optional. The dataset ID used for report creation.
                      Only applies when you generate an embed token for report creation.
                    "identities": [
                        {
                            "username": "str",  # The effective username within a token
                              that applies row-level security rules. For an on-premises model, the
                              username can contain alphanumeric or any of the following characters '.',
                              '-', '_', '!', '#', '^', '~', '""', '@'. For cloud models, the username
                              can contain any ASCII character. For either model, the username length
                              must not exceed 256 characters, and the username shouldn't contain
                              spaces. Required.
                            "customData": "str",  # Optional. `Custom data
                              </power-bi/developer/embedded/embedded-row-level-security#using-the-customdata-feature>`_
                              that's used to apply row-level security rules. Supported for live
                              connection to Azure Analysis Services models and cloud models only.
                            "datasets": [
                                "str"  # Optional. An array of datasets for which
                                  this identity applies.
                            ],
                            "identityBlob": {
                                "value": "str"  # An OAuth 2.0 access token for Azure
                                  SQL. Required.
                            },
                            "reports": [
                                "str"  # Optional. An array of reports for which this
                                  identity applies. Only supported for paginated reports.
                            ],
                            "roles": [
                                "str"  # Optional. An array of row-level security
                                  (RLS) roles within a token that applies RLS rules. An identity can
                                  contain up to 50 roles. A role can contain any character except
                                  ``,``"" , and its length must not exceed 50 characters.
                            ]
                        }
                    ],
                    "lifetimeInMinutes": 0  # Optional. The maximum lifetime of the token in
                      minutes, starting from the time it was generated. Can be used to shorten the
                      expiration time of a token, but not to extend it. The value must be a positive
                      integer. Zero (0) is equivalent to null and will be ignored, resulting in the
                      default expiration time.
                }

                # response body for status code(s): 200
                response == {
                    "expiration": "2020-02-20 00:00:00",  # The date and time (UTC) of token
                      expiration. Required.
                    "token": "str",  # The embed token. Required.
                    "tokenId": "str"  # The unique token ID. Through audit logs, the token ID can
                      be used to correlate operations that use the token with the generate operation.
                      Required.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(request_parameters, (IOBase, bytes)):
            _content = request_parameters
        else:
            _json = request_parameters

        _request = build_reports_generate_token_for_create_in_group_request(
            group_id=group_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def generate_token_in_group(
        self,
        group_id: str,
        report_id: str,
        request_parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Generates an embed token to view or edit the specified report from the specified workspace.

        ..

           [!TIP]
           To create embed tokens, it's recommended to use the latest API, `Generate Token
        </rest/api/power-bi/embed-token/generate-token>`_. Generate token supports additional
        functions, such as creating a token for multiple items.

           [!IMPORTANT]
           This API call is only relevant to the `embed for your customers
        </power-bi/developer/embed-sample-for-customers>`_ scenario. To learn more about using this
        API, see `Considerations when generating an embed token
        </power-bi/developer/embedded/generate-embed-token>`_.


        Permissions
        -----------


        * When using a service principal for authentication, refer to `Embed Power BI content with
        service principal </power-bi/developer/embed-service-principal>`_ and `Considerations and
        limitations
        </power-bi/developer/embedded/embed-service-principal#considerations-and-limitations>`_.
        * This API call can be called by a service principal profile. For more information see:
        `Service principal profiles in Power BI Embedded
        </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        All of the following, unless a requirement doesn't apply:


        * Report.ReadWrite.All or Report.Read.All
        * Dataset.ReadWrite.All or Dataset.Read.All
        * Content.Create, required if the ``allowSaveAs`` flag is specified in `GenerateTokenRequest
        </rest/api/power-bi/embed-token/reports-generate-token-for-create-in-group#generatetokenrequest>`_

        Limitations
        -----------

        For Azure Analysis Services or Analysis Services on-premises live connection reports,
        generating an embed token with row-level security may not work for several minutes after a
        `Rebind Report </rest/api/power-bi/reports/rebind-report>`_.
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param report_id: The report ID. Required.
        :type report_id: str
        :param request_parameters: Generate token parameters. Required.
        :type request_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                request_parameters = {
                    "accessLevel": "str",  # Optional. The required access level for embed token
                      generation. Known values are: "View", "Edit", and "Create".
                    "allowSaveAs": bool,  # Optional. Whether an embedded report can be saved as
                      a new report. The default value is ``false``. Only applies when you generate an
                      embed token for report embedding.
                    "datasetId": "str",  # Optional. The dataset ID used for report creation.
                      Only applies when you generate an embed token for report creation.
                    "identities": [
                        {
                            "username": "str",  # The effective username within a token
                              that applies row-level security rules. For an on-premises model, the
                              username can contain alphanumeric or any of the following characters '.',
                              '-', '_', '!', '#', '^', '~', '""', '@'. For cloud models, the username
                              can contain any ASCII character. For either model, the username length
                              must not exceed 256 characters, and the username shouldn't contain
                              spaces. Required.
                            "customData": "str",  # Optional. `Custom data
                              </power-bi/developer/embedded/embedded-row-level-security#using-the-customdata-feature>`_
                              that's used to apply row-level security rules. Supported for live
                              connection to Azure Analysis Services models and cloud models only.
                            "datasets": [
                                "str"  # Optional. An array of datasets for which
                                  this identity applies.
                            ],
                            "identityBlob": {
                                "value": "str"  # An OAuth 2.0 access token for Azure
                                  SQL. Required.
                            },
                            "reports": [
                                "str"  # Optional. An array of reports for which this
                                  identity applies. Only supported for paginated reports.
                            ],
                            "roles": [
                                "str"  # Optional. An array of row-level security
                                  (RLS) roles within a token that applies RLS rules. An identity can
                                  contain up to 50 roles. A role can contain any character except
                                  ``,``"" , and its length must not exceed 50 characters.
                            ]
                        }
                    ],
                    "lifetimeInMinutes": 0  # Optional. The maximum lifetime of the token in
                      minutes, starting from the time it was generated. Can be used to shorten the
                      expiration time of a token, but not to extend it. The value must be a positive
                      integer. Zero (0) is equivalent to null and will be ignored, resulting in the
                      default expiration time.
                }

                # response body for status code(s): 200
                response == {
                    "expiration": "2020-02-20 00:00:00",  # The date and time (UTC) of token
                      expiration. Required.
                    "token": "str",  # The embed token. Required.
                    "tokenId": "str"  # The unique token ID. Through audit logs, the token ID can
                      be used to correlate operations that use the token with the generate operation.
                      Required.
                }
        """

    @overload
    async def generate_token_in_group(
        self,
        group_id: str,
        report_id: str,
        request_parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Generates an embed token to view or edit the specified report from the specified workspace.

        ..

           [!TIP]
           To create embed tokens, it's recommended to use the latest API, `Generate Token
        </rest/api/power-bi/embed-token/generate-token>`_. Generate token supports additional
        functions, such as creating a token for multiple items.

           [!IMPORTANT]
           This API call is only relevant to the `embed for your customers
        </power-bi/developer/embed-sample-for-customers>`_ scenario. To learn more about using this
        API, see `Considerations when generating an embed token
        </power-bi/developer/embedded/generate-embed-token>`_.


        Permissions
        -----------


        * When using a service principal for authentication, refer to `Embed Power BI content with
        service principal </power-bi/developer/embed-service-principal>`_ and `Considerations and
        limitations
        </power-bi/developer/embedded/embed-service-principal#considerations-and-limitations>`_.
        * This API call can be called by a service principal profile. For more information see:
        `Service principal profiles in Power BI Embedded
        </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        All of the following, unless a requirement doesn't apply:


        * Report.ReadWrite.All or Report.Read.All
        * Dataset.ReadWrite.All or Dataset.Read.All
        * Content.Create, required if the ``allowSaveAs`` flag is specified in `GenerateTokenRequest
        </rest/api/power-bi/embed-token/reports-generate-token-for-create-in-group#generatetokenrequest>`_

        Limitations
        -----------

        For Azure Analysis Services or Analysis Services on-premises live connection reports,
        generating an embed token with row-level security may not work for several minutes after a
        `Rebind Report </rest/api/power-bi/reports/rebind-report>`_.
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param report_id: The report ID. Required.
        :type report_id: str
        :param request_parameters: Generate token parameters. Required.
        :type request_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "expiration": "2020-02-20 00:00:00",  # The date and time (UTC) of token
                      expiration. Required.
                    "token": "str",  # The embed token. Required.
                    "tokenId": "str"  # The unique token ID. Through audit logs, the token ID can
                      be used to correlate operations that use the token with the generate operation.
                      Required.
                }
        """

    @distributed_trace_async
    async def generate_token_in_group(
        self, group_id: str, report_id: str, request_parameters: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Generates an embed token to view or edit the specified report from the specified workspace.

        ..

           [!TIP]
           To create embed tokens, it's recommended to use the latest API, `Generate Token
        </rest/api/power-bi/embed-token/generate-token>`_. Generate token supports additional
        functions, such as creating a token for multiple items.

           [!IMPORTANT]
           This API call is only relevant to the `embed for your customers
        </power-bi/developer/embed-sample-for-customers>`_ scenario. To learn more about using this
        API, see `Considerations when generating an embed token
        </power-bi/developer/embedded/generate-embed-token>`_.


        Permissions
        -----------


        * When using a service principal for authentication, refer to `Embed Power BI content with
        service principal </power-bi/developer/embed-service-principal>`_ and `Considerations and
        limitations
        </power-bi/developer/embedded/embed-service-principal#considerations-and-limitations>`_.
        * This API call can be called by a service principal profile. For more information see:
        `Service principal profiles in Power BI Embedded
        </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        All of the following, unless a requirement doesn't apply:


        * Report.ReadWrite.All or Report.Read.All
        * Dataset.ReadWrite.All or Dataset.Read.All
        * Content.Create, required if the ``allowSaveAs`` flag is specified in `GenerateTokenRequest
        </rest/api/power-bi/embed-token/reports-generate-token-for-create-in-group#generatetokenrequest>`_

        Limitations
        -----------

        For Azure Analysis Services or Analysis Services on-premises live connection reports,
        generating an embed token with row-level security may not work for several minutes after a
        `Rebind Report </rest/api/power-bi/reports/rebind-report>`_.
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param report_id: The report ID. Required.
        :type report_id: str
        :param request_parameters: Generate token parameters. Is either a JSON type or a IO type.
         Required.
        :type request_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                request_parameters = {
                    "accessLevel": "str",  # Optional. The required access level for embed token
                      generation. Known values are: "View", "Edit", and "Create".
                    "allowSaveAs": bool,  # Optional. Whether an embedded report can be saved as
                      a new report. The default value is ``false``. Only applies when you generate an
                      embed token for report embedding.
                    "datasetId": "str",  # Optional. The dataset ID used for report creation.
                      Only applies when you generate an embed token for report creation.
                    "identities": [
                        {
                            "username": "str",  # The effective username within a token
                              that applies row-level security rules. For an on-premises model, the
                              username can contain alphanumeric or any of the following characters '.',
                              '-', '_', '!', '#', '^', '~', '""', '@'. For cloud models, the username
                              can contain any ASCII character. For either model, the username length
                              must not exceed 256 characters, and the username shouldn't contain
                              spaces. Required.
                            "customData": "str",  # Optional. `Custom data
                              </power-bi/developer/embedded/embedded-row-level-security#using-the-customdata-feature>`_
                              that's used to apply row-level security rules. Supported for live
                              connection to Azure Analysis Services models and cloud models only.
                            "datasets": [
                                "str"  # Optional. An array of datasets for which
                                  this identity applies.
                            ],
                            "identityBlob": {
                                "value": "str"  # An OAuth 2.0 access token for Azure
                                  SQL. Required.
                            },
                            "reports": [
                                "str"  # Optional. An array of reports for which this
                                  identity applies. Only supported for paginated reports.
                            ],
                            "roles": [
                                "str"  # Optional. An array of row-level security
                                  (RLS) roles within a token that applies RLS rules. An identity can
                                  contain up to 50 roles. A role can contain any character except
                                  ``,``"" , and its length must not exceed 50 characters.
                            ]
                        }
                    ],
                    "lifetimeInMinutes": 0  # Optional. The maximum lifetime of the token in
                      minutes, starting from the time it was generated. Can be used to shorten the
                      expiration time of a token, but not to extend it. The value must be a positive
                      integer. Zero (0) is equivalent to null and will be ignored, resulting in the
                      default expiration time.
                }

                # response body for status code(s): 200
                response == {
                    "expiration": "2020-02-20 00:00:00",  # The date and time (UTC) of token
                      expiration. Required.
                    "token": "str",  # The embed token. Required.
                    "tokenId": "str"  # The unique token ID. Through audit logs, the token ID can
                      be used to correlate operations that use the token with the generate operation.
                      Required.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(request_parameters, (IOBase, bytes)):
            _content = request_parameters
        else:
            _json = request_parameters

        _request = build_reports_generate_token_in_group_request(
            group_id=group_id,
            report_id=report_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_reports_in_group_as_admin(
        self,
        group_id: str,
        *,
        filter: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        **kwargs: Any
    ) -> JSON:
        """Returns a list of reports from the specified workspace.

        Permissions
        -----------


        * The user must have administrator rights (such as Office 365 Global Administrator or Power BI
        Service Administrator) or authenticate using a service principal.
        * Delegated permissions are supported.

        When running under service prinicipal authentication, an app **must not** have any
        admin-consent required premissions for Power BI set on it in the Azure portal.

        Required Scope
        --------------

        Tenant.Read.All or Tenant.ReadWrite.All

        Relevant only when authenticating via a standard delegated admin access token. Must not be
        present when authentication via a service principal is used.

        Limitations
        -----------

        Maximum 200 requests per hour.
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :keyword filter: Filters the results, based on a boolean condition. Default value is None.
        :paramtype filter: str
        :keyword top: Returns only the first n results. Default value is None.
        :paramtype top: int
        :keyword skip: Skips the first n results. Default value is None.
        :paramtype skip: int
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional. OData context.
                    "value": [
                        {
                            "id": "str",  # The report ID. Required.
                            "appId": "str",  # Optional. The app ID, returned only if the
                              report belongs to an app.
                            "createdBy": "str",  # Optional. The report owner. Available
                              only for reports created after June 2019.
                            "createdDateTime": "2020-02-20 00:00:00",  # Optional. The
                              report creation date and time.
                            "datasetId": "str",  # Optional. The dataset ID of the
                              report.
                            "description": "str",  # Optional. The report description.
                            "embedUrl": "str",  # Optional. The embed URL of the report.
                            "modifiedBy": "str",  # Optional. The last user that modified
                              the report.
                            "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. The
                              date and time that the report was last modified.
                            "name": "str",  # Optional. The name of the report.
                            "reportType": "str",  # Optional. The report type.
                              "PaginatedReport"
                            "subscriptions": [
                                {
                                    "id": "str",  # The subscription ID.
                                      Required.
                                    "artifactDisplayName": "str",  # Optional.
                                      The name of the subscribed Power BI item (such as a report or a
                                      dashboard).
                                    "artifactId": "str",  # Optional. The ID of
                                      the subscribed Power BI item (such as a report or a dashboard).
                                    "artifactType": "str",  # Optional. The type
                                      of Power BI item (for example a ``Report``"" , ``Dashboard``"" ,
                                      or ``Dataset``"" ).
                                    "attachmentFormat": "str",  # Optional.
                                      Format of the report attached in the email subscription.
                                    "endDate": "2020-02-20 00:00:00",  #
                                      Optional. The end date and time of the email subscription.
                                    "frequency": "str",  # Optional. The
                                      frequency of the email subscription.
                                    "isEnabled": bool,  # Optional. Whether the
                                      email subscription is enabled.
                                    "linkToContent": bool,  # Optional. Whether a
                                      subscription link exists in the email subscription.
                                    "previewImage": bool,  # Optional. Whether a
                                      screenshot of the report exists in the email subscription.
                                    "startDate": "2020-02-20 00:00:00",  #
                                      Optional. The start date and time of the email subscription.
                                    "subArtifactDisplayName": "str",  # Optional.
                                      The page name of the subscribed Power BI item, if it's a report.
                                    "title": "str",  # Optional. The app name.
                                    "users": [
                                        {
                                            "identifier": "str",  #
                                              Identifier of the principal. Required.
                                            "principalType": "str",  #
                                              The principal type. Required. Known values are: "None",
                                              "User", "Group", and "App".
                                            "displayName": "str",  #
                                              Optional. Display name of the principal.
                                            "emailAddress": "str",  #
                                              Optional. Email address of the user.
                                            "graphId": "str",  #
                                              Optional. Identifier of the principal in Microsoft Graph.
                                              Only available for admin APIs.
                                            "profile": {
                                                "id": "str",  # The
                                                  service principal profile ID. Required.
                                                "displayName": "str"
                                                  # Optional. The service principal profile name.
                                            },
                                            "userType": "str"  #
                                              Optional. Type of the user.
                                        }
                                    ]
                                }
                            ],
                            "users": [
                                {
                                    "identifier": "str",  # Identifier of the
                                      principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "reportUserAccessRight": "str",  # The access
                                      right that the user has for the report (permission level).
                                      Required. Known values are: "None", "Read", "ReadWrite",
                                      "ReadReshare", "ReadCopy", and "Owner".
                                    "displayName": "str",  # Optional. Display
                                      name of the principal.
                                    "emailAddress": "str",  # Optional. Email
                                      address of the user.
                                    "graphId": "str",  # Optional. Identifier of
                                      the principal in Microsoft Graph. Only available for admin APIs.
                                    "profile": {
                                        "id": "str",  # The service principal
                                          profile ID. Required.
                                        "displayName": "str"  # Optional. The
                                          service principal profile name.
                                    },
                                    "userType": "str"  # Optional. Type of the
                                      user.
                                }
                            ],
                            "webUrl": "str",  # Optional. The web URL of the report.
                            "workspaceId": "str"  # Optional. The workspace ID (GUID) of
                              the report. This property will be returned only in GetReportsAsAdmin.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_reports_get_reports_in_group_as_admin_request(
            group_id=group_id,
            filter=filter,
            top=top,
            skip=skip,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_reports_as_admin(
        self, *, filter: Optional[str] = None, top: Optional[int] = None, skip: Optional[int] = None, **kwargs: Any
    ) -> JSON:
        """Returns a list of reports for the organization.

        Permissions
        -----------


        * The user must have administrator rights (such as Office 365 Global Administrator or Power BI
        Service Administrator) or authenticate using a service principal.
        * Delegated permissions are supported.

        When running under service prinicipal authentication, an app **must not** have any
        admin-consent required premissions for Power BI set on it in the Azure portal.

        Required Scope
        --------------

        Tenant.Read.All or Tenant.ReadWrite.All

        Relevant only when authenticating via a standard delegated admin access token. Must not be
        present when authentication via a service principal is used.

        Limitations
        -----------

        Maximum 1 request per 10 minutes.
        :code:`<br>`:code:`<br>`.

        :keyword filter: Filters the results, based on a boolean condition. Default value is None.
        :paramtype filter: str
        :keyword top: Returns only the first n results. Default value is None.
        :paramtype top: int
        :keyword skip: Skips the first n results. Default value is None.
        :paramtype skip: int
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional. OData context.
                    "value": [
                        {
                            "id": "str",  # The report ID. Required.
                            "appId": "str",  # Optional. The app ID, returned only if the
                              report belongs to an app.
                            "createdBy": "str",  # Optional. The report owner. Available
                              only for reports created after June 2019.
                            "createdDateTime": "2020-02-20 00:00:00",  # Optional. The
                              report creation date and time.
                            "datasetId": "str",  # Optional. The dataset ID of the
                              report.
                            "description": "str",  # Optional. The report description.
                            "embedUrl": "str",  # Optional. The embed URL of the report.
                            "modifiedBy": "str",  # Optional. The last user that modified
                              the report.
                            "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. The
                              date and time that the report was last modified.
                            "name": "str",  # Optional. The name of the report.
                            "reportType": "str",  # Optional. The report type.
                              "PaginatedReport"
                            "subscriptions": [
                                {
                                    "id": "str",  # The subscription ID.
                                      Required.
                                    "artifactDisplayName": "str",  # Optional.
                                      The name of the subscribed Power BI item (such as a report or a
                                      dashboard).
                                    "artifactId": "str",  # Optional. The ID of
                                      the subscribed Power BI item (such as a report or a dashboard).
                                    "artifactType": "str",  # Optional. The type
                                      of Power BI item (for example a ``Report``"" , ``Dashboard``"" ,
                                      or ``Dataset``"" ).
                                    "attachmentFormat": "str",  # Optional.
                                      Format of the report attached in the email subscription.
                                    "endDate": "2020-02-20 00:00:00",  #
                                      Optional. The end date and time of the email subscription.
                                    "frequency": "str",  # Optional. The
                                      frequency of the email subscription.
                                    "isEnabled": bool,  # Optional. Whether the
                                      email subscription is enabled.
                                    "linkToContent": bool,  # Optional. Whether a
                                      subscription link exists in the email subscription.
                                    "previewImage": bool,  # Optional. Whether a
                                      screenshot of the report exists in the email subscription.
                                    "startDate": "2020-02-20 00:00:00",  #
                                      Optional. The start date and time of the email subscription.
                                    "subArtifactDisplayName": "str",  # Optional.
                                      The page name of the subscribed Power BI item, if it's a report.
                                    "title": "str",  # Optional. The app name.
                                    "users": [
                                        {
                                            "identifier": "str",  #
                                              Identifier of the principal. Required.
                                            "principalType": "str",  #
                                              The principal type. Required. Known values are: "None",
                                              "User", "Group", and "App".
                                            "displayName": "str",  #
                                              Optional. Display name of the principal.
                                            "emailAddress": "str",  #
                                              Optional. Email address of the user.
                                            "graphId": "str",  #
                                              Optional. Identifier of the principal in Microsoft Graph.
                                              Only available for admin APIs.
                                            "profile": {
                                                "id": "str",  # The
                                                  service principal profile ID. Required.
                                                "displayName": "str"
                                                  # Optional. The service principal profile name.
                                            },
                                            "userType": "str"  #
                                              Optional. Type of the user.
                                        }
                                    ]
                                }
                            ],
                            "users": [
                                {
                                    "identifier": "str",  # Identifier of the
                                      principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "reportUserAccessRight": "str",  # The access
                                      right that the user has for the report (permission level).
                                      Required. Known values are: "None", "Read", "ReadWrite",
                                      "ReadReshare", "ReadCopy", and "Owner".
                                    "displayName": "str",  # Optional. Display
                                      name of the principal.
                                    "emailAddress": "str",  # Optional. Email
                                      address of the user.
                                    "graphId": "str",  # Optional. Identifier of
                                      the principal in Microsoft Graph. Only available for admin APIs.
                                    "profile": {
                                        "id": "str",  # The service principal
                                          profile ID. Required.
                                        "displayName": "str"  # Optional. The
                                          service principal profile name.
                                    },
                                    "userType": "str"  # Optional. Type of the
                                      user.
                                }
                            ],
                            "webUrl": "str",  # Optional. The web URL of the report.
                            "workspaceId": "str"  # Optional. The workspace ID (GUID) of
                              the report. This property will be returned only in GetReportsAsAdmin.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_reports_get_reports_as_admin_request(
            filter=filter,
            top=top,
            skip=skip,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_report_users_as_admin(self, report_id: str, **kwargs: Any) -> JSON:
        """Returns a list of users that have access to the specified report.

        Permissions
        -----------


        * The user must have administrator rights (such as Office 365 Global Administrator or Power BI
        Service Administrator) or authenticate using a service principal.
        * Delegated permissions are supported.

        When running under service prinicipal authentication, an app **must not** have any
        admin-consent required premissions for Power BI set on it in the Azure portal.

        Required Scope
        --------------

        Tenant.Read.All or Tenant.ReadWrite.All

        Relevant only when authenticating via a standard delegated admin access token. Must not be
        present when authentication via a service principal is used.

        Limitations
        -----------

        Maximum 200 requests per hour.
        :code:`<br>`:code:`<br>`.

        :param report_id: The report ID. Required.
        :type report_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional.
                    "value": [
                        {
                            "identifier": "str",  # Identifier of the principal.
                              Required.
                            "principalType": "str",  # The principal type. Required.
                              Known values are: "None", "User", "Group", and "App".
                            "reportUserAccessRight": "str",  # The access right that the
                              user has for the report (permission level). Required. Known values are:
                              "None", "Read", "ReadWrite", "ReadReshare", "ReadCopy", and "Owner".
                            "displayName": "str",  # Optional. Display name of the
                              principal.
                            "emailAddress": "str",  # Optional. Email address of the
                              user.
                            "graphId": "str",  # Optional. Identifier of the principal in
                              Microsoft Graph. Only available for admin APIs.
                            "profile": {
                                "id": "str",  # The service principal profile ID.
                                  Required.
                                "displayName": "str"  # Optional. The service
                                  principal profile name.
                            },
                            "userType": "str"  # Optional. Type of the user.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_reports_get_report_users_as_admin_request(
            report_id=report_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_report_subscriptions_as_admin(self, report_id: str, **kwargs: Any) -> JSON:
        """Returns a list of report subscriptions along with subscriber details. This is a preview API
        call.

        Permissions
        -----------


        * The user must have administrator rights (such as Office 365 Global Administrator or Power BI
        Service Administrator) or authenticate using a service principal.
        * Delegated permissions are supported.

        Required Scope
        --------------

        Tenant.Read.All or Tenant.ReadWrite.All

        Limitations
        -----------

        Maximum 200 requests per hour.
        :code:`<br>`:code:`<br>`.

        :param report_id: The report ID. Required.
        :type report_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional.
                    "value": [
                        {
                            "id": "str",  # The subscription ID. Required.
                            "artifactDisplayName": "str",  # Optional. The name of the
                              subscribed Power BI item (such as a report or a dashboard).
                            "artifactId": "str",  # Optional. The ID of the subscribed
                              Power BI item (such as a report or a dashboard).
                            "artifactType": "str",  # Optional. The type of Power BI item
                              (for example a ``Report``"" , ``Dashboard``"" , or ``Dataset``"" ).
                            "attachmentFormat": "str",  # Optional. Format of the report
                              attached in the email subscription.
                            "endDate": "2020-02-20 00:00:00",  # Optional. The end date
                              and time of the email subscription.
                            "frequency": "str",  # Optional. The frequency of the email
                              subscription.
                            "isEnabled": bool,  # Optional. Whether the email
                              subscription is enabled.
                            "linkToContent": bool,  # Optional. Whether a subscription
                              link exists in the email subscription.
                            "previewImage": bool,  # Optional. Whether a screenshot of
                              the report exists in the email subscription.
                            "startDate": "2020-02-20 00:00:00",  # Optional. The start
                              date and time of the email subscription.
                            "subArtifactDisplayName": "str",  # Optional. The page name
                              of the subscribed Power BI item, if it's a report.
                            "title": "str",  # Optional. The app name.
                            "users": [
                                {
                                    "identifier": "str",  # Identifier of the
                                      principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "displayName": "str",  # Optional. Display
                                      name of the principal.
                                    "emailAddress": "str",  # Optional. Email
                                      address of the user.
                                    "graphId": "str",  # Optional. Identifier of
                                      the principal in Microsoft Graph. Only available for admin APIs.
                                    "profile": {
                                        "id": "str",  # The service principal
                                          profile ID. Required.
                                        "displayName": "str"  # Optional. The
                                          service principal profile name.
                                    },
                                    "userType": "str"  # Optional. Type of the
                                      user.
                                }
                            ]
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_reports_get_report_subscriptions_as_admin_request(
            report_id=report_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def take_over_in_group(  # pylint: disable=inconsistent-return-statements
        self, group_id: str, report_id: str, **kwargs: Any
    ) -> None:
        """Transfers ownership of the data sources for the specified paginated report (RDL) to the current
        authorized user.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Report.ReadWrite.All

        Limitations
        -----------

        Only supports paginated reports.
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param report_id: The report ID. Required.
        :type report_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_reports_take_over_in_group_request(
            group_id=group_id,
            report_id=report_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class DashboardsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~power_bi_client.aio.PowerBIClient`'s
        :attr:`dashboards` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get_dashboards(self, **kwargs: Any) -> JSON:
        """Returns a list of dashboards from **My workspace**.

        This API also returns shared dashboards and dashboards from shared apps. Dashboards that reside
        in shared workspaces can be accessed using the `Get Dashboards In Group API
        </rest/api/power-bi/dashboards/get-dashboards-in-group>`_.

        Required Scope
        --------------

        Dashboard.ReadWrite.All or Dashboard.Read.All
        :code:`<br>`:code:`<br>`.

        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional. OData context.
                    "value": [
                        {
                            "id": "str",  # The dashboard ID. Required.
                            "appId": "str",  # Optional. The app ID, returned only if the
                              dashboard belongs to an app.
                            "displayName": "str",  # Optional. The display name of the
                              dashboard.
                            "embedUrl": "str",  # Optional. The embed URL of the
                              dashboard.
                            "isReadOnly": bool,  # Optional. Whether the dashboard is
                              read-only.
                            "subscriptions": [
                                {
                                    "id": "str",  # The subscription ID.
                                      Required.
                                    "artifactDisplayName": "str",  # Optional.
                                      The name of the subscribed Power BI item (such as a report or a
                                      dashboard).
                                    "artifactId": "str",  # Optional. The ID of
                                      the subscribed Power BI item (such as a report or a dashboard).
                                    "artifactType": "str",  # Optional. The type
                                      of Power BI item (for example a ``Report``"" , ``Dashboard``"" ,
                                      or ``Dataset``"" ).
                                    "attachmentFormat": "str",  # Optional.
                                      Format of the report attached in the email subscription.
                                    "endDate": "2020-02-20 00:00:00",  #
                                      Optional. The end date and time of the email subscription.
                                    "frequency": "str",  # Optional. The
                                      frequency of the email subscription.
                                    "isEnabled": bool,  # Optional. Whether the
                                      email subscription is enabled.
                                    "linkToContent": bool,  # Optional. Whether a
                                      subscription link exists in the email subscription.
                                    "previewImage": bool,  # Optional. Whether a
                                      screenshot of the report exists in the email subscription.
                                    "startDate": "2020-02-20 00:00:00",  #
                                      Optional. The start date and time of the email subscription.
                                    "subArtifactDisplayName": "str",  # Optional.
                                      The page name of the subscribed Power BI item, if it's a report.
                                    "title": "str",  # Optional. The app name.
                                    "users": [
                                        {
                                            "identifier": "str",  #
                                              Identifier of the principal. Required.
                                            "principalType": "str",  #
                                              The principal type. Required. Known values are: "None",
                                              "User", "Group", and "App".
                                            "displayName": "str",  #
                                              Optional. Display name of the principal.
                                            "emailAddress": "str",  #
                                              Optional. Email address of the user.
                                            "graphId": "str",  #
                                              Optional. Identifier of the principal in Microsoft Graph.
                                              Only available for admin APIs.
                                            "profile": {
                                                "id": "str",  # The
                                                  service principal profile ID. Required.
                                                "displayName": "str"
                                                  # Optional. The service principal profile name.
                                            },
                                            "userType": "str"  #
                                              Optional. Type of the user.
                                        }
                                    ]
                                }
                            ],
                            "users": [
                                {
                                    "dashboardUserAccessRight": "str",  # The
                                      access right that the user has for the dashboard (permission
                                      level). Required. Known values are: "None", "Read", "ReadWrite",
                                      "ReadReshare", "ReadCopy", and "Owner".
                                    "identifier": "str",  # Identifier of the
                                      principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "displayName": "str",  # Optional. Display
                                      name of the principal.
                                    "emailAddress": "str",  # Optional. Email
                                      address of the user.
                                    "graphId": "str",  # Optional. Identifier of
                                      the principal in Microsoft Graph. Only available for admin APIs.
                                    "profile": {
                                        "id": "str",  # The service principal
                                          profile ID. Required.
                                        "displayName": "str"  # Optional. The
                                          service principal profile name.
                                    },
                                    "userType": "str"  # Optional. Type of the
                                      user.
                                }
                            ],
                            "webUrl": "str"  # Optional. The web URL of the dashboard.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_dashboards_get_dashboards_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def add_dashboard(
        self, request_parameters: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Creates a new empty dashboard in **My workspace**.

        Required Scope
        --------------

        Content.Create
        :code:`<br>`:code:`<br>`.

        :param request_parameters: Add dashboard parameters. Required.
        :type request_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                request_parameters = {
                    "name": "str"  # The name of the new dashboard. Required.
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # The dashboard ID. Required.
                    "appId": "str",  # Optional. The app ID, returned only if the dashboard
                      belongs to an app.
                    "displayName": "str",  # Optional. The display name of the dashboard.
                    "embedUrl": "str",  # Optional. The embed URL of the dashboard.
                    "isReadOnly": bool,  # Optional. Whether the dashboard is read-only.
                    "subscriptions": [
                        {
                            "id": "str",  # The subscription ID. Required.
                            "artifactDisplayName": "str",  # Optional. The name of the
                              subscribed Power BI item (such as a report or a dashboard).
                            "artifactId": "str",  # Optional. The ID of the subscribed
                              Power BI item (such as a report or a dashboard).
                            "artifactType": "str",  # Optional. The type of Power BI item
                              (for example a ``Report``"" , ``Dashboard``"" , or ``Dataset``"" ).
                            "attachmentFormat": "str",  # Optional. Format of the report
                              attached in the email subscription.
                            "endDate": "2020-02-20 00:00:00",  # Optional. The end date
                              and time of the email subscription.
                            "frequency": "str",  # Optional. The frequency of the email
                              subscription.
                            "isEnabled": bool,  # Optional. Whether the email
                              subscription is enabled.
                            "linkToContent": bool,  # Optional. Whether a subscription
                              link exists in the email subscription.
                            "previewImage": bool,  # Optional. Whether a screenshot of
                              the report exists in the email subscription.
                            "startDate": "2020-02-20 00:00:00",  # Optional. The start
                              date and time of the email subscription.
                            "subArtifactDisplayName": "str",  # Optional. The page name
                              of the subscribed Power BI item, if it's a report.
                            "title": "str",  # Optional. The app name.
                            "users": [
                                {
                                    "identifier": "str",  # Identifier of the
                                      principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "displayName": "str",  # Optional. Display
                                      name of the principal.
                                    "emailAddress": "str",  # Optional. Email
                                      address of the user.
                                    "graphId": "str",  # Optional. Identifier of
                                      the principal in Microsoft Graph. Only available for admin APIs.
                                    "profile": {
                                        "id": "str",  # The service principal
                                          profile ID. Required.
                                        "displayName": "str"  # Optional. The
                                          service principal profile name.
                                    },
                                    "userType": "str"  # Optional. Type of the
                                      user.
                                }
                            ]
                        }
                    ],
                    "users": [
                        {
                            "dashboardUserAccessRight": "str",  # The access right that
                              the user has for the dashboard (permission level). Required. Known values
                              are: "None", "Read", "ReadWrite", "ReadReshare", "ReadCopy", and "Owner".
                            "identifier": "str",  # Identifier of the principal.
                              Required.
                            "principalType": "str",  # The principal type. Required.
                              Known values are: "None", "User", "Group", and "App".
                            "displayName": "str",  # Optional. Display name of the
                              principal.
                            "emailAddress": "str",  # Optional. Email address of the
                              user.
                            "graphId": "str",  # Optional. Identifier of the principal in
                              Microsoft Graph. Only available for admin APIs.
                            "profile": {
                                "id": "str",  # The service principal profile ID.
                                  Required.
                                "displayName": "str"  # Optional. The service
                                  principal profile name.
                            },
                            "userType": "str"  # Optional. Type of the user.
                        }
                    ],
                    "webUrl": "str"  # Optional. The web URL of the dashboard.
                }
        """

    @overload
    async def add_dashboard(
        self, request_parameters: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Creates a new empty dashboard in **My workspace**.

        Required Scope
        --------------

        Content.Create
        :code:`<br>`:code:`<br>`.

        :param request_parameters: Add dashboard parameters. Required.
        :type request_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # The dashboard ID. Required.
                    "appId": "str",  # Optional. The app ID, returned only if the dashboard
                      belongs to an app.
                    "displayName": "str",  # Optional. The display name of the dashboard.
                    "embedUrl": "str",  # Optional. The embed URL of the dashboard.
                    "isReadOnly": bool,  # Optional. Whether the dashboard is read-only.
                    "subscriptions": [
                        {
                            "id": "str",  # The subscription ID. Required.
                            "artifactDisplayName": "str",  # Optional. The name of the
                              subscribed Power BI item (such as a report or a dashboard).
                            "artifactId": "str",  # Optional. The ID of the subscribed
                              Power BI item (such as a report or a dashboard).
                            "artifactType": "str",  # Optional. The type of Power BI item
                              (for example a ``Report``"" , ``Dashboard``"" , or ``Dataset``"" ).
                            "attachmentFormat": "str",  # Optional. Format of the report
                              attached in the email subscription.
                            "endDate": "2020-02-20 00:00:00",  # Optional. The end date
                              and time of the email subscription.
                            "frequency": "str",  # Optional. The frequency of the email
                              subscription.
                            "isEnabled": bool,  # Optional. Whether the email
                              subscription is enabled.
                            "linkToContent": bool,  # Optional. Whether a subscription
                              link exists in the email subscription.
                            "previewImage": bool,  # Optional. Whether a screenshot of
                              the report exists in the email subscription.
                            "startDate": "2020-02-20 00:00:00",  # Optional. The start
                              date and time of the email subscription.
                            "subArtifactDisplayName": "str",  # Optional. The page name
                              of the subscribed Power BI item, if it's a report.
                            "title": "str",  # Optional. The app name.
                            "users": [
                                {
                                    "identifier": "str",  # Identifier of the
                                      principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "displayName": "str",  # Optional. Display
                                      name of the principal.
                                    "emailAddress": "str",  # Optional. Email
                                      address of the user.
                                    "graphId": "str",  # Optional. Identifier of
                                      the principal in Microsoft Graph. Only available for admin APIs.
                                    "profile": {
                                        "id": "str",  # The service principal
                                          profile ID. Required.
                                        "displayName": "str"  # Optional. The
                                          service principal profile name.
                                    },
                                    "userType": "str"  # Optional. Type of the
                                      user.
                                }
                            ]
                        }
                    ],
                    "users": [
                        {
                            "dashboardUserAccessRight": "str",  # The access right that
                              the user has for the dashboard (permission level). Required. Known values
                              are: "None", "Read", "ReadWrite", "ReadReshare", "ReadCopy", and "Owner".
                            "identifier": "str",  # Identifier of the principal.
                              Required.
                            "principalType": "str",  # The principal type. Required.
                              Known values are: "None", "User", "Group", and "App".
                            "displayName": "str",  # Optional. Display name of the
                              principal.
                            "emailAddress": "str",  # Optional. Email address of the
                              user.
                            "graphId": "str",  # Optional. Identifier of the principal in
                              Microsoft Graph. Only available for admin APIs.
                            "profile": {
                                "id": "str",  # The service principal profile ID.
                                  Required.
                                "displayName": "str"  # Optional. The service
                                  principal profile name.
                            },
                            "userType": "str"  # Optional. Type of the user.
                        }
                    ],
                    "webUrl": "str"  # Optional. The web URL of the dashboard.
                }
        """

    @distributed_trace_async
    async def add_dashboard(self, request_parameters: Union[JSON, IO], **kwargs: Any) -> JSON:
        """Creates a new empty dashboard in **My workspace**.

        Required Scope
        --------------

        Content.Create
        :code:`<br>`:code:`<br>`.

        :param request_parameters: Add dashboard parameters. Is either a JSON type or a IO type.
         Required.
        :type request_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                request_parameters = {
                    "name": "str"  # The name of the new dashboard. Required.
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # The dashboard ID. Required.
                    "appId": "str",  # Optional. The app ID, returned only if the dashboard
                      belongs to an app.
                    "displayName": "str",  # Optional. The display name of the dashboard.
                    "embedUrl": "str",  # Optional. The embed URL of the dashboard.
                    "isReadOnly": bool,  # Optional. Whether the dashboard is read-only.
                    "subscriptions": [
                        {
                            "id": "str",  # The subscription ID. Required.
                            "artifactDisplayName": "str",  # Optional. The name of the
                              subscribed Power BI item (such as a report or a dashboard).
                            "artifactId": "str",  # Optional. The ID of the subscribed
                              Power BI item (such as a report or a dashboard).
                            "artifactType": "str",  # Optional. The type of Power BI item
                              (for example a ``Report``"" , ``Dashboard``"" , or ``Dataset``"" ).
                            "attachmentFormat": "str",  # Optional. Format of the report
                              attached in the email subscription.
                            "endDate": "2020-02-20 00:00:00",  # Optional. The end date
                              and time of the email subscription.
                            "frequency": "str",  # Optional. The frequency of the email
                              subscription.
                            "isEnabled": bool,  # Optional. Whether the email
                              subscription is enabled.
                            "linkToContent": bool,  # Optional. Whether a subscription
                              link exists in the email subscription.
                            "previewImage": bool,  # Optional. Whether a screenshot of
                              the report exists in the email subscription.
                            "startDate": "2020-02-20 00:00:00",  # Optional. The start
                              date and time of the email subscription.
                            "subArtifactDisplayName": "str",  # Optional. The page name
                              of the subscribed Power BI item, if it's a report.
                            "title": "str",  # Optional. The app name.
                            "users": [
                                {
                                    "identifier": "str",  # Identifier of the
                                      principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "displayName": "str",  # Optional. Display
                                      name of the principal.
                                    "emailAddress": "str",  # Optional. Email
                                      address of the user.
                                    "graphId": "str",  # Optional. Identifier of
                                      the principal in Microsoft Graph. Only available for admin APIs.
                                    "profile": {
                                        "id": "str",  # The service principal
                                          profile ID. Required.
                                        "displayName": "str"  # Optional. The
                                          service principal profile name.
                                    },
                                    "userType": "str"  # Optional. Type of the
                                      user.
                                }
                            ]
                        }
                    ],
                    "users": [
                        {
                            "dashboardUserAccessRight": "str",  # The access right that
                              the user has for the dashboard (permission level). Required. Known values
                              are: "None", "Read", "ReadWrite", "ReadReshare", "ReadCopy", and "Owner".
                            "identifier": "str",  # Identifier of the principal.
                              Required.
                            "principalType": "str",  # The principal type. Required.
                              Known values are: "None", "User", "Group", and "App".
                            "displayName": "str",  # Optional. Display name of the
                              principal.
                            "emailAddress": "str",  # Optional. Email address of the
                              user.
                            "graphId": "str",  # Optional. Identifier of the principal in
                              Microsoft Graph. Only available for admin APIs.
                            "profile": {
                                "id": "str",  # The service principal profile ID.
                                  Required.
                                "displayName": "str"  # Optional. The service
                                  principal profile name.
                            },
                            "userType": "str"  # Optional. Type of the user.
                        }
                    ],
                    "webUrl": "str"  # Optional. The web URL of the dashboard.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(request_parameters, (IOBase, bytes)):
            _content = request_parameters
        else:
            _json = request_parameters

        _request = build_dashboards_add_dashboard_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_dashboard(self, dashboard_id: str, **kwargs: Any) -> JSON:
        """Returns the specified dashboard from **My workspace**.

        Required Scope
        --------------

        Dashboard.ReadWrite.All or Dashboard.Read.All
        :code:`<br>`:code:`<br>`.

        :param dashboard_id: The dashboard ID. Required.
        :type dashboard_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # The dashboard ID. Required.
                    "appId": "str",  # Optional. The app ID, returned only if the dashboard
                      belongs to an app.
                    "displayName": "str",  # Optional. The display name of the dashboard.
                    "embedUrl": "str",  # Optional. The embed URL of the dashboard.
                    "isReadOnly": bool,  # Optional. Whether the dashboard is read-only.
                    "subscriptions": [
                        {
                            "id": "str",  # The subscription ID. Required.
                            "artifactDisplayName": "str",  # Optional. The name of the
                              subscribed Power BI item (such as a report or a dashboard).
                            "artifactId": "str",  # Optional. The ID of the subscribed
                              Power BI item (such as a report or a dashboard).
                            "artifactType": "str",  # Optional. The type of Power BI item
                              (for example a ``Report``"" , ``Dashboard``"" , or ``Dataset``"" ).
                            "attachmentFormat": "str",  # Optional. Format of the report
                              attached in the email subscription.
                            "endDate": "2020-02-20 00:00:00",  # Optional. The end date
                              and time of the email subscription.
                            "frequency": "str",  # Optional. The frequency of the email
                              subscription.
                            "isEnabled": bool,  # Optional. Whether the email
                              subscription is enabled.
                            "linkToContent": bool,  # Optional. Whether a subscription
                              link exists in the email subscription.
                            "previewImage": bool,  # Optional. Whether a screenshot of
                              the report exists in the email subscription.
                            "startDate": "2020-02-20 00:00:00",  # Optional. The start
                              date and time of the email subscription.
                            "subArtifactDisplayName": "str",  # Optional. The page name
                              of the subscribed Power BI item, if it's a report.
                            "title": "str",  # Optional. The app name.
                            "users": [
                                {
                                    "identifier": "str",  # Identifier of the
                                      principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "displayName": "str",  # Optional. Display
                                      name of the principal.
                                    "emailAddress": "str",  # Optional. Email
                                      address of the user.
                                    "graphId": "str",  # Optional. Identifier of
                                      the principal in Microsoft Graph. Only available for admin APIs.
                                    "profile": {
                                        "id": "str",  # The service principal
                                          profile ID. Required.
                                        "displayName": "str"  # Optional. The
                                          service principal profile name.
                                    },
                                    "userType": "str"  # Optional. Type of the
                                      user.
                                }
                            ]
                        }
                    ],
                    "users": [
                        {
                            "dashboardUserAccessRight": "str",  # The access right that
                              the user has for the dashboard (permission level). Required. Known values
                              are: "None", "Read", "ReadWrite", "ReadReshare", "ReadCopy", and "Owner".
                            "identifier": "str",  # Identifier of the principal.
                              Required.
                            "principalType": "str",  # The principal type. Required.
                              Known values are: "None", "User", "Group", and "App".
                            "displayName": "str",  # Optional. Display name of the
                              principal.
                            "emailAddress": "str",  # Optional. Email address of the
                              user.
                            "graphId": "str",  # Optional. Identifier of the principal in
                              Microsoft Graph. Only available for admin APIs.
                            "profile": {
                                "id": "str",  # The service principal profile ID.
                                  Required.
                                "displayName": "str"  # Optional. The service
                                  principal profile name.
                            },
                            "userType": "str"  # Optional. Type of the user.
                        }
                    ],
                    "webUrl": "str"  # Optional. The web URL of the dashboard.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_dashboards_get_dashboard_request(
            dashboard_id=dashboard_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def delete_dashboard(  # pylint: disable=inconsistent-return-statements
        self, dashboard_id: str, **kwargs: Any
    ) -> None:
        """Deletes the specified dashboard from **My workspace**.

        Required Scope
        --------------

        Dashboard.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param dashboard_id: The dashboard ID. Required.
        :type dashboard_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_dashboards_delete_dashboard_request(
            dashboard_id=dashboard_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get_tiles(self, dashboard_id: str, **kwargs: Any) -> JSON:
        """Returns a list of tiles within the specified dashboard from **My workspace**.

        Supported tiles include datasets and live tiles that contain an entire report page.

        Required Scope
        --------------

        Dashboard.ReadWrite.All or Dashboard.Read.All

        Limitations
        -----------

        Titles that are edited in the report before the visual is added to the dashboard, are not
        returned. To return these titles, edit them in the dashboard.
        :code:`<br>`:code:`<br>`.

        :param dashboard_id: The dashboard ID. Required.
        :type dashboard_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional. OData context.
                    "value": [
                        {
                            "id": "str",  # The tile ID. Required.
                            "colSpan": 0,  # Optional. The number of tile span columns.
                            "datasetId": "str",  # Optional. The dataset ID. Available
                              only for tiles created from a report or by using a dataset, such as Q&A
                              tiles.
                            "embedData": "str",  # Optional. The embed data for the tile.
                            "embedUrl": "str",  # Optional. The embed URL of the tile.
                            "reportId": "str",  # Optional. The report ID. Available only
                              for tiles created from a report.
                            "rowSpan": 0,  # Optional. The number of tile span rows.
                            "title": "str"  # Optional. The display name of the tile.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_dashboards_get_tiles_request(
            dashboard_id=dashboard_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_tile(self, dashboard_id: str, tile_id: str, **kwargs: Any) -> JSON:
        """Returns the specified tile within the specified dashboard from **My workspace**.

        Supported tiles include datasets and live tiles that contain an entire report page.

        Required Scope
        --------------

        Dashboard.ReadWrite.All or Dashboard.Read.All

        Limitations
        -----------

        Titles that are edited in the report before the visual is added to the dashboard, are not
        returned. To return these titles, edit them in the dashboard.
        :code:`<br>`:code:`<br>`.

        :param dashboard_id: The dashboard ID. Required.
        :type dashboard_id: str
        :param tile_id: The tile ID. Required.
        :type tile_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # The tile ID. Required.
                    "colSpan": 0,  # Optional. The number of tile span columns.
                    "datasetId": "str",  # Optional. The dataset ID. Available only for tiles
                      created from a report or by using a dataset, such as Q&A tiles.
                    "embedData": "str",  # Optional. The embed data for the tile.
                    "embedUrl": "str",  # Optional. The embed URL of the tile.
                    "reportId": "str",  # Optional. The report ID. Available only for tiles
                      created from a report.
                    "rowSpan": 0,  # Optional. The number of tile span rows.
                    "title": "str"  # Optional. The display name of the tile.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_dashboards_get_tile_request(
            dashboard_id=dashboard_id,
            tile_id=tile_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def clone_tile(
        self,
        dashboard_id: str,
        tile_id: str,
        request_parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Clones the specified tile from **My workspace**.

        When a tile is cloned to another workspace and bound to another report and dataset, it's cloned
        as is with its underlying query containing the original report filters.

        If the target report ID and target dataset are missing, the following can occur:


        * If you're cloning a tile within the same workspace, the report and dataset links will be
        cloned from the source tile.
        * If you're cloning a tile within a different workspace, report and dataset links will be
        removed, and the tile will be broken.

        Required Scope
        --------------

        Dashboard.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param dashboard_id: The dashboard ID. Required.
        :type dashboard_id: str
        :param tile_id: The tile ID. Required.
        :type tile_id: str
        :param request_parameters: Clone tile parameters. Required.
        :type request_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                request_parameters = {
                    "targetDashboardId": "str",  # The target dashboard ID. Required.
                    "positionConflictAction": "str",  # Optional. Optional. A parameter for
                      specifying an action in case of a position conflict. If there's a conflict and
                      this parameter isn't provided, then the default value ``Tail`` will be applied.
                      If there's no conflict, then the cloned tile will have the same position as in
                      the source. Known values are: "Tail" and "Abort".
                    "targetModelId": "str",  # Optional. Optional. A parameter for specifying a
                      target model ID. When cloning a tile linked to a dataset, pass the target model
                      ID to rebind the new tile to a different dataset.
                    "targetReportId": "str",  # Optional. Optional. A parameter for specifying a
                      target report ID. When cloning a tile linked to a report, pass the target report
                      ID to rebind the new tile to a different report.
                    "targetWorkspaceId": "str"  # Optional. Optional. A parameter for specifying
                      a target workspace ID. An empty GUID (""
                      ``00000000-0000-0000-0000-000000000000``"" ) indicates **My workspace**. If this
                      parameter isn't provided, the tile will be cloned within the same workspace as
                      the source tile.
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # The tile ID. Required.
                    "colSpan": 0,  # Optional. The number of tile span columns.
                    "datasetId": "str",  # Optional. The dataset ID. Available only for tiles
                      created from a report or by using a dataset, such as Q&A tiles.
                    "embedData": "str",  # Optional. The embed data for the tile.
                    "embedUrl": "str",  # Optional. The embed URL of the tile.
                    "reportId": "str",  # Optional. The report ID. Available only for tiles
                      created from a report.
                    "rowSpan": 0,  # Optional. The number of tile span rows.
                    "title": "str"  # Optional. The display name of the tile.
                }
        """

    @overload
    async def clone_tile(
        self,
        dashboard_id: str,
        tile_id: str,
        request_parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Clones the specified tile from **My workspace**.

        When a tile is cloned to another workspace and bound to another report and dataset, it's cloned
        as is with its underlying query containing the original report filters.

        If the target report ID and target dataset are missing, the following can occur:


        * If you're cloning a tile within the same workspace, the report and dataset links will be
        cloned from the source tile.
        * If you're cloning a tile within a different workspace, report and dataset links will be
        removed, and the tile will be broken.

        Required Scope
        --------------

        Dashboard.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param dashboard_id: The dashboard ID. Required.
        :type dashboard_id: str
        :param tile_id: The tile ID. Required.
        :type tile_id: str
        :param request_parameters: Clone tile parameters. Required.
        :type request_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # The tile ID. Required.
                    "colSpan": 0,  # Optional. The number of tile span columns.
                    "datasetId": "str",  # Optional. The dataset ID. Available only for tiles
                      created from a report or by using a dataset, such as Q&A tiles.
                    "embedData": "str",  # Optional. The embed data for the tile.
                    "embedUrl": "str",  # Optional. The embed URL of the tile.
                    "reportId": "str",  # Optional. The report ID. Available only for tiles
                      created from a report.
                    "rowSpan": 0,  # Optional. The number of tile span rows.
                    "title": "str"  # Optional. The display name of the tile.
                }
        """

    @distributed_trace_async
    async def clone_tile(
        self, dashboard_id: str, tile_id: str, request_parameters: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Clones the specified tile from **My workspace**.

        When a tile is cloned to another workspace and bound to another report and dataset, it's cloned
        as is with its underlying query containing the original report filters.

        If the target report ID and target dataset are missing, the following can occur:


        * If you're cloning a tile within the same workspace, the report and dataset links will be
        cloned from the source tile.
        * If you're cloning a tile within a different workspace, report and dataset links will be
        removed, and the tile will be broken.

        Required Scope
        --------------

        Dashboard.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param dashboard_id: The dashboard ID. Required.
        :type dashboard_id: str
        :param tile_id: The tile ID. Required.
        :type tile_id: str
        :param request_parameters: Clone tile parameters. Is either a JSON type or a IO type. Required.
        :type request_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                request_parameters = {
                    "targetDashboardId": "str",  # The target dashboard ID. Required.
                    "positionConflictAction": "str",  # Optional. Optional. A parameter for
                      specifying an action in case of a position conflict. If there's a conflict and
                      this parameter isn't provided, then the default value ``Tail`` will be applied.
                      If there's no conflict, then the cloned tile will have the same position as in
                      the source. Known values are: "Tail" and "Abort".
                    "targetModelId": "str",  # Optional. Optional. A parameter for specifying a
                      target model ID. When cloning a tile linked to a dataset, pass the target model
                      ID to rebind the new tile to a different dataset.
                    "targetReportId": "str",  # Optional. Optional. A parameter for specifying a
                      target report ID. When cloning a tile linked to a report, pass the target report
                      ID to rebind the new tile to a different report.
                    "targetWorkspaceId": "str"  # Optional. Optional. A parameter for specifying
                      a target workspace ID. An empty GUID (""
                      ``00000000-0000-0000-0000-000000000000``"" ) indicates **My workspace**. If this
                      parameter isn't provided, the tile will be cloned within the same workspace as
                      the source tile.
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # The tile ID. Required.
                    "colSpan": 0,  # Optional. The number of tile span columns.
                    "datasetId": "str",  # Optional. The dataset ID. Available only for tiles
                      created from a report or by using a dataset, such as Q&A tiles.
                    "embedData": "str",  # Optional. The embed data for the tile.
                    "embedUrl": "str",  # Optional. The embed URL of the tile.
                    "reportId": "str",  # Optional. The report ID. Available only for tiles
                      created from a report.
                    "rowSpan": 0,  # Optional. The number of tile span rows.
                    "title": "str"  # Optional. The display name of the tile.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(request_parameters, (IOBase, bytes)):
            _content = request_parameters
        else:
            _json = request_parameters

        _request = build_dashboards_clone_tile_request(
            dashboard_id=dashboard_id,
            tile_id=tile_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_dashboards_in_group(self, group_id: str, **kwargs: Any) -> JSON:
        """Returns a list of dashboards from the specified workspace.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Dashboard.ReadWrite.All or Dashboard.Read.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional. OData context.
                    "value": [
                        {
                            "id": "str",  # The dashboard ID. Required.
                            "appId": "str",  # Optional. The app ID, returned only if the
                              dashboard belongs to an app.
                            "displayName": "str",  # Optional. The display name of the
                              dashboard.
                            "embedUrl": "str",  # Optional. The embed URL of the
                              dashboard.
                            "isReadOnly": bool,  # Optional. Whether the dashboard is
                              read-only.
                            "subscriptions": [
                                {
                                    "id": "str",  # The subscription ID.
                                      Required.
                                    "artifactDisplayName": "str",  # Optional.
                                      The name of the subscribed Power BI item (such as a report or a
                                      dashboard).
                                    "artifactId": "str",  # Optional. The ID of
                                      the subscribed Power BI item (such as a report or a dashboard).
                                    "artifactType": "str",  # Optional. The type
                                      of Power BI item (for example a ``Report``"" , ``Dashboard``"" ,
                                      or ``Dataset``"" ).
                                    "attachmentFormat": "str",  # Optional.
                                      Format of the report attached in the email subscription.
                                    "endDate": "2020-02-20 00:00:00",  #
                                      Optional. The end date and time of the email subscription.
                                    "frequency": "str",  # Optional. The
                                      frequency of the email subscription.
                                    "isEnabled": bool,  # Optional. Whether the
                                      email subscription is enabled.
                                    "linkToContent": bool,  # Optional. Whether a
                                      subscription link exists in the email subscription.
                                    "previewImage": bool,  # Optional. Whether a
                                      screenshot of the report exists in the email subscription.
                                    "startDate": "2020-02-20 00:00:00",  #
                                      Optional. The start date and time of the email subscription.
                                    "subArtifactDisplayName": "str",  # Optional.
                                      The page name of the subscribed Power BI item, if it's a report.
                                    "title": "str",  # Optional. The app name.
                                    "users": [
                                        {
                                            "identifier": "str",  #
                                              Identifier of the principal. Required.
                                            "principalType": "str",  #
                                              The principal type. Required. Known values are: "None",
                                              "User", "Group", and "App".
                                            "displayName": "str",  #
                                              Optional. Display name of the principal.
                                            "emailAddress": "str",  #
                                              Optional. Email address of the user.
                                            "graphId": "str",  #
                                              Optional. Identifier of the principal in Microsoft Graph.
                                              Only available for admin APIs.
                                            "profile": {
                                                "id": "str",  # The
                                                  service principal profile ID. Required.
                                                "displayName": "str"
                                                  # Optional. The service principal profile name.
                                            },
                                            "userType": "str"  #
                                              Optional. Type of the user.
                                        }
                                    ]
                                }
                            ],
                            "users": [
                                {
                                    "dashboardUserAccessRight": "str",  # The
                                      access right that the user has for the dashboard (permission
                                      level). Required. Known values are: "None", "Read", "ReadWrite",
                                      "ReadReshare", "ReadCopy", and "Owner".
                                    "identifier": "str",  # Identifier of the
                                      principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "displayName": "str",  # Optional. Display
                                      name of the principal.
                                    "emailAddress": "str",  # Optional. Email
                                      address of the user.
                                    "graphId": "str",  # Optional. Identifier of
                                      the principal in Microsoft Graph. Only available for admin APIs.
                                    "profile": {
                                        "id": "str",  # The service principal
                                          profile ID. Required.
                                        "displayName": "str"  # Optional. The
                                          service principal profile name.
                                    },
                                    "userType": "str"  # Optional. Type of the
                                      user.
                                }
                            ],
                            "webUrl": "str"  # Optional. The web URL of the dashboard.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_dashboards_get_dashboards_in_group_request(
            group_id=group_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def add_dashboard_in_group(
        self, group_id: str, request_parameters: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Creates a new empty dashboard in the specified workspace.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Content.Create
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param request_parameters: Add dashboard parameters. Required.
        :type request_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                request_parameters = {
                    "name": "str"  # The name of the new dashboard. Required.
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # The dashboard ID. Required.
                    "appId": "str",  # Optional. The app ID, returned only if the dashboard
                      belongs to an app.
                    "displayName": "str",  # Optional. The display name of the dashboard.
                    "embedUrl": "str",  # Optional. The embed URL of the dashboard.
                    "isReadOnly": bool,  # Optional. Whether the dashboard is read-only.
                    "subscriptions": [
                        {
                            "id": "str",  # The subscription ID. Required.
                            "artifactDisplayName": "str",  # Optional. The name of the
                              subscribed Power BI item (such as a report or a dashboard).
                            "artifactId": "str",  # Optional. The ID of the subscribed
                              Power BI item (such as a report or a dashboard).
                            "artifactType": "str",  # Optional. The type of Power BI item
                              (for example a ``Report``"" , ``Dashboard``"" , or ``Dataset``"" ).
                            "attachmentFormat": "str",  # Optional. Format of the report
                              attached in the email subscription.
                            "endDate": "2020-02-20 00:00:00",  # Optional. The end date
                              and time of the email subscription.
                            "frequency": "str",  # Optional. The frequency of the email
                              subscription.
                            "isEnabled": bool,  # Optional. Whether the email
                              subscription is enabled.
                            "linkToContent": bool,  # Optional. Whether a subscription
                              link exists in the email subscription.
                            "previewImage": bool,  # Optional. Whether a screenshot of
                              the report exists in the email subscription.
                            "startDate": "2020-02-20 00:00:00",  # Optional. The start
                              date and time of the email subscription.
                            "subArtifactDisplayName": "str",  # Optional. The page name
                              of the subscribed Power BI item, if it's a report.
                            "title": "str",  # Optional. The app name.
                            "users": [
                                {
                                    "identifier": "str",  # Identifier of the
                                      principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "displayName": "str",  # Optional. Display
                                      name of the principal.
                                    "emailAddress": "str",  # Optional. Email
                                      address of the user.
                                    "graphId": "str",  # Optional. Identifier of
                                      the principal in Microsoft Graph. Only available for admin APIs.
                                    "profile": {
                                        "id": "str",  # The service principal
                                          profile ID. Required.
                                        "displayName": "str"  # Optional. The
                                          service principal profile name.
                                    },
                                    "userType": "str"  # Optional. Type of the
                                      user.
                                }
                            ]
                        }
                    ],
                    "users": [
                        {
                            "dashboardUserAccessRight": "str",  # The access right that
                              the user has for the dashboard (permission level). Required. Known values
                              are: "None", "Read", "ReadWrite", "ReadReshare", "ReadCopy", and "Owner".
                            "identifier": "str",  # Identifier of the principal.
                              Required.
                            "principalType": "str",  # The principal type. Required.
                              Known values are: "None", "User", "Group", and "App".
                            "displayName": "str",  # Optional. Display name of the
                              principal.
                            "emailAddress": "str",  # Optional. Email address of the
                              user.
                            "graphId": "str",  # Optional. Identifier of the principal in
                              Microsoft Graph. Only available for admin APIs.
                            "profile": {
                                "id": "str",  # The service principal profile ID.
                                  Required.
                                "displayName": "str"  # Optional. The service
                                  principal profile name.
                            },
                            "userType": "str"  # Optional. Type of the user.
                        }
                    ],
                    "webUrl": "str"  # Optional. The web URL of the dashboard.
                }
        """

    @overload
    async def add_dashboard_in_group(
        self, group_id: str, request_parameters: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Creates a new empty dashboard in the specified workspace.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Content.Create
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param request_parameters: Add dashboard parameters. Required.
        :type request_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # The dashboard ID. Required.
                    "appId": "str",  # Optional. The app ID, returned only if the dashboard
                      belongs to an app.
                    "displayName": "str",  # Optional. The display name of the dashboard.
                    "embedUrl": "str",  # Optional. The embed URL of the dashboard.
                    "isReadOnly": bool,  # Optional. Whether the dashboard is read-only.
                    "subscriptions": [
                        {
                            "id": "str",  # The subscription ID. Required.
                            "artifactDisplayName": "str",  # Optional. The name of the
                              subscribed Power BI item (such as a report or a dashboard).
                            "artifactId": "str",  # Optional. The ID of the subscribed
                              Power BI item (such as a report or a dashboard).
                            "artifactType": "str",  # Optional. The type of Power BI item
                              (for example a ``Report``"" , ``Dashboard``"" , or ``Dataset``"" ).
                            "attachmentFormat": "str",  # Optional. Format of the report
                              attached in the email subscription.
                            "endDate": "2020-02-20 00:00:00",  # Optional. The end date
                              and time of the email subscription.
                            "frequency": "str",  # Optional. The frequency of the email
                              subscription.
                            "isEnabled": bool,  # Optional. Whether the email
                              subscription is enabled.
                            "linkToContent": bool,  # Optional. Whether a subscription
                              link exists in the email subscription.
                            "previewImage": bool,  # Optional. Whether a screenshot of
                              the report exists in the email subscription.
                            "startDate": "2020-02-20 00:00:00",  # Optional. The start
                              date and time of the email subscription.
                            "subArtifactDisplayName": "str",  # Optional. The page name
                              of the subscribed Power BI item, if it's a report.
                            "title": "str",  # Optional. The app name.
                            "users": [
                                {
                                    "identifier": "str",  # Identifier of the
                                      principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "displayName": "str",  # Optional. Display
                                      name of the principal.
                                    "emailAddress": "str",  # Optional. Email
                                      address of the user.
                                    "graphId": "str",  # Optional. Identifier of
                                      the principal in Microsoft Graph. Only available for admin APIs.
                                    "profile": {
                                        "id": "str",  # The service principal
                                          profile ID. Required.
                                        "displayName": "str"  # Optional. The
                                          service principal profile name.
                                    },
                                    "userType": "str"  # Optional. Type of the
                                      user.
                                }
                            ]
                        }
                    ],
                    "users": [
                        {
                            "dashboardUserAccessRight": "str",  # The access right that
                              the user has for the dashboard (permission level). Required. Known values
                              are: "None", "Read", "ReadWrite", "ReadReshare", "ReadCopy", and "Owner".
                            "identifier": "str",  # Identifier of the principal.
                              Required.
                            "principalType": "str",  # The principal type. Required.
                              Known values are: "None", "User", "Group", and "App".
                            "displayName": "str",  # Optional. Display name of the
                              principal.
                            "emailAddress": "str",  # Optional. Email address of the
                              user.
                            "graphId": "str",  # Optional. Identifier of the principal in
                              Microsoft Graph. Only available for admin APIs.
                            "profile": {
                                "id": "str",  # The service principal profile ID.
                                  Required.
                                "displayName": "str"  # Optional. The service
                                  principal profile name.
                            },
                            "userType": "str"  # Optional. Type of the user.
                        }
                    ],
                    "webUrl": "str"  # Optional. The web URL of the dashboard.
                }
        """

    @distributed_trace_async
    async def add_dashboard_in_group(self, group_id: str, request_parameters: Union[JSON, IO], **kwargs: Any) -> JSON:
        """Creates a new empty dashboard in the specified workspace.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Content.Create
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param request_parameters: Add dashboard parameters. Is either a JSON type or a IO type.
         Required.
        :type request_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                request_parameters = {
                    "name": "str"  # The name of the new dashboard. Required.
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # The dashboard ID. Required.
                    "appId": "str",  # Optional. The app ID, returned only if the dashboard
                      belongs to an app.
                    "displayName": "str",  # Optional. The display name of the dashboard.
                    "embedUrl": "str",  # Optional. The embed URL of the dashboard.
                    "isReadOnly": bool,  # Optional. Whether the dashboard is read-only.
                    "subscriptions": [
                        {
                            "id": "str",  # The subscription ID. Required.
                            "artifactDisplayName": "str",  # Optional. The name of the
                              subscribed Power BI item (such as a report or a dashboard).
                            "artifactId": "str",  # Optional. The ID of the subscribed
                              Power BI item (such as a report or a dashboard).
                            "artifactType": "str",  # Optional. The type of Power BI item
                              (for example a ``Report``"" , ``Dashboard``"" , or ``Dataset``"" ).
                            "attachmentFormat": "str",  # Optional. Format of the report
                              attached in the email subscription.
                            "endDate": "2020-02-20 00:00:00",  # Optional. The end date
                              and time of the email subscription.
                            "frequency": "str",  # Optional. The frequency of the email
                              subscription.
                            "isEnabled": bool,  # Optional. Whether the email
                              subscription is enabled.
                            "linkToContent": bool,  # Optional. Whether a subscription
                              link exists in the email subscription.
                            "previewImage": bool,  # Optional. Whether a screenshot of
                              the report exists in the email subscription.
                            "startDate": "2020-02-20 00:00:00",  # Optional. The start
                              date and time of the email subscription.
                            "subArtifactDisplayName": "str",  # Optional. The page name
                              of the subscribed Power BI item, if it's a report.
                            "title": "str",  # Optional. The app name.
                            "users": [
                                {
                                    "identifier": "str",  # Identifier of the
                                      principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "displayName": "str",  # Optional. Display
                                      name of the principal.
                                    "emailAddress": "str",  # Optional. Email
                                      address of the user.
                                    "graphId": "str",  # Optional. Identifier of
                                      the principal in Microsoft Graph. Only available for admin APIs.
                                    "profile": {
                                        "id": "str",  # The service principal
                                          profile ID. Required.
                                        "displayName": "str"  # Optional. The
                                          service principal profile name.
                                    },
                                    "userType": "str"  # Optional. Type of the
                                      user.
                                }
                            ]
                        }
                    ],
                    "users": [
                        {
                            "dashboardUserAccessRight": "str",  # The access right that
                              the user has for the dashboard (permission level). Required. Known values
                              are: "None", "Read", "ReadWrite", "ReadReshare", "ReadCopy", and "Owner".
                            "identifier": "str",  # Identifier of the principal.
                              Required.
                            "principalType": "str",  # The principal type. Required.
                              Known values are: "None", "User", "Group", and "App".
                            "displayName": "str",  # Optional. Display name of the
                              principal.
                            "emailAddress": "str",  # Optional. Email address of the
                              user.
                            "graphId": "str",  # Optional. Identifier of the principal in
                              Microsoft Graph. Only available for admin APIs.
                            "profile": {
                                "id": "str",  # The service principal profile ID.
                                  Required.
                                "displayName": "str"  # Optional. The service
                                  principal profile name.
                            },
                            "userType": "str"  # Optional. Type of the user.
                        }
                    ],
                    "webUrl": "str"  # Optional. The web URL of the dashboard.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(request_parameters, (IOBase, bytes)):
            _content = request_parameters
        else:
            _json = request_parameters

        _request = build_dashboards_add_dashboard_in_group_request(
            group_id=group_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_dashboard_in_group(self, group_id: str, dashboard_id: str, **kwargs: Any) -> JSON:
        """Returns the specified dashboard from the specified workspace.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Dashboard.ReadWrite.All or Dashboard.Read.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dashboard_id: The dashboard ID. Required.
        :type dashboard_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # The dashboard ID. Required.
                    "appId": "str",  # Optional. The app ID, returned only if the dashboard
                      belongs to an app.
                    "displayName": "str",  # Optional. The display name of the dashboard.
                    "embedUrl": "str",  # Optional. The embed URL of the dashboard.
                    "isReadOnly": bool,  # Optional. Whether the dashboard is read-only.
                    "subscriptions": [
                        {
                            "id": "str",  # The subscription ID. Required.
                            "artifactDisplayName": "str",  # Optional. The name of the
                              subscribed Power BI item (such as a report or a dashboard).
                            "artifactId": "str",  # Optional. The ID of the subscribed
                              Power BI item (such as a report or a dashboard).
                            "artifactType": "str",  # Optional. The type of Power BI item
                              (for example a ``Report``"" , ``Dashboard``"" , or ``Dataset``"" ).
                            "attachmentFormat": "str",  # Optional. Format of the report
                              attached in the email subscription.
                            "endDate": "2020-02-20 00:00:00",  # Optional. The end date
                              and time of the email subscription.
                            "frequency": "str",  # Optional. The frequency of the email
                              subscription.
                            "isEnabled": bool,  # Optional. Whether the email
                              subscription is enabled.
                            "linkToContent": bool,  # Optional. Whether a subscription
                              link exists in the email subscription.
                            "previewImage": bool,  # Optional. Whether a screenshot of
                              the report exists in the email subscription.
                            "startDate": "2020-02-20 00:00:00",  # Optional. The start
                              date and time of the email subscription.
                            "subArtifactDisplayName": "str",  # Optional. The page name
                              of the subscribed Power BI item, if it's a report.
                            "title": "str",  # Optional. The app name.
                            "users": [
                                {
                                    "identifier": "str",  # Identifier of the
                                      principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "displayName": "str",  # Optional. Display
                                      name of the principal.
                                    "emailAddress": "str",  # Optional. Email
                                      address of the user.
                                    "graphId": "str",  # Optional. Identifier of
                                      the principal in Microsoft Graph. Only available for admin APIs.
                                    "profile": {
                                        "id": "str",  # The service principal
                                          profile ID. Required.
                                        "displayName": "str"  # Optional. The
                                          service principal profile name.
                                    },
                                    "userType": "str"  # Optional. Type of the
                                      user.
                                }
                            ]
                        }
                    ],
                    "users": [
                        {
                            "dashboardUserAccessRight": "str",  # The access right that
                              the user has for the dashboard (permission level). Required. Known values
                              are: "None", "Read", "ReadWrite", "ReadReshare", "ReadCopy", and "Owner".
                            "identifier": "str",  # Identifier of the principal.
                              Required.
                            "principalType": "str",  # The principal type. Required.
                              Known values are: "None", "User", "Group", and "App".
                            "displayName": "str",  # Optional. Display name of the
                              principal.
                            "emailAddress": "str",  # Optional. Email address of the
                              user.
                            "graphId": "str",  # Optional. Identifier of the principal in
                              Microsoft Graph. Only available for admin APIs.
                            "profile": {
                                "id": "str",  # The service principal profile ID.
                                  Required.
                                "displayName": "str"  # Optional. The service
                                  principal profile name.
                            },
                            "userType": "str"  # Optional. Type of the user.
                        }
                    ],
                    "webUrl": "str"  # Optional. The web URL of the dashboard.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_dashboards_get_dashboard_in_group_request(
            group_id=group_id,
            dashboard_id=dashboard_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def delete_dashboard_in_group(  # pylint: disable=inconsistent-return-statements
        self, group_id: str, dashboard_id: str, **kwargs: Any
    ) -> None:
        """Deletes the specified dashboard from the specified workspace.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Dashboard.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dashboard_id: The dashboard ID. Required.
        :type dashboard_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_dashboards_delete_dashboard_in_group_request(
            group_id=group_id,
            dashboard_id=dashboard_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get_tiles_in_group(self, group_id: str, dashboard_id: str, **kwargs: Any) -> JSON:
        """Returns a list of tiles within the specified dashboard from the specified workspace.

        Supported tiles include datasets and live tiles that contain an entire report page.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Dashboard.ReadWrite.All or Dashboard.Read.All

        Limitations
        -----------

        Titles that are edited in the report before the visual is added to the dashboard, are not
        returned. To return these titles, edit them in the dashboard.
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dashboard_id: The dashboard ID. Required.
        :type dashboard_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional. OData context.
                    "value": [
                        {
                            "id": "str",  # The tile ID. Required.
                            "colSpan": 0,  # Optional. The number of tile span columns.
                            "datasetId": "str",  # Optional. The dataset ID. Available
                              only for tiles created from a report or by using a dataset, such as Q&A
                              tiles.
                            "embedData": "str",  # Optional. The embed data for the tile.
                            "embedUrl": "str",  # Optional. The embed URL of the tile.
                            "reportId": "str",  # Optional. The report ID. Available only
                              for tiles created from a report.
                            "rowSpan": 0,  # Optional. The number of tile span rows.
                            "title": "str"  # Optional. The display name of the tile.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_dashboards_get_tiles_in_group_request(
            group_id=group_id,
            dashboard_id=dashboard_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_tile_in_group(self, group_id: str, dashboard_id: str, tile_id: str, **kwargs: Any) -> JSON:
        """Returns the specified tile within the specified dashboard from the specified workspace.

        Supported tiles include datasets and live tiles that contain an entire report page.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Dashboard.ReadWrite.All or Dashboard.Read.All

        Limitations
        -----------

        Titles that are edited in the report before the visual is added to the dashboard, are not
        returned. To return these titles, edit them in the dashboard.
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dashboard_id: The dashboard ID. Required.
        :type dashboard_id: str
        :param tile_id: The tile ID. Required.
        :type tile_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # The tile ID. Required.
                    "colSpan": 0,  # Optional. The number of tile span columns.
                    "datasetId": "str",  # Optional. The dataset ID. Available only for tiles
                      created from a report or by using a dataset, such as Q&A tiles.
                    "embedData": "str",  # Optional. The embed data for the tile.
                    "embedUrl": "str",  # Optional. The embed URL of the tile.
                    "reportId": "str",  # Optional. The report ID. Available only for tiles
                      created from a report.
                    "rowSpan": 0,  # Optional. The number of tile span rows.
                    "title": "str"  # Optional. The display name of the tile.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_dashboards_get_tile_in_group_request(
            group_id=group_id,
            dashboard_id=dashboard_id,
            tile_id=tile_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def clone_tile_in_group(
        self,
        group_id: str,
        dashboard_id: str,
        tile_id: str,
        request_parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Clones the specified tile from the specified workspace.

        When a tile is cloned to another workspace and bound to another report and dataset, it's cloned
        as is with its underlying query containing the original report filters.

        If the target report ID and target dataset are missing, the following can occur:


        * If you're cloning a tile within the same workspace, the report and dataset links will be
        cloned from the source tile.
        * If you're cloning a tile within a different workspace, report and dataset links will be
        removed, and the tile will be broken.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Dashboard.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dashboard_id: The dashboard ID. Required.
        :type dashboard_id: str
        :param tile_id: The tile ID. Required.
        :type tile_id: str
        :param request_parameters: Clone tile parameters. Required.
        :type request_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                request_parameters = {
                    "targetDashboardId": "str",  # The target dashboard ID. Required.
                    "positionConflictAction": "str",  # Optional. Optional. A parameter for
                      specifying an action in case of a position conflict. If there's a conflict and
                      this parameter isn't provided, then the default value ``Tail`` will be applied.
                      If there's no conflict, then the cloned tile will have the same position as in
                      the source. Known values are: "Tail" and "Abort".
                    "targetModelId": "str",  # Optional. Optional. A parameter for specifying a
                      target model ID. When cloning a tile linked to a dataset, pass the target model
                      ID to rebind the new tile to a different dataset.
                    "targetReportId": "str",  # Optional. Optional. A parameter for specifying a
                      target report ID. When cloning a tile linked to a report, pass the target report
                      ID to rebind the new tile to a different report.
                    "targetWorkspaceId": "str"  # Optional. Optional. A parameter for specifying
                      a target workspace ID. An empty GUID (""
                      ``00000000-0000-0000-0000-000000000000``"" ) indicates **My workspace**. If this
                      parameter isn't provided, the tile will be cloned within the same workspace as
                      the source tile.
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # The tile ID. Required.
                    "colSpan": 0,  # Optional. The number of tile span columns.
                    "datasetId": "str",  # Optional. The dataset ID. Available only for tiles
                      created from a report or by using a dataset, such as Q&A tiles.
                    "embedData": "str",  # Optional. The embed data for the tile.
                    "embedUrl": "str",  # Optional. The embed URL of the tile.
                    "reportId": "str",  # Optional. The report ID. Available only for tiles
                      created from a report.
                    "rowSpan": 0,  # Optional. The number of tile span rows.
                    "title": "str"  # Optional. The display name of the tile.
                }
        """

    @overload
    async def clone_tile_in_group(
        self,
        group_id: str,
        dashboard_id: str,
        tile_id: str,
        request_parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Clones the specified tile from the specified workspace.

        When a tile is cloned to another workspace and bound to another report and dataset, it's cloned
        as is with its underlying query containing the original report filters.

        If the target report ID and target dataset are missing, the following can occur:


        * If you're cloning a tile within the same workspace, the report and dataset links will be
        cloned from the source tile.
        * If you're cloning a tile within a different workspace, report and dataset links will be
        removed, and the tile will be broken.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Dashboard.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dashboard_id: The dashboard ID. Required.
        :type dashboard_id: str
        :param tile_id: The tile ID. Required.
        :type tile_id: str
        :param request_parameters: Clone tile parameters. Required.
        :type request_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # The tile ID. Required.
                    "colSpan": 0,  # Optional. The number of tile span columns.
                    "datasetId": "str",  # Optional. The dataset ID. Available only for tiles
                      created from a report or by using a dataset, such as Q&A tiles.
                    "embedData": "str",  # Optional. The embed data for the tile.
                    "embedUrl": "str",  # Optional. The embed URL of the tile.
                    "reportId": "str",  # Optional. The report ID. Available only for tiles
                      created from a report.
                    "rowSpan": 0,  # Optional. The number of tile span rows.
                    "title": "str"  # Optional. The display name of the tile.
                }
        """

    @distributed_trace_async
    async def clone_tile_in_group(
        self, group_id: str, dashboard_id: str, tile_id: str, request_parameters: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Clones the specified tile from the specified workspace.

        When a tile is cloned to another workspace and bound to another report and dataset, it's cloned
        as is with its underlying query containing the original report filters.

        If the target report ID and target dataset are missing, the following can occur:


        * If you're cloning a tile within the same workspace, the report and dataset links will be
        cloned from the source tile.
        * If you're cloning a tile within a different workspace, report and dataset links will be
        removed, and the tile will be broken.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Dashboard.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dashboard_id: The dashboard ID. Required.
        :type dashboard_id: str
        :param tile_id: The tile ID. Required.
        :type tile_id: str
        :param request_parameters: Clone tile parameters. Is either a JSON type or a IO type. Required.
        :type request_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                request_parameters = {
                    "targetDashboardId": "str",  # The target dashboard ID. Required.
                    "positionConflictAction": "str",  # Optional. Optional. A parameter for
                      specifying an action in case of a position conflict. If there's a conflict and
                      this parameter isn't provided, then the default value ``Tail`` will be applied.
                      If there's no conflict, then the cloned tile will have the same position as in
                      the source. Known values are: "Tail" and "Abort".
                    "targetModelId": "str",  # Optional. Optional. A parameter for specifying a
                      target model ID. When cloning a tile linked to a dataset, pass the target model
                      ID to rebind the new tile to a different dataset.
                    "targetReportId": "str",  # Optional. Optional. A parameter for specifying a
                      target report ID. When cloning a tile linked to a report, pass the target report
                      ID to rebind the new tile to a different report.
                    "targetWorkspaceId": "str"  # Optional. Optional. A parameter for specifying
                      a target workspace ID. An empty GUID (""
                      ``00000000-0000-0000-0000-000000000000``"" ) indicates **My workspace**. If this
                      parameter isn't provided, the tile will be cloned within the same workspace as
                      the source tile.
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # The tile ID. Required.
                    "colSpan": 0,  # Optional. The number of tile span columns.
                    "datasetId": "str",  # Optional. The dataset ID. Available only for tiles
                      created from a report or by using a dataset, such as Q&A tiles.
                    "embedData": "str",  # Optional. The embed data for the tile.
                    "embedUrl": "str",  # Optional. The embed URL of the tile.
                    "reportId": "str",  # Optional. The report ID. Available only for tiles
                      created from a report.
                    "rowSpan": 0,  # Optional. The number of tile span rows.
                    "title": "str"  # Optional. The display name of the tile.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(request_parameters, (IOBase, bytes)):
            _content = request_parameters
        else:
            _json = request_parameters

        _request = build_dashboards_clone_tile_in_group_request(
            group_id=group_id,
            dashboard_id=dashboard_id,
            tile_id=tile_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def generate_token_in_group(
        self,
        group_id: str,
        dashboard_id: str,
        request_parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Generates an embed token to view the specified dashboard from the specified workspace.

        ..

           [!IMPORTANT]
           This API call is only relevant to the `embed for your customers
        </power-bi/developer/embed-sample-for-customers>`_ scenario. To learn more about using this
        API, see `Considerations when generating an embed token
        </power-bi/developer/embedded/generate-embed-token>`_.


        Permissions
        -----------


        * When using a service principal for authentication, refer to `Embed Power BI content with
        service principal </power-bi/developer/embed-service-principal>`_ and `Considerations and
        limitations
        </power-bi/developer/embedded/embed-service-principal#considerations-and-limitations>`_.
        * This API call can be called by a service principal profile. For more information see:
        `Service principal profiles in Power BI Embedded
        </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        All of the following:


        * Dashboard.ReadWrite.All or Dashboard.Read.All
        * Report.ReadWrite.All or Report.Read.All
        * Dataset.ReadWrite.All or Dataset.Read.All
          :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dashboard_id: The dashboard ID. Required.
        :type dashboard_id: str
        :param request_parameters: Generate token parameters. Required.
        :type request_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                request_parameters = {
                    "accessLevel": "str",  # Optional. The required access level for embed token
                      generation. Known values are: "View", "Edit", and "Create".
                    "allowSaveAs": bool,  # Optional. Whether an embedded report can be saved as
                      a new report. The default value is ``false``. Only applies when you generate an
                      embed token for report embedding.
                    "datasetId": "str",  # Optional. The dataset ID used for report creation.
                      Only applies when you generate an embed token for report creation.
                    "identities": [
                        {
                            "username": "str",  # The effective username within a token
                              that applies row-level security rules. For an on-premises model, the
                              username can contain alphanumeric or any of the following characters '.',
                              '-', '_', '!', '#', '^', '~', '""', '@'. For cloud models, the username
                              can contain any ASCII character. For either model, the username length
                              must not exceed 256 characters, and the username shouldn't contain
                              spaces. Required.
                            "customData": "str",  # Optional. `Custom data
                              </power-bi/developer/embedded/embedded-row-level-security#using-the-customdata-feature>`_
                              that's used to apply row-level security rules. Supported for live
                              connection to Azure Analysis Services models and cloud models only.
                            "datasets": [
                                "str"  # Optional. An array of datasets for which
                                  this identity applies.
                            ],
                            "identityBlob": {
                                "value": "str"  # An OAuth 2.0 access token for Azure
                                  SQL. Required.
                            },
                            "reports": [
                                "str"  # Optional. An array of reports for which this
                                  identity applies. Only supported for paginated reports.
                            ],
                            "roles": [
                                "str"  # Optional. An array of row-level security
                                  (RLS) roles within a token that applies RLS rules. An identity can
                                  contain up to 50 roles. A role can contain any character except
                                  ``,``"" , and its length must not exceed 50 characters.
                            ]
                        }
                    ],
                    "lifetimeInMinutes": 0  # Optional. The maximum lifetime of the token in
                      minutes, starting from the time it was generated. Can be used to shorten the
                      expiration time of a token, but not to extend it. The value must be a positive
                      integer. Zero (0) is equivalent to null and will be ignored, resulting in the
                      default expiration time.
                }

                # response body for status code(s): 200
                response == {
                    "expiration": "2020-02-20 00:00:00",  # The date and time (UTC) of token
                      expiration. Required.
                    "token": "str",  # The embed token. Required.
                    "tokenId": "str"  # The unique token ID. Through audit logs, the token ID can
                      be used to correlate operations that use the token with the generate operation.
                      Required.
                }
        """

    @overload
    async def generate_token_in_group(
        self,
        group_id: str,
        dashboard_id: str,
        request_parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Generates an embed token to view the specified dashboard from the specified workspace.

        ..

           [!IMPORTANT]
           This API call is only relevant to the `embed for your customers
        </power-bi/developer/embed-sample-for-customers>`_ scenario. To learn more about using this
        API, see `Considerations when generating an embed token
        </power-bi/developer/embedded/generate-embed-token>`_.


        Permissions
        -----------


        * When using a service principal for authentication, refer to `Embed Power BI content with
        service principal </power-bi/developer/embed-service-principal>`_ and `Considerations and
        limitations
        </power-bi/developer/embedded/embed-service-principal#considerations-and-limitations>`_.
        * This API call can be called by a service principal profile. For more information see:
        `Service principal profiles in Power BI Embedded
        </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        All of the following:


        * Dashboard.ReadWrite.All or Dashboard.Read.All
        * Report.ReadWrite.All or Report.Read.All
        * Dataset.ReadWrite.All or Dataset.Read.All
          :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dashboard_id: The dashboard ID. Required.
        :type dashboard_id: str
        :param request_parameters: Generate token parameters. Required.
        :type request_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "expiration": "2020-02-20 00:00:00",  # The date and time (UTC) of token
                      expiration. Required.
                    "token": "str",  # The embed token. Required.
                    "tokenId": "str"  # The unique token ID. Through audit logs, the token ID can
                      be used to correlate operations that use the token with the generate operation.
                      Required.
                }
        """

    @distributed_trace_async
    async def generate_token_in_group(
        self, group_id: str, dashboard_id: str, request_parameters: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Generates an embed token to view the specified dashboard from the specified workspace.

        ..

           [!IMPORTANT]
           This API call is only relevant to the `embed for your customers
        </power-bi/developer/embed-sample-for-customers>`_ scenario. To learn more about using this
        API, see `Considerations when generating an embed token
        </power-bi/developer/embedded/generate-embed-token>`_.


        Permissions
        -----------


        * When using a service principal for authentication, refer to `Embed Power BI content with
        service principal </power-bi/developer/embed-service-principal>`_ and `Considerations and
        limitations
        </power-bi/developer/embedded/embed-service-principal#considerations-and-limitations>`_.
        * This API call can be called by a service principal profile. For more information see:
        `Service principal profiles in Power BI Embedded
        </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        All of the following:


        * Dashboard.ReadWrite.All or Dashboard.Read.All
        * Report.ReadWrite.All or Report.Read.All
        * Dataset.ReadWrite.All or Dataset.Read.All
          :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dashboard_id: The dashboard ID. Required.
        :type dashboard_id: str
        :param request_parameters: Generate token parameters. Is either a JSON type or a IO type.
         Required.
        :type request_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                request_parameters = {
                    "accessLevel": "str",  # Optional. The required access level for embed token
                      generation. Known values are: "View", "Edit", and "Create".
                    "allowSaveAs": bool,  # Optional. Whether an embedded report can be saved as
                      a new report. The default value is ``false``. Only applies when you generate an
                      embed token for report embedding.
                    "datasetId": "str",  # Optional. The dataset ID used for report creation.
                      Only applies when you generate an embed token for report creation.
                    "identities": [
                        {
                            "username": "str",  # The effective username within a token
                              that applies row-level security rules. For an on-premises model, the
                              username can contain alphanumeric or any of the following characters '.',
                              '-', '_', '!', '#', '^', '~', '""', '@'. For cloud models, the username
                              can contain any ASCII character. For either model, the username length
                              must not exceed 256 characters, and the username shouldn't contain
                              spaces. Required.
                            "customData": "str",  # Optional. `Custom data
                              </power-bi/developer/embedded/embedded-row-level-security#using-the-customdata-feature>`_
                              that's used to apply row-level security rules. Supported for live
                              connection to Azure Analysis Services models and cloud models only.
                            "datasets": [
                                "str"  # Optional. An array of datasets for which
                                  this identity applies.
                            ],
                            "identityBlob": {
                                "value": "str"  # An OAuth 2.0 access token for Azure
                                  SQL. Required.
                            },
                            "reports": [
                                "str"  # Optional. An array of reports for which this
                                  identity applies. Only supported for paginated reports.
                            ],
                            "roles": [
                                "str"  # Optional. An array of row-level security
                                  (RLS) roles within a token that applies RLS rules. An identity can
                                  contain up to 50 roles. A role can contain any character except
                                  ``,``"" , and its length must not exceed 50 characters.
                            ]
                        }
                    ],
                    "lifetimeInMinutes": 0  # Optional. The maximum lifetime of the token in
                      minutes, starting from the time it was generated. Can be used to shorten the
                      expiration time of a token, but not to extend it. The value must be a positive
                      integer. Zero (0) is equivalent to null and will be ignored, resulting in the
                      default expiration time.
                }

                # response body for status code(s): 200
                response == {
                    "expiration": "2020-02-20 00:00:00",  # The date and time (UTC) of token
                      expiration. Required.
                    "token": "str",  # The embed token. Required.
                    "tokenId": "str"  # The unique token ID. Through audit logs, the token ID can
                      be used to correlate operations that use the token with the generate operation.
                      Required.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(request_parameters, (IOBase, bytes)):
            _content = request_parameters
        else:
            _json = request_parameters

        _request = build_dashboards_generate_token_in_group_request(
            group_id=group_id,
            dashboard_id=dashboard_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_dashboards_in_group_as_admin(
        self,
        group_id: str,
        *,
        filter: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        **kwargs: Any
    ) -> JSON:
        """Returns a list of dashboards from the specified workspace.

        Permissions
        -----------


        * The user must have administrator rights (such as Office 365 Global Administrator or Power BI
        Service Administrator) or authenticate using a service principal.
        * Delegated permissions are supported.

        When running under service prinicipal authentication, an app **must not** have any
        admin-consent required premissions for Power BI set on it in the Azure portal.

        Required Scope
        --------------

        Tenant.Read.All or Tenant.ReadWrite.All

        Relevant only when authenticating via a standard delegated admin access token. Must not be
        present when authentication via a service principal is used.

        Limitations
        -----------

        Maximum 200 requests per hour.
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :keyword filter: Filters the results, based on a boolean condition. Default value is None.
        :paramtype filter: str
        :keyword top: Returns only the first n results. Default value is None.
        :paramtype top: int
        :keyword skip: Skips the first n results. Default value is None.
        :paramtype skip: int
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional. OData context.
                    "value": [
                        {
                            "id": "str",  # The dashboard ID. Required.
                            "appId": "str",  # Optional. The app ID, returned only if the
                              dashboard belongs to an app.
                            "displayName": "str",  # Optional. The display name of the
                              dashboard.
                            "embedUrl": "str",  # Optional. The embed URL of the
                              dashboard.
                            "isReadOnly": bool,  # Optional. Whether the dashboard is
                              read-only.
                            "subscriptions": [
                                {
                                    "id": "str",  # The subscription ID.
                                      Required.
                                    "artifactDisplayName": "str",  # Optional.
                                      The name of the subscribed Power BI item (such as a report or a
                                      dashboard).
                                    "artifactId": "str",  # Optional. The ID of
                                      the subscribed Power BI item (such as a report or a dashboard).
                                    "artifactType": "str",  # Optional. The type
                                      of Power BI item (for example a ``Report``"" , ``Dashboard``"" ,
                                      or ``Dataset``"" ).
                                    "attachmentFormat": "str",  # Optional.
                                      Format of the report attached in the email subscription.
                                    "endDate": "2020-02-20 00:00:00",  #
                                      Optional. The end date and time of the email subscription.
                                    "frequency": "str",  # Optional. The
                                      frequency of the email subscription.
                                    "isEnabled": bool,  # Optional. Whether the
                                      email subscription is enabled.
                                    "linkToContent": bool,  # Optional. Whether a
                                      subscription link exists in the email subscription.
                                    "previewImage": bool,  # Optional. Whether a
                                      screenshot of the report exists in the email subscription.
                                    "startDate": "2020-02-20 00:00:00",  #
                                      Optional. The start date and time of the email subscription.
                                    "subArtifactDisplayName": "str",  # Optional.
                                      The page name of the subscribed Power BI item, if it's a report.
                                    "title": "str",  # Optional. The app name.
                                    "users": [
                                        {
                                            "identifier": "str",  #
                                              Identifier of the principal. Required.
                                            "principalType": "str",  #
                                              The principal type. Required. Known values are: "None",
                                              "User", "Group", and "App".
                                            "displayName": "str",  #
                                              Optional. Display name of the principal.
                                            "emailAddress": "str",  #
                                              Optional. Email address of the user.
                                            "graphId": "str",  #
                                              Optional. Identifier of the principal in Microsoft Graph.
                                              Only available for admin APIs.
                                            "profile": {
                                                "id": "str",  # The
                                                  service principal profile ID. Required.
                                                "displayName": "str"
                                                  # Optional. The service principal profile name.
                                            },
                                            "userType": "str"  #
                                              Optional. Type of the user.
                                        }
                                    ]
                                }
                            ],
                            "tiles": [
                                {
                                    "id": "str",  # The tile ID. Required.
                                    "colSpan": 0,  # Optional. The number of tile
                                      span columns.
                                    "datasetId": "str",  # Optional. The dataset
                                      ID. Available only for tiles created from a report or by using a
                                      dataset, such as Q&A tiles.
                                    "embedData": "str",  # Optional. The embed
                                      data for the tile.
                                    "embedUrl": "str",  # Optional. The embed URL
                                      of the tile.
                                    "reportId": "str",  # Optional. The report
                                      ID. Available only for tiles created from a report.
                                    "rowSpan": 0,  # Optional. The number of tile
                                      span rows.
                                    "title": "str"  # Optional. The display name
                                      of the tile.
                                }
                            ],
                            "users": [
                                {
                                    "dashboardUserAccessRight": "str",  # The
                                      access right that the user has for the dashboard (permission
                                      level). Required. Known values are: "None", "Read", "ReadWrite",
                                      "ReadReshare", "ReadCopy", and "Owner".
                                    "identifier": "str",  # Identifier of the
                                      principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "displayName": "str",  # Optional. Display
                                      name of the principal.
                                    "emailAddress": "str",  # Optional. Email
                                      address of the user.
                                    "graphId": "str",  # Optional. Identifier of
                                      the principal in Microsoft Graph. Only available for admin APIs.
                                    "profile": {
                                        "id": "str",  # The service principal
                                          profile ID. Required.
                                        "displayName": "str"  # Optional. The
                                          service principal profile name.
                                    },
                                    "userType": "str"  # Optional. Type of the
                                      user.
                                }
                            ],
                            "webUrl": "str",  # Optional. The web URL of the dashboard.
                            "workspaceId": "str"  # Optional. The workspace ID (GUID) of
                              the dashboard. This property will be returned only in
                              GetDashboardsAsAdmin.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_dashboards_get_dashboards_in_group_as_admin_request(
            group_id=group_id,
            filter=filter,
            top=top,
            skip=skip,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_dashboards_as_admin(
        self,
        *,
        expand: Optional[str] = None,
        filter: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        **kwargs: Any
    ) -> JSON:
        """Returns a list of dashboards for the organization.

        Permissions
        -----------


        * The user must have administrator rights (such as Office 365 Global Administrator or Power BI
        Service Administrator) or authenticate using a service principal.
        * Delegated permissions are supported.

        When running under service prinicipal authentication, an app **must not** have any
        admin-consent required premissions for Power BI set on it in the Azure portal.

        Required Scope
        --------------

        Tenant.Read.All or Tenant.ReadWrite.All

        Relevant only when authenticating via a standard delegated admin access token. Must not be
        present when authentication via a service principal is used.

        Limitations
        -----------

        Maximum 200 requests per hour.
        :code:`<br>`:code:`<br>`.

        :keyword expand: Accepts a comma-separated list of data types, which will be expanded inline in
         the response. Supports ``tiles``. Default value is None.
        :paramtype expand: str
        :keyword filter: Filters the results, based on a boolean condition. Default value is None.
        :paramtype filter: str
        :keyword top: Returns only the first n results. Default value is None.
        :paramtype top: int
        :keyword skip: Skips the first n results. Default value is None.
        :paramtype skip: int
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional. OData context.
                    "value": [
                        {
                            "id": "str",  # The dashboard ID. Required.
                            "appId": "str",  # Optional. The app ID, returned only if the
                              dashboard belongs to an app.
                            "displayName": "str",  # Optional. The display name of the
                              dashboard.
                            "embedUrl": "str",  # Optional. The embed URL of the
                              dashboard.
                            "isReadOnly": bool,  # Optional. Whether the dashboard is
                              read-only.
                            "subscriptions": [
                                {
                                    "id": "str",  # The subscription ID.
                                      Required.
                                    "artifactDisplayName": "str",  # Optional.
                                      The name of the subscribed Power BI item (such as a report or a
                                      dashboard).
                                    "artifactId": "str",  # Optional. The ID of
                                      the subscribed Power BI item (such as a report or a dashboard).
                                    "artifactType": "str",  # Optional. The type
                                      of Power BI item (for example a ``Report``"" , ``Dashboard``"" ,
                                      or ``Dataset``"" ).
                                    "attachmentFormat": "str",  # Optional.
                                      Format of the report attached in the email subscription.
                                    "endDate": "2020-02-20 00:00:00",  #
                                      Optional. The end date and time of the email subscription.
                                    "frequency": "str",  # Optional. The
                                      frequency of the email subscription.
                                    "isEnabled": bool,  # Optional. Whether the
                                      email subscription is enabled.
                                    "linkToContent": bool,  # Optional. Whether a
                                      subscription link exists in the email subscription.
                                    "previewImage": bool,  # Optional. Whether a
                                      screenshot of the report exists in the email subscription.
                                    "startDate": "2020-02-20 00:00:00",  #
                                      Optional. The start date and time of the email subscription.
                                    "subArtifactDisplayName": "str",  # Optional.
                                      The page name of the subscribed Power BI item, if it's a report.
                                    "title": "str",  # Optional. The app name.
                                    "users": [
                                        {
                                            "identifier": "str",  #
                                              Identifier of the principal. Required.
                                            "principalType": "str",  #
                                              The principal type. Required. Known values are: "None",
                                              "User", "Group", and "App".
                                            "displayName": "str",  #
                                              Optional. Display name of the principal.
                                            "emailAddress": "str",  #
                                              Optional. Email address of the user.
                                            "graphId": "str",  #
                                              Optional. Identifier of the principal in Microsoft Graph.
                                              Only available for admin APIs.
                                            "profile": {
                                                "id": "str",  # The
                                                  service principal profile ID. Required.
                                                "displayName": "str"
                                                  # Optional. The service principal profile name.
                                            },
                                            "userType": "str"  #
                                              Optional. Type of the user.
                                        }
                                    ]
                                }
                            ],
                            "tiles": [
                                {
                                    "id": "str",  # The tile ID. Required.
                                    "colSpan": 0,  # Optional. The number of tile
                                      span columns.
                                    "datasetId": "str",  # Optional. The dataset
                                      ID. Available only for tiles created from a report or by using a
                                      dataset, such as Q&A tiles.
                                    "embedData": "str",  # Optional. The embed
                                      data for the tile.
                                    "embedUrl": "str",  # Optional. The embed URL
                                      of the tile.
                                    "reportId": "str",  # Optional. The report
                                      ID. Available only for tiles created from a report.
                                    "rowSpan": 0,  # Optional. The number of tile
                                      span rows.
                                    "title": "str"  # Optional. The display name
                                      of the tile.
                                }
                            ],
                            "users": [
                                {
                                    "dashboardUserAccessRight": "str",  # The
                                      access right that the user has for the dashboard (permission
                                      level). Required. Known values are: "None", "Read", "ReadWrite",
                                      "ReadReshare", "ReadCopy", and "Owner".
                                    "identifier": "str",  # Identifier of the
                                      principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "displayName": "str",  # Optional. Display
                                      name of the principal.
                                    "emailAddress": "str",  # Optional. Email
                                      address of the user.
                                    "graphId": "str",  # Optional. Identifier of
                                      the principal in Microsoft Graph. Only available for admin APIs.
                                    "profile": {
                                        "id": "str",  # The service principal
                                          profile ID. Required.
                                        "displayName": "str"  # Optional. The
                                          service principal profile name.
                                    },
                                    "userType": "str"  # Optional. Type of the
                                      user.
                                }
                            ],
                            "webUrl": "str",  # Optional. The web URL of the dashboard.
                            "workspaceId": "str"  # Optional. The workspace ID (GUID) of
                              the dashboard. This property will be returned only in
                              GetDashboardsAsAdmin.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_dashboards_get_dashboards_as_admin_request(
            expand=expand,
            filter=filter,
            top=top,
            skip=skip,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_tiles_as_admin(self, dashboard_id: str, **kwargs: Any) -> JSON:
        """Returns a list of tiles within the specified dashboard.

        Permissions
        -----------


        * The user must have administrator rights (such as Office 365 Global Administrator or Power BI
        Service Administrator) or authenticate using a service principal.
        * Delegated permissions are supported.

        When running under service prinicipal authentication, an app **must not** have any
        admin-consent required premissions for Power BI set on it in the Azure portal.

        Required Scope
        --------------

        Tenant.Read.All or Tenant.ReadWrite.All

        Relevant only when authenticating via a standard delegated admin access token. Must not be
        present when authentication via a service principal is used.

        Limitations
        -----------

        Maximum 200 requests per hour.
        :code:`<br>`:code:`<br>`.

        :param dashboard_id: The dashboard ID. Required.
        :type dashboard_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional. OData context.
                    "value": [
                        {
                            "id": "str",  # The tile ID. Required.
                            "colSpan": 0,  # Optional. The number of tile span columns.
                            "datasetId": "str",  # Optional. The dataset ID. Available
                              only for tiles created from a report or by using a dataset, such as Q&A
                              tiles.
                            "embedData": "str",  # Optional. The embed data for the tile.
                            "embedUrl": "str",  # Optional. The embed URL of the tile.
                            "reportId": "str",  # Optional. The report ID. Available only
                              for tiles created from a report.
                            "rowSpan": 0,  # Optional. The number of tile span rows.
                            "title": "str"  # Optional. The display name of the tile.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_dashboards_get_tiles_as_admin_request(
            dashboard_id=dashboard_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_dashboard_users_as_admin(self, dashboard_id: str, **kwargs: Any) -> JSON:
        """Returns a list of users that have access to the specified dashboard.

        Permissions
        -----------


        * The user must have administrator rights (such as Office 365 Global Administrator or Power BI
        Service Administrator) or authenticate using a service principal.
        * Delegated permissions are supported.

        When running under service prinicipal authentication, an app **must not** have any
        admin-consent required premissions for Power BI set on it in the Azure portal.

        Required Scope
        --------------

        Tenant.Read.All or Tenant.ReadWrite.All

        Relevant only when authenticating via a standard delegated admin access token. Must not be
        present when authentication via a service principal is used.

        Limitations
        -----------

        Maximum 200 requests per hour.
        :code:`<br>`:code:`<br>`.

        :param dashboard_id: The dashboard ID. Required.
        :type dashboard_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional.
                    "value": [
                        {
                            "dashboardUserAccessRight": "str",  # The access right that
                              the user has for the dashboard (permission level). Required. Known values
                              are: "None", "Read", "ReadWrite", "ReadReshare", "ReadCopy", and "Owner".
                            "identifier": "str",  # Identifier of the principal.
                              Required.
                            "principalType": "str",  # The principal type. Required.
                              Known values are: "None", "User", "Group", and "App".
                            "displayName": "str",  # Optional. Display name of the
                              principal.
                            "emailAddress": "str",  # Optional. Email address of the
                              user.
                            "graphId": "str",  # Optional. Identifier of the principal in
                              Microsoft Graph. Only available for admin APIs.
                            "profile": {
                                "id": "str",  # The service principal profile ID.
                                  Required.
                                "displayName": "str"  # Optional. The service
                                  principal profile name.
                            },
                            "userType": "str"  # Optional. Type of the user.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_dashboards_get_dashboard_users_as_admin_request(
            dashboard_id=dashboard_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_dashboard_subscriptions_as_admin(self, dashboard_id: str, **kwargs: Any) -> JSON:
        """Returns a list of dashboard subscriptions along with subscriber details. This is a preview API
        call.

        Permissions
        -----------


        * The user must have administrator rights (such as Office 365 Global Administrator or Power BI
        Service Administrator) or authenticate using a service principal.
        * Delegated permissions are supported.

        Required Scope
        --------------

        Tenant.Read.All or Tenant.ReadWrite.All

        Limitations
        -----------

        Maximum 200 requests per hour.
        :code:`<br>`:code:`<br>`.

        :param dashboard_id: The dashboard ID. Required.
        :type dashboard_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional.
                    "value": [
                        {
                            "id": "str",  # The subscription ID. Required.
                            "artifactDisplayName": "str",  # Optional. The name of the
                              subscribed Power BI item (such as a report or a dashboard).
                            "artifactId": "str",  # Optional. The ID of the subscribed
                              Power BI item (such as a report or a dashboard).
                            "artifactType": "str",  # Optional. The type of Power BI item
                              (for example a ``Report``"" , ``Dashboard``"" , or ``Dataset``"" ).
                            "attachmentFormat": "str",  # Optional. Format of the report
                              attached in the email subscription.
                            "endDate": "2020-02-20 00:00:00",  # Optional. The end date
                              and time of the email subscription.
                            "frequency": "str",  # Optional. The frequency of the email
                              subscription.
                            "isEnabled": bool,  # Optional. Whether the email
                              subscription is enabled.
                            "linkToContent": bool,  # Optional. Whether a subscription
                              link exists in the email subscription.
                            "previewImage": bool,  # Optional. Whether a screenshot of
                              the report exists in the email subscription.
                            "startDate": "2020-02-20 00:00:00",  # Optional. The start
                              date and time of the email subscription.
                            "subArtifactDisplayName": "str",  # Optional. The page name
                              of the subscribed Power BI item, if it's a report.
                            "title": "str",  # Optional. The app name.
                            "users": [
                                {
                                    "identifier": "str",  # Identifier of the
                                      principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "displayName": "str",  # Optional. Display
                                      name of the principal.
                                    "emailAddress": "str",  # Optional. Email
                                      address of the user.
                                    "graphId": "str",  # Optional. Identifier of
                                      the principal in Microsoft Graph. Only available for admin APIs.
                                    "profile": {
                                        "id": "str",  # The service principal
                                          profile ID. Required.
                                        "displayName": "str"  # Optional. The
                                          service principal profile name.
                                    },
                                    "userType": "str"  # Optional. Type of the
                                      user.
                                }
                            ]
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_dashboards_get_dashboard_subscriptions_as_admin_request(
            dashboard_id=dashboard_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore


class TilesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~power_bi_client.aio.PowerBIClient`'s
        :attr:`tiles` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    async def generate_token_in_group(
        self,
        group_id: str,
        dashboard_id: str,
        tile_id: str,
        request_parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Generates an embed token to view the specified tile from the specified workspace.

        ..

           [!IMPORTANT]
           This API call is only relevant to the `embed for your customers
        </power-bi/developer/embed-sample-for-customers>`_ scenario. To learn more about using this
        API, see `Considerations when generating an embed token
        </power-bi/developer/embedded/generate-embed-token>`_.


        Permissions
        -----------


        * When using a service principal for authentication, refer to `Embed Power BI content with
        service principal </power-bi/developer/embed-service-principal>`_ and `Considerations and
        limitations
        </power-bi/developer/embedded/embed-service-principal#considerations-and-limitations>`_.
        * This API call can be called by a service principal profile. For more information see:
        `Service principal profiles in Power BI Embedded
        </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        All of the following:


        * Dashboard.ReadWrite.All or Dashboard.Read.All
        * Report.ReadWrite.All or Report.Read.All
        * Dataset.ReadWrite.All or Dataset.Read.All
          :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dashboard_id: The dashboard ID. Required.
        :type dashboard_id: str
        :param tile_id: The tile ID. Required.
        :type tile_id: str
        :param request_parameters: Generate token parameters. Required.
        :type request_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                request_parameters = {
                    "accessLevel": "str",  # Optional. The required access level for embed token
                      generation. Known values are: "View", "Edit", and "Create".
                    "allowSaveAs": bool,  # Optional. Whether an embedded report can be saved as
                      a new report. The default value is ``false``. Only applies when you generate an
                      embed token for report embedding.
                    "datasetId": "str",  # Optional. The dataset ID used for report creation.
                      Only applies when you generate an embed token for report creation.
                    "identities": [
                        {
                            "username": "str",  # The effective username within a token
                              that applies row-level security rules. For an on-premises model, the
                              username can contain alphanumeric or any of the following characters '.',
                              '-', '_', '!', '#', '^', '~', '""', '@'. For cloud models, the username
                              can contain any ASCII character. For either model, the username length
                              must not exceed 256 characters, and the username shouldn't contain
                              spaces. Required.
                            "customData": "str",  # Optional. `Custom data
                              </power-bi/developer/embedded/embedded-row-level-security#using-the-customdata-feature>`_
                              that's used to apply row-level security rules. Supported for live
                              connection to Azure Analysis Services models and cloud models only.
                            "datasets": [
                                "str"  # Optional. An array of datasets for which
                                  this identity applies.
                            ],
                            "identityBlob": {
                                "value": "str"  # An OAuth 2.0 access token for Azure
                                  SQL. Required.
                            },
                            "reports": [
                                "str"  # Optional. An array of reports for which this
                                  identity applies. Only supported for paginated reports.
                            ],
                            "roles": [
                                "str"  # Optional. An array of row-level security
                                  (RLS) roles within a token that applies RLS rules. An identity can
                                  contain up to 50 roles. A role can contain any character except
                                  ``,``"" , and its length must not exceed 50 characters.
                            ]
                        }
                    ],
                    "lifetimeInMinutes": 0  # Optional. The maximum lifetime of the token in
                      minutes, starting from the time it was generated. Can be used to shorten the
                      expiration time of a token, but not to extend it. The value must be a positive
                      integer. Zero (0) is equivalent to null and will be ignored, resulting in the
                      default expiration time.
                }

                # response body for status code(s): 200
                response == {
                    "expiration": "2020-02-20 00:00:00",  # The date and time (UTC) of token
                      expiration. Required.
                    "token": "str",  # The embed token. Required.
                    "tokenId": "str"  # The unique token ID. Through audit logs, the token ID can
                      be used to correlate operations that use the token with the generate operation.
                      Required.
                }
        """

    @overload
    async def generate_token_in_group(
        self,
        group_id: str,
        dashboard_id: str,
        tile_id: str,
        request_parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Generates an embed token to view the specified tile from the specified workspace.

        ..

           [!IMPORTANT]
           This API call is only relevant to the `embed for your customers
        </power-bi/developer/embed-sample-for-customers>`_ scenario. To learn more about using this
        API, see `Considerations when generating an embed token
        </power-bi/developer/embedded/generate-embed-token>`_.


        Permissions
        -----------


        * When using a service principal for authentication, refer to `Embed Power BI content with
        service principal </power-bi/developer/embed-service-principal>`_ and `Considerations and
        limitations
        </power-bi/developer/embedded/embed-service-principal#considerations-and-limitations>`_.
        * This API call can be called by a service principal profile. For more information see:
        `Service principal profiles in Power BI Embedded
        </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        All of the following:


        * Dashboard.ReadWrite.All or Dashboard.Read.All
        * Report.ReadWrite.All or Report.Read.All
        * Dataset.ReadWrite.All or Dataset.Read.All
          :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dashboard_id: The dashboard ID. Required.
        :type dashboard_id: str
        :param tile_id: The tile ID. Required.
        :type tile_id: str
        :param request_parameters: Generate token parameters. Required.
        :type request_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "expiration": "2020-02-20 00:00:00",  # The date and time (UTC) of token
                      expiration. Required.
                    "token": "str",  # The embed token. Required.
                    "tokenId": "str"  # The unique token ID. Through audit logs, the token ID can
                      be used to correlate operations that use the token with the generate operation.
                      Required.
                }
        """

    @distributed_trace_async
    async def generate_token_in_group(
        self, group_id: str, dashboard_id: str, tile_id: str, request_parameters: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Generates an embed token to view the specified tile from the specified workspace.

        ..

           [!IMPORTANT]
           This API call is only relevant to the `embed for your customers
        </power-bi/developer/embed-sample-for-customers>`_ scenario. To learn more about using this
        API, see `Considerations when generating an embed token
        </power-bi/developer/embedded/generate-embed-token>`_.


        Permissions
        -----------


        * When using a service principal for authentication, refer to `Embed Power BI content with
        service principal </power-bi/developer/embed-service-principal>`_ and `Considerations and
        limitations
        </power-bi/developer/embedded/embed-service-principal#considerations-and-limitations>`_.
        * This API call can be called by a service principal profile. For more information see:
        `Service principal profiles in Power BI Embedded
        </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        All of the following:


        * Dashboard.ReadWrite.All or Dashboard.Read.All
        * Report.ReadWrite.All or Report.Read.All
        * Dataset.ReadWrite.All or Dataset.Read.All
          :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dashboard_id: The dashboard ID. Required.
        :type dashboard_id: str
        :param tile_id: The tile ID. Required.
        :type tile_id: str
        :param request_parameters: Generate token parameters. Is either a JSON type or a IO type.
         Required.
        :type request_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                request_parameters = {
                    "accessLevel": "str",  # Optional. The required access level for embed token
                      generation. Known values are: "View", "Edit", and "Create".
                    "allowSaveAs": bool,  # Optional. Whether an embedded report can be saved as
                      a new report. The default value is ``false``. Only applies when you generate an
                      embed token for report embedding.
                    "datasetId": "str",  # Optional. The dataset ID used for report creation.
                      Only applies when you generate an embed token for report creation.
                    "identities": [
                        {
                            "username": "str",  # The effective username within a token
                              that applies row-level security rules. For an on-premises model, the
                              username can contain alphanumeric or any of the following characters '.',
                              '-', '_', '!', '#', '^', '~', '""', '@'. For cloud models, the username
                              can contain any ASCII character. For either model, the username length
                              must not exceed 256 characters, and the username shouldn't contain
                              spaces. Required.
                            "customData": "str",  # Optional. `Custom data
                              </power-bi/developer/embedded/embedded-row-level-security#using-the-customdata-feature>`_
                              that's used to apply row-level security rules. Supported for live
                              connection to Azure Analysis Services models and cloud models only.
                            "datasets": [
                                "str"  # Optional. An array of datasets for which
                                  this identity applies.
                            ],
                            "identityBlob": {
                                "value": "str"  # An OAuth 2.0 access token for Azure
                                  SQL. Required.
                            },
                            "reports": [
                                "str"  # Optional. An array of reports for which this
                                  identity applies. Only supported for paginated reports.
                            ],
                            "roles": [
                                "str"  # Optional. An array of row-level security
                                  (RLS) roles within a token that applies RLS rules. An identity can
                                  contain up to 50 roles. A role can contain any character except
                                  ``,``"" , and its length must not exceed 50 characters.
                            ]
                        }
                    ],
                    "lifetimeInMinutes": 0  # Optional. The maximum lifetime of the token in
                      minutes, starting from the time it was generated. Can be used to shorten the
                      expiration time of a token, but not to extend it. The value must be a positive
                      integer. Zero (0) is equivalent to null and will be ignored, resulting in the
                      default expiration time.
                }

                # response body for status code(s): 200
                response == {
                    "expiration": "2020-02-20 00:00:00",  # The date and time (UTC) of token
                      expiration. Required.
                    "token": "str",  # The embed token. Required.
                    "tokenId": "str"  # The unique token ID. Through audit logs, the token ID can
                      be used to correlate operations that use the token with the generate operation.
                      Required.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(request_parameters, (IOBase, bytes)):
            _content = request_parameters
        else:
            _json = request_parameters

        _request = build_tiles_generate_token_in_group_request(
            group_id=group_id,
            dashboard_id=dashboard_id,
            tile_id=tile_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore


class AppsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~power_bi_client.aio.PowerBIClient`'s
        :attr:`apps` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get_apps(self, **kwargs: Any) -> JSON:
        """Returns a list of installed apps.

        Required Scope
        --------------

        App.Read.All

        Limitations
        -----------

        Service principal authentication isn't supported.
        :code:`<br>`:code:`<br>`.

        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional. OData context.
                    "value": [
                        {
                            "id": "str",  # The app ID. Required.
                            "description": "str",  # Optional. The app description.
                            "lastUpdate": "2020-02-20 00:00:00",  # Optional. The date
                              and time the app was last updated.
                            "name": "str",  # Optional. The app name.
                            "publishedBy": "str"  # Optional. The app publisher.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_apps_get_apps_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_app(self, app_id: str, **kwargs: Any) -> JSON:
        """Returns the specified installed app.

        Required Scope
        --------------

        App.Read.All

        Limitations
        -----------

        Service principal authentication isn't supported.
        :code:`<br>`:code:`<br>`.

        :param app_id: The app ID. Required.
        :type app_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # The app ID. Required.
                    "description": "str",  # Optional. The app description.
                    "lastUpdate": "2020-02-20 00:00:00",  # Optional. The date and time the app
                      was last updated.
                    "name": "str",  # Optional. The app name.
                    "publishedBy": "str"  # Optional. The app publisher.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_apps_get_app_request(
            app_id=app_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_reports(self, app_id: str, **kwargs: Any) -> JSON:
        """Returns a list of reports from the specified app.

        Required Scope
        --------------

        Report.ReadWrite.All or Report.Read.All

        Limitations
        -----------

        Service principal authentication isn't supported.
        :code:`<br>`:code:`<br>`.

        :param app_id: The app ID. Required.
        :type app_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional. OData context.
                    "value": [
                        {
                            "id": "str",  # The report ID. Required.
                            "appId": "str",  # Optional. The app ID, returned only if the
                              report belongs to an app.
                            "datasetId": "str",  # Optional. The dataset ID of the
                              report.
                            "description": "str",  # Optional. The report description.
                            "embedUrl": "str",  # Optional. The embed URL of the report.
                            "name": "str",  # Optional. The name of the report.
                            "reportType": "str",  # Optional. The report type.
                              "PaginatedReport"
                            "subscriptions": [
                                {
                                    "id": "str",  # The subscription ID.
                                      Required.
                                    "artifactDisplayName": "str",  # Optional.
                                      The name of the subscribed Power BI item (such as a report or a
                                      dashboard).
                                    "artifactId": "str",  # Optional. The ID of
                                      the subscribed Power BI item (such as a report or a dashboard).
                                    "artifactType": "str",  # Optional. The type
                                      of Power BI item (for example a ``Report``"" , ``Dashboard``"" ,
                                      or ``Dataset``"" ).
                                    "attachmentFormat": "str",  # Optional.
                                      Format of the report attached in the email subscription.
                                    "endDate": "2020-02-20 00:00:00",  #
                                      Optional. The end date and time of the email subscription.
                                    "frequency": "str",  # Optional. The
                                      frequency of the email subscription.
                                    "isEnabled": bool,  # Optional. Whether the
                                      email subscription is enabled.
                                    "linkToContent": bool,  # Optional. Whether a
                                      subscription link exists in the email subscription.
                                    "previewImage": bool,  # Optional. Whether a
                                      screenshot of the report exists in the email subscription.
                                    "startDate": "2020-02-20 00:00:00",  #
                                      Optional. The start date and time of the email subscription.
                                    "subArtifactDisplayName": "str",  # Optional.
                                      The page name of the subscribed Power BI item, if it's a report.
                                    "title": "str",  # Optional. The app name.
                                    "users": [
                                        {
                                            "identifier": "str",  #
                                              Identifier of the principal. Required.
                                            "principalType": "str",  #
                                              The principal type. Required. Known values are: "None",
                                              "User", "Group", and "App".
                                            "displayName": "str",  #
                                              Optional. Display name of the principal.
                                            "emailAddress": "str",  #
                                              Optional. Email address of the user.
                                            "graphId": "str",  #
                                              Optional. Identifier of the principal in Microsoft Graph.
                                              Only available for admin APIs.
                                            "profile": {
                                                "id": "str",  # The
                                                  service principal profile ID. Required.
                                                "displayName": "str"
                                                  # Optional. The service principal profile name.
                                            },
                                            "userType": "str"  #
                                              Optional. Type of the user.
                                        }
                                    ]
                                }
                            ],
                            "users": [
                                {
                                    "identifier": "str",  # Identifier of the
                                      principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "reportUserAccessRight": "str",  # The access
                                      right that the user has for the report (permission level).
                                      Required. Known values are: "None", "Read", "ReadWrite",
                                      "ReadReshare", "ReadCopy", and "Owner".
                                    "displayName": "str",  # Optional. Display
                                      name of the principal.
                                    "emailAddress": "str",  # Optional. Email
                                      address of the user.
                                    "graphId": "str",  # Optional. Identifier of
                                      the principal in Microsoft Graph. Only available for admin APIs.
                                    "profile": {
                                        "id": "str",  # The service principal
                                          profile ID. Required.
                                        "displayName": "str"  # Optional. The
                                          service principal profile name.
                                    },
                                    "userType": "str"  # Optional. Type of the
                                      user.
                                }
                            ],
                            "webUrl": "str"  # Optional. The web URL of the report.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_apps_get_reports_request(
            app_id=app_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_report(self, app_id: str, report_id: str, **kwargs: Any) -> JSON:
        """Returns the specified report from the specified app.

        Required Scope
        --------------

        Report.ReadWrite.All or Report.Read.All

        Limitations
        -----------

        Service principal authentication isn't supported.
        :code:`<br>`:code:`<br>`.

        :param app_id: The app ID. Required.
        :type app_id: str
        :param report_id: The report ID. Required.
        :type report_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # The report ID. Required.
                    "appId": "str",  # Optional. The app ID, returned only if the report belongs
                      to an app.
                    "datasetId": "str",  # Optional. The dataset ID of the report.
                    "description": "str",  # Optional. The report description.
                    "embedUrl": "str",  # Optional. The embed URL of the report.
                    "name": "str",  # Optional. The name of the report.
                    "reportType": "str",  # Optional. The report type. "PaginatedReport"
                    "subscriptions": [
                        {
                            "id": "str",  # The subscription ID. Required.
                            "artifactDisplayName": "str",  # Optional. The name of the
                              subscribed Power BI item (such as a report or a dashboard).
                            "artifactId": "str",  # Optional. The ID of the subscribed
                              Power BI item (such as a report or a dashboard).
                            "artifactType": "str",  # Optional. The type of Power BI item
                              (for example a ``Report``"" , ``Dashboard``"" , or ``Dataset``"" ).
                            "attachmentFormat": "str",  # Optional. Format of the report
                              attached in the email subscription.
                            "endDate": "2020-02-20 00:00:00",  # Optional. The end date
                              and time of the email subscription.
                            "frequency": "str",  # Optional. The frequency of the email
                              subscription.
                            "isEnabled": bool,  # Optional. Whether the email
                              subscription is enabled.
                            "linkToContent": bool,  # Optional. Whether a subscription
                              link exists in the email subscription.
                            "previewImage": bool,  # Optional. Whether a screenshot of
                              the report exists in the email subscription.
                            "startDate": "2020-02-20 00:00:00",  # Optional. The start
                              date and time of the email subscription.
                            "subArtifactDisplayName": "str",  # Optional. The page name
                              of the subscribed Power BI item, if it's a report.
                            "title": "str",  # Optional. The app name.
                            "users": [
                                {
                                    "identifier": "str",  # Identifier of the
                                      principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "displayName": "str",  # Optional. Display
                                      name of the principal.
                                    "emailAddress": "str",  # Optional. Email
                                      address of the user.
                                    "graphId": "str",  # Optional. Identifier of
                                      the principal in Microsoft Graph. Only available for admin APIs.
                                    "profile": {
                                        "id": "str",  # The service principal
                                          profile ID. Required.
                                        "displayName": "str"  # Optional. The
                                          service principal profile name.
                                    },
                                    "userType": "str"  # Optional. Type of the
                                      user.
                                }
                            ]
                        }
                    ],
                    "users": [
                        {
                            "identifier": "str",  # Identifier of the principal.
                              Required.
                            "principalType": "str",  # The principal type. Required.
                              Known values are: "None", "User", "Group", and "App".
                            "reportUserAccessRight": "str",  # The access right that the
                              user has for the report (permission level). Required. Known values are:
                              "None", "Read", "ReadWrite", "ReadReshare", "ReadCopy", and "Owner".
                            "displayName": "str",  # Optional. Display name of the
                              principal.
                            "emailAddress": "str",  # Optional. Email address of the
                              user.
                            "graphId": "str",  # Optional. Identifier of the principal in
                              Microsoft Graph. Only available for admin APIs.
                            "profile": {
                                "id": "str",  # The service principal profile ID.
                                  Required.
                                "displayName": "str"  # Optional. The service
                                  principal profile name.
                            },
                            "userType": "str"  # Optional. Type of the user.
                        }
                    ],
                    "webUrl": "str"  # Optional. The web URL of the report.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_apps_get_report_request(
            app_id=app_id,
            report_id=report_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_dashboards(self, app_id: str, **kwargs: Any) -> JSON:
        """Returns a list of dashboards from the specified app.

        Required Scope
        --------------

        Dashboard.ReadWrite.All or Dashboard.Read.All

        Limitations
        -----------

        Service principal authentication isn't supported.
        :code:`<br>`:code:`<br>`.

        :param app_id: The app ID. Required.
        :type app_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional. OData context.
                    "value": [
                        {
                            "id": "str",  # The dashboard ID. Required.
                            "appId": "str",  # Optional. The app ID, returned only if the
                              dashboard belongs to an app.
                            "displayName": "str",  # Optional. The display name of the
                              dashboard.
                            "embedUrl": "str",  # Optional. The embed URL of the
                              dashboard.
                            "isReadOnly": bool,  # Optional. Whether the dashboard is
                              read-only.
                            "subscriptions": [
                                {
                                    "id": "str",  # The subscription ID.
                                      Required.
                                    "artifactDisplayName": "str",  # Optional.
                                      The name of the subscribed Power BI item (such as a report or a
                                      dashboard).
                                    "artifactId": "str",  # Optional. The ID of
                                      the subscribed Power BI item (such as a report or a dashboard).
                                    "artifactType": "str",  # Optional. The type
                                      of Power BI item (for example a ``Report``"" , ``Dashboard``"" ,
                                      or ``Dataset``"" ).
                                    "attachmentFormat": "str",  # Optional.
                                      Format of the report attached in the email subscription.
                                    "endDate": "2020-02-20 00:00:00",  #
                                      Optional. The end date and time of the email subscription.
                                    "frequency": "str",  # Optional. The
                                      frequency of the email subscription.
                                    "isEnabled": bool,  # Optional. Whether the
                                      email subscription is enabled.
                                    "linkToContent": bool,  # Optional. Whether a
                                      subscription link exists in the email subscription.
                                    "previewImage": bool,  # Optional. Whether a
                                      screenshot of the report exists in the email subscription.
                                    "startDate": "2020-02-20 00:00:00",  #
                                      Optional. The start date and time of the email subscription.
                                    "subArtifactDisplayName": "str",  # Optional.
                                      The page name of the subscribed Power BI item, if it's a report.
                                    "title": "str",  # Optional. The app name.
                                    "users": [
                                        {
                                            "identifier": "str",  #
                                              Identifier of the principal. Required.
                                            "principalType": "str",  #
                                              The principal type. Required. Known values are: "None",
                                              "User", "Group", and "App".
                                            "displayName": "str",  #
                                              Optional. Display name of the principal.
                                            "emailAddress": "str",  #
                                              Optional. Email address of the user.
                                            "graphId": "str",  #
                                              Optional. Identifier of the principal in Microsoft Graph.
                                              Only available for admin APIs.
                                            "profile": {
                                                "id": "str",  # The
                                                  service principal profile ID. Required.
                                                "displayName": "str"
                                                  # Optional. The service principal profile name.
                                            },
                                            "userType": "str"  #
                                              Optional. Type of the user.
                                        }
                                    ]
                                }
                            ],
                            "users": [
                                {
                                    "dashboardUserAccessRight": "str",  # The
                                      access right that the user has for the dashboard (permission
                                      level). Required. Known values are: "None", "Read", "ReadWrite",
                                      "ReadReshare", "ReadCopy", and "Owner".
                                    "identifier": "str",  # Identifier of the
                                      principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "displayName": "str",  # Optional. Display
                                      name of the principal.
                                    "emailAddress": "str",  # Optional. Email
                                      address of the user.
                                    "graphId": "str",  # Optional. Identifier of
                                      the principal in Microsoft Graph. Only available for admin APIs.
                                    "profile": {
                                        "id": "str",  # The service principal
                                          profile ID. Required.
                                        "displayName": "str"  # Optional. The
                                          service principal profile name.
                                    },
                                    "userType": "str"  # Optional. Type of the
                                      user.
                                }
                            ],
                            "webUrl": "str"  # Optional. The web URL of the dashboard.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_apps_get_dashboards_request(
            app_id=app_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_dashboard(self, app_id: str, dashboard_id: str, **kwargs: Any) -> JSON:
        """Returns the specified dashboard from the specified app.

        Required Scope
        --------------

        Dashboard.ReadWrite.All or Dashboard.Read.All

        Limitations
        -----------

        Service principal authentication isn't supported.
        :code:`<br>`:code:`<br>`.

        :param app_id: The app ID. Required.
        :type app_id: str
        :param dashboard_id: The dashboard ID. Required.
        :type dashboard_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # The dashboard ID. Required.
                    "appId": "str",  # Optional. The app ID, returned only if the dashboard
                      belongs to an app.
                    "displayName": "str",  # Optional. The display name of the dashboard.
                    "embedUrl": "str",  # Optional. The embed URL of the dashboard.
                    "isReadOnly": bool,  # Optional. Whether the dashboard is read-only.
                    "subscriptions": [
                        {
                            "id": "str",  # The subscription ID. Required.
                            "artifactDisplayName": "str",  # Optional. The name of the
                              subscribed Power BI item (such as a report or a dashboard).
                            "artifactId": "str",  # Optional. The ID of the subscribed
                              Power BI item (such as a report or a dashboard).
                            "artifactType": "str",  # Optional. The type of Power BI item
                              (for example a ``Report``"" , ``Dashboard``"" , or ``Dataset``"" ).
                            "attachmentFormat": "str",  # Optional. Format of the report
                              attached in the email subscription.
                            "endDate": "2020-02-20 00:00:00",  # Optional. The end date
                              and time of the email subscription.
                            "frequency": "str",  # Optional. The frequency of the email
                              subscription.
                            "isEnabled": bool,  # Optional. Whether the email
                              subscription is enabled.
                            "linkToContent": bool,  # Optional. Whether a subscription
                              link exists in the email subscription.
                            "previewImage": bool,  # Optional. Whether a screenshot of
                              the report exists in the email subscription.
                            "startDate": "2020-02-20 00:00:00",  # Optional. The start
                              date and time of the email subscription.
                            "subArtifactDisplayName": "str",  # Optional. The page name
                              of the subscribed Power BI item, if it's a report.
                            "title": "str",  # Optional. The app name.
                            "users": [
                                {
                                    "identifier": "str",  # Identifier of the
                                      principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "displayName": "str",  # Optional. Display
                                      name of the principal.
                                    "emailAddress": "str",  # Optional. Email
                                      address of the user.
                                    "graphId": "str",  # Optional. Identifier of
                                      the principal in Microsoft Graph. Only available for admin APIs.
                                    "profile": {
                                        "id": "str",  # The service principal
                                          profile ID. Required.
                                        "displayName": "str"  # Optional. The
                                          service principal profile name.
                                    },
                                    "userType": "str"  # Optional. Type of the
                                      user.
                                }
                            ]
                        }
                    ],
                    "users": [
                        {
                            "dashboardUserAccessRight": "str",  # The access right that
                              the user has for the dashboard (permission level). Required. Known values
                              are: "None", "Read", "ReadWrite", "ReadReshare", "ReadCopy", and "Owner".
                            "identifier": "str",  # Identifier of the principal.
                              Required.
                            "principalType": "str",  # The principal type. Required.
                              Known values are: "None", "User", "Group", and "App".
                            "displayName": "str",  # Optional. Display name of the
                              principal.
                            "emailAddress": "str",  # Optional. Email address of the
                              user.
                            "graphId": "str",  # Optional. Identifier of the principal in
                              Microsoft Graph. Only available for admin APIs.
                            "profile": {
                                "id": "str",  # The service principal profile ID.
                                  Required.
                                "displayName": "str"  # Optional. The service
                                  principal profile name.
                            },
                            "userType": "str"  # Optional. Type of the user.
                        }
                    ],
                    "webUrl": "str"  # Optional. The web URL of the dashboard.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_apps_get_dashboard_request(
            app_id=app_id,
            dashboard_id=dashboard_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_tiles(self, app_id: str, dashboard_id: str, **kwargs: Any) -> JSON:
        """Returns a list of tiles within the specified dashboard from the specified app.

        Required Scope
        --------------

        Dashboard.ReadWrite.All or Dashboard.Read.All

        Limitations
        -----------

        Service principal authentication isn't supported.
        :code:`<br>`:code:`<br>`.

        :param app_id: The app ID. Required.
        :type app_id: str
        :param dashboard_id: The dashboard ID. Required.
        :type dashboard_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional. OData context.
                    "value": [
                        {
                            "id": "str",  # The tile ID. Required.
                            "colSpan": 0,  # Optional. The number of tile span columns.
                            "datasetId": "str",  # Optional. The dataset ID. Available
                              only for tiles created from a report or by using a dataset, such as Q&A
                              tiles.
                            "embedData": "str",  # Optional. The embed data for the tile.
                            "embedUrl": "str",  # Optional. The embed URL of the tile.
                            "reportId": "str",  # Optional. The report ID. Available only
                              for tiles created from a report.
                            "rowSpan": 0,  # Optional. The number of tile span rows.
                            "title": "str"  # Optional. The display name of the tile.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_apps_get_tiles_request(
            app_id=app_id,
            dashboard_id=dashboard_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_tile(self, app_id: str, dashboard_id: str, tile_id: str, **kwargs: Any) -> JSON:
        """Returns the specified tile within the specified dashboard from the specified app.

        Supported tiles include datasets and live tiles that contain an entire report page.

        Required Scope
        --------------

        Dashboard.ReadWrite.All or Dashboard.Read.All

        Limitations
        -----------

        Service principal authentication isn't supported.
        :code:`<br>`:code:`<br>`.

        :param app_id: The app ID. Required.
        :type app_id: str
        :param dashboard_id: The dashboard ID. Required.
        :type dashboard_id: str
        :param tile_id: The tile ID. Required.
        :type tile_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # The tile ID. Required.
                    "colSpan": 0,  # Optional. The number of tile span columns.
                    "datasetId": "str",  # Optional. The dataset ID. Available only for tiles
                      created from a report or by using a dataset, such as Q&A tiles.
                    "embedData": "str",  # Optional. The embed data for the tile.
                    "embedUrl": "str",  # Optional. The embed URL of the tile.
                    "reportId": "str",  # Optional. The report ID. Available only for tiles
                      created from a report.
                    "rowSpan": 0,  # Optional. The number of tile span rows.
                    "title": "str"  # Optional. The display name of the tile.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_apps_get_tile_request(
            app_id=app_id,
            dashboard_id=dashboard_id,
            tile_id=tile_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_apps_as_admin(self, *, top: int, **kwargs: Any) -> JSON:
        """Returns a list of apps in the organization.

        The query parameter $top is required.

        Permissions
        -----------


        * The user must have administrator rights (such as Office 365 Global Administrator or Power BI
        Service Administrator) or authenticate using a service principal.
        * Delegated permissions are supported.

        When running under service prinicipal authentication, an app **must not** have any
        admin-consent required premissions for Power BI set on it in the Azure portal.

        Required Scope
        --------------

        Tenant.Read.All or Tenant.ReadWrite.All

        Relevant only when authenticating via a standard delegated admin access token. Must not be
        present when authentication via a service principal is used.

        Limitations
        -----------

        Maximum 200 requests per hour.
        :code:`<br>`:code:`<br>`.

        :keyword top: The requested number of entries in the refresh history. If not provided, the
         default is all available entries. Required.
        :paramtype top: int
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional. OData context.
                    "value": [
                        {
                            "id": "str",  # The app ID. Required.
                            "description": "str",  # Optional. The app description.
                            "lastUpdate": "2020-02-20 00:00:00",  # Optional. The date
                              and time the app was last updated.
                            "name": "str",  # Optional. The app name.
                            "publishedBy": "str",  # Optional. The app publisher.
                            "workspaceId": "str"  # Optional. Associated workspace for
                              the app.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_apps_get_apps_as_admin_request(
            top=top,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_app_users_as_admin(self, app_id: str, **kwargs: Any) -> JSON:
        """Returns a list of users that have access to the specified app.

        Permissions
        -----------


        * The user must have administrator rights (such as Office 365 Global Administrator or Power BI
        Service Administrator) or authenticate using a service principal.
        * Delegated permissions are supported.

        When running under service prinicipal authentication, an app **must not** have any
        admin-consent required premissions for Power BI set on it in the Azure portal.

        Required Scope
        --------------

        Tenant.Read.All or Tenant.ReadWrite.All

        Relevant only when authenticating via a standard delegated admin access token. Must not be
        present when authentication via a service principal is used.

        Limitations
        -----------

        Maximum 200 requests per hour.
        :code:`<br>`:code:`<br>`.

        :param app_id: The app ID. Required.
        :type app_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional.
                    "value": [
                        {
                            "appUserAccessRight": "str",  # The access right that the
                              user has for the app. Required. Known values are: "None", "Read",
                              "ReadWrite", "ReadReshare", "ReadWriteReshare", "ReadExplore",
                              "ReadCopy", "ReadExploreCopy", "ReadReshareExploreCopy",
                              "ReadReshareExplore", "ReadWriteExplore", "ReadWriteReshareExplore",
                              "ReadWriteExploreCopy", "ReadReshareCopy", and "All".
                            "displayName": "str",  # Optional. Display name of the
                              principal.
                            "emailAddress": "str",  # Optional. Email address of the
                              user.
                            "graphId": "str",  # Optional. Identifier of the principal in
                              Microsoft Graph. Only available for admin APIs.
                            "identifier": "str",  # Optional. Identifier of the
                              principal.
                            "principalType": "str"  # Optional. The principal type. Known
                              values are: "None", "User", "Group", and "App".
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_apps_get_app_users_as_admin_request(
            app_id=app_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore


class DataflowsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~power_bi_client.aio.PowerBIClient`'s
        :attr:`dataflows` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get_dataflow(self, group_id: str, dataflow_id: str, **kwargs: Any) -> AsyncIterator[bytes]:
        """Exports the specified dataflow definition to a JSON file.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Dataflow.ReadWrite.All or Dataflow.Read.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataflow_id: The dataflow ID. Required.
        :type dataflow_id: str
        :return: Async iterator of the response bytes
        :rtype: AsyncIterator[bytes]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        _request = build_dataflows_get_dataflow_request(
            group_id=group_id,
            dataflow_id=dataflow_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, cast(AsyncIterator[bytes], deserialized), {})  # type: ignore

        return cast(AsyncIterator[bytes], deserialized)  # type: ignore

    @distributed_trace_async
    async def delete_dataflow(  # pylint: disable=inconsistent-return-statements
        self, group_id: str, dataflow_id: str, **kwargs: Any
    ) -> None:
        """Deletes a dataflow from Power BI data prep storage, including its definition file and model.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Dataflow.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataflow_id: The dataflow ID. Required.
        :type dataflow_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_dataflows_delete_dataflow_request(
            group_id=group_id,
            dataflow_id=dataflow_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def update_dataflow(  # pylint: disable=inconsistent-return-statements
        self,
        group_id: str,
        dataflow_id: str,
        dataflow_update_request: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Updates dataflow properties, capabilities and settings.

        Required Scope
        --------------

        Dataflow.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataflow_id: The dataflow ID. Required.
        :type dataflow_id: str
        :param dataflow_update_request: Patch dataflow properties, capabilities and settings. Required.
        :type dataflow_update_request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                dataflow_update_request = {
                    "allowNativeQueries": bool,  # Optional. Whether to allow native queries.
                    "computeEngineBehavior": "str",  # Optional. The behavior of the compute
                      engine. Known values are: "computeOptimized", "computeOn", and "computeDisabled".
                    "description": "str",  # Optional. The new description for the dataflow.
                    "name": "str"  # Optional. The new name for the dataflow.
                }
        """

    @overload
    async def update_dataflow(  # pylint: disable=inconsistent-return-statements
        self,
        group_id: str,
        dataflow_id: str,
        dataflow_update_request: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Updates dataflow properties, capabilities and settings.

        Required Scope
        --------------

        Dataflow.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataflow_id: The dataflow ID. Required.
        :type dataflow_id: str
        :param dataflow_update_request: Patch dataflow properties, capabilities and settings. Required.
        :type dataflow_update_request: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_dataflow(  # pylint: disable=inconsistent-return-statements
        self, group_id: str, dataflow_id: str, dataflow_update_request: Union[JSON, IO], **kwargs: Any
    ) -> None:
        """Updates dataflow properties, capabilities and settings.

        Required Scope
        --------------

        Dataflow.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataflow_id: The dataflow ID. Required.
        :type dataflow_id: str
        :param dataflow_update_request: Patch dataflow properties, capabilities and settings. Is either
         a JSON type or a IO type. Required.
        :type dataflow_update_request: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                dataflow_update_request = {
                    "allowNativeQueries": bool,  # Optional. Whether to allow native queries.
                    "computeEngineBehavior": "str",  # Optional. The behavior of the compute
                      engine. Known values are: "computeOptimized", "computeOn", and "computeDisabled".
                    "description": "str",  # Optional. The new description for the dataflow.
                    "name": "str"  # Optional. The new name for the dataflow.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(dataflow_update_request, (IOBase, bytes)):
            _content = dataflow_update_request
        else:
            _json = dataflow_update_request

        _request = build_dataflows_update_dataflow_request(
            group_id=group_id,
            dataflow_id=dataflow_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def refresh_dataflow(  # pylint: disable=inconsistent-return-statements
        self,
        group_id: str,
        dataflow_id: str,
        refresh_request: Optional[JSON] = None,
        *,
        process_type: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Triggers a refresh for the specified dataflow.

        Supported email notification options are **MailOnFailure** and **NoNotification**.
        **MailOnCompletion** isn't supported.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Dataflow.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataflow_id: The dataflow ID. Required.
        :type dataflow_id: str
        :param refresh_request: Default value is None.
        :type refresh_request: JSON
        :keyword process_type: Type of refresh process to use. Known values are: "default" and
         "processFull". Default value is None.
        :paramtype process_type: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                refresh_request = {
                    "notifyOption": "str"  # Mail notification options. Required. Known values
                      are: "NoNotification", "MailOnFailure", and "MailOnCompletion".
                }
        """

    @overload
    async def refresh_dataflow(  # pylint: disable=inconsistent-return-statements
        self,
        group_id: str,
        dataflow_id: str,
        refresh_request: Optional[IO] = None,
        *,
        process_type: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Triggers a refresh for the specified dataflow.

        Supported email notification options are **MailOnFailure** and **NoNotification**.
        **MailOnCompletion** isn't supported.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Dataflow.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataflow_id: The dataflow ID. Required.
        :type dataflow_id: str
        :param refresh_request: Default value is None.
        :type refresh_request: IO
        :keyword process_type: Type of refresh process to use. Known values are: "default" and
         "processFull". Default value is None.
        :paramtype process_type: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def refresh_dataflow(  # pylint: disable=inconsistent-return-statements
        self,
        group_id: str,
        dataflow_id: str,
        refresh_request: Optional[Union[JSON, IO]] = None,
        *,
        process_type: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """Triggers a refresh for the specified dataflow.

        Supported email notification options are **MailOnFailure** and **NoNotification**.
        **MailOnCompletion** isn't supported.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Dataflow.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataflow_id: The dataflow ID. Required.
        :type dataflow_id: str
        :param refresh_request: Is either a JSON type or a IO type. Default value is None.
        :type refresh_request: JSON or IO
        :keyword process_type: Type of refresh process to use. Known values are: "default" and
         "processFull". Default value is None.
        :paramtype process_type: str
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                refresh_request = {
                    "notifyOption": "str"  # Mail notification options. Required. Known values
                      are: "NoNotification", "MailOnFailure", and "MailOnCompletion".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(refresh_request, (IOBase, bytes)):
            _content = refresh_request
        else:
            if refresh_request is not None:
                _json = refresh_request
            else:
                _json = None

        _request = build_dataflows_refresh_dataflow_request(
            group_id=group_id,
            dataflow_id=dataflow_id,
            process_type=process_type,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get_dataflow_data_sources(self, group_id: str, dataflow_id: str, **kwargs: Any) -> JSON:
        """Returns a list of data sources for the specified dataflow.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Dataflow.ReadWrite.All or Dataflow.Read.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataflow_id: The dataflow ID. Required.
        :type dataflow_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional. OData context.
                    "value": [
                        {
                            "connectionDetails": {
                                "account": "str",  # Optional. The connection
                                  account.
                                "classInfo": "str",  # Optional. The connection class
                                  information.
                                "database": "str",  # Optional. The connection
                                  database.
                                "domain": "str",  # Optional. The connection domain.
                                "emailAddress": "str",  # Optional. The connection
                                  email address.
                                "kind": "str",  # Optional. The connection kind.
                                "loginServer": "str",  # Optional. The connection
                                  login server.
                                "path": "str",  # Optional. The connection path.
                                "server": "str",  # Optional. The connection server.
                                "url": "str"  # Optional. The connection URL.
                            },
                            "connectionString": "str",  # Optional. (Deprecated) The data
                              source connection string. Available only for DirectQuery.
                            "datasourceId": "str",  # Optional. The bound data source ID,
                              which is empty when not bound to a gateway.
                            "datasourceType": "str",  # Optional. The data source type.
                            "gatewayId": "str",  # Optional. The bound gateway ID, which
                              is empty when not bound to a gateway. When using a gateway cluster, the
                              gateway ID refers to the primary (first) gateway in the cluster and is
                              similar to the gateway cluster ID.
                            "name": "str"  # Optional. (Deprecated) The data source name.
                              Available only for DirectQuery.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_dataflows_get_dataflow_data_sources_request(
            group_id=group_id,
            dataflow_id=dataflow_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_dataflows(self, group_id: str, **kwargs: Any) -> JSON:
        """Returns a list of all dataflows from the specified workspace.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Dataflow.ReadWrite.All or Dataflow.Read.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional.
                    "value": [
                        {
                            "objectId": "str",  # The dataflow ID. Required.
                            "configuredBy": "str",  # Optional. The dataflow owner.
                            "description": "str",  # Optional. The dataflow description.
                            "modelUrl": "str",  # Optional. A URL to the dataflow
                              definition file (model.json).
                            "modifiedBy": "str",  # Optional. The user that modified the
                              dataflow.
                            "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. The
                              date and time that the dataflow was last modified.
                            "name": "str",  # Optional. The dataflow name.
                            "users": [
                                {
                                    "identifier": "str",  # Identifier of the
                                      principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "DataflowUserAccessRight": "str",  #
                                      Optional. The access right that a user has for the dataflow
                                      (permission level). Known values are: "None", "Read",
                                      "ReadWrite", "ReadReshare", and "Owner".
                                    "displayName": "str",  # Optional. Display
                                      name of the principal.
                                    "emailAddress": "str",  # Optional. Email
                                      address of the user.
                                    "graphId": "str",  # Optional. Identifier of
                                      the principal in Microsoft Graph. Only available for admin APIs.
                                    "profile": {
                                        "id": "str",  # The service principal
                                          profile ID. Required.
                                        "displayName": "str"  # Optional. The
                                          service principal profile name.
                                    },
                                    "userType": "str"  # Optional. Type of the
                                      user.
                                }
                            ]
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_dataflows_get_dataflows_request(
            group_id=group_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_upstream_dataflows_in_group(self, group_id: str, dataflow_id: str, **kwargs: Any) -> JSON:
        """Returns a list of upstream dataflows for the specified dataflow.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Dataflow.ReadWrite.All or Dataflow.Read.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataflow_id: The dataflow ID. Required.
        :type dataflow_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional.
                    "value": [
                        {
                            "groupId": "str",  # Optional. The target group ID.
                            "targetDataflowId": "str"  # Optional. The target dataflow
                              ID.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_dataflows_get_upstream_dataflows_in_group_request(
            group_id=group_id,
            dataflow_id=dataflow_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def update_refresh_schedule(  # pylint: disable=inconsistent-return-statements
        self,
        group_id: str,
        dataflow_id: str,
        refresh_schedule_request: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Creates or updates the refresh schedule for a specified dataflow.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Dataflow.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataflow_id: The dataflow ID. Required.
        :type dataflow_id: str
        :param refresh_schedule_request: The dataflow refresh schedule to create or update. Required.
        :type refresh_schedule_request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                refresh_schedule_request = {
                    "value": {
                        "NotifyOption": "str",  # Optional. The notification option on
                          termination of a scheduled refresh. Service principals only support the
                          ``NoNotification`` value. Known values are: "NoNotification" and
                          "MailOnFailure".
                        "days": [
                            "str"  # Optional. The days on which to execute the refresh.
                        ],
                        "enabled": bool,  # Optional. Whether the refresh is enabled.
                        "localTimeZoneId": "str",  # Optional. The ID of the time zone to
                          use. For more information, see `Time zone info
                          </dotnet/api/system.timezoneinfo.id>`_.
                        "times": [
                            "str"  # Optional. The times of day to execute the refresh.
                        ]
                    }
                }
        """

    @overload
    async def update_refresh_schedule(  # pylint: disable=inconsistent-return-statements
        self,
        group_id: str,
        dataflow_id: str,
        refresh_schedule_request: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Creates or updates the refresh schedule for a specified dataflow.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Dataflow.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataflow_id: The dataflow ID. Required.
        :type dataflow_id: str
        :param refresh_schedule_request: The dataflow refresh schedule to create or update. Required.
        :type refresh_schedule_request: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_refresh_schedule(  # pylint: disable=inconsistent-return-statements
        self, group_id: str, dataflow_id: str, refresh_schedule_request: Union[JSON, IO], **kwargs: Any
    ) -> None:
        """Creates or updates the refresh schedule for a specified dataflow.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Dataflow.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataflow_id: The dataflow ID. Required.
        :type dataflow_id: str
        :param refresh_schedule_request: The dataflow refresh schedule to create or update. Is either a
         JSON type or a IO type. Required.
        :type refresh_schedule_request: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                refresh_schedule_request = {
                    "value": {
                        "NotifyOption": "str",  # Optional. The notification option on
                          termination of a scheduled refresh. Service principals only support the
                          ``NoNotification`` value. Known values are: "NoNotification" and
                          "MailOnFailure".
                        "days": [
                            "str"  # Optional. The days on which to execute the refresh.
                        ],
                        "enabled": bool,  # Optional. Whether the refresh is enabled.
                        "localTimeZoneId": "str",  # Optional. The ID of the time zone to
                          use. For more information, see `Time zone info
                          </dotnet/api/system.timezoneinfo.id>`_.
                        "times": [
                            "str"  # Optional. The times of day to execute the refresh.
                        ]
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(refresh_schedule_request, (IOBase, bytes)):
            _content = refresh_schedule_request
        else:
            _json = refresh_schedule_request

        _request = build_dataflows_update_refresh_schedule_request(
            group_id=group_id,
            dataflow_id=dataflow_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get_dataflow_transactions(self, group_id: str, dataflow_id: str, **kwargs: Any) -> JSON:
        """Returns a list of transactions for the specified dataflow.

        Required Scope
        --------------

        Dataflow.ReadWrite.All or Dataflow.Read.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataflow_id: The dataflow ID. Required.
        :type dataflow_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional. OData context.
                    "value": [
                        {
                            "id": "str",  # The transaction ID. Required.
                            "endTime": "str",  # Optional. The end time of the
                              transaction.
                            "refreshType": "str",  # Optional. The type of refresh
                              transaction.
                            "startTime": "str",  # Optional. The start time of the
                              transaction.
                            "status": "str"  # Optional. The status of the transaction.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_dataflows_get_dataflow_transactions_request(
            group_id=group_id,
            dataflow_id=dataflow_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def cancel_dataflow_transaction(self, group_id: str, transaction_id: str, **kwargs: Any) -> JSON:
        """Attempts to cancel the specified transactions.

        Required Scope
        --------------

        Dataflow.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param transaction_id: The transaction ID. Required.
        :type transaction_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "status": "str",  # Optional. The transaction status. Known values are:
                      "invalid", "successfullyMarked", "alreadyConcluded", and "notFound".
                    "transactionId": "str"  # Optional. The transaction ID.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_dataflows_cancel_dataflow_transaction_request(
            group_id=group_id,
            transaction_id=transaction_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_upstream_dataflows_in_group_as_admin(self, group_id: str, dataflow_id: str, **kwargs: Any) -> JSON:
        """Returns a list of upstream dataflows for the specified dataflow.

        Permissions
        -----------


        * The user must have administrator rights (such as Office 365 Global Administrator or Power BI
        Service Administrator) or authenticate using a service principal.
        * Delegated permissions are supported.

        When running under service prinicipal authentication, an app **must not** have any
        admin-consent required premissions for Power BI set on it in the Azure portal.

        Required Scope
        --------------

        Tenant.Read.All or Tenant.ReadWrite.All

        Relevant only when authenticating via a standard delegated admin access token. Must not be
        present when authentication via a service principal is used.

        Limitations
        -----------

        Maximum 200 requests per hour.
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param dataflow_id: The dataflow ID. Required.
        :type dataflow_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional.
                    "value": [
                        {
                            "groupId": "str",  # Optional. The target group ID.
                            "targetDataflowId": "str"  # Optional. The target dataflow
                              ID.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_dataflows_get_upstream_dataflows_in_group_as_admin_request(
            group_id=group_id,
            dataflow_id=dataflow_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_dataflows_in_group_as_admin(
        self,
        group_id: str,
        *,
        filter: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        **kwargs: Any
    ) -> JSON:
        """Returns a list of dataflows from the specified workspace.

        Permissions
        -----------


        * The user must have administrator rights (such as Office 365 Global Administrator or Power BI
        Service Administrator) or authenticate using a service principal.
        * Delegated permissions are supported.

        When running under service prinicipal authentication, an app **must not** have any
        admin-consent required premissions for Power BI set on it in the Azure portal.

        Required Scope
        --------------

        Tenant.Read.All or Tenant.ReadWrite.All

        Relevant only when authenticating via a standard delegated admin access token. Must not be
        present when authentication via a service principal is used.

        Limitations
        -----------

        Maximum 200 requests per hour.
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :keyword filter: Filters the results, based on a boolean condition. Default value is None.
        :paramtype filter: str
        :keyword top: Returns only the first n results. Default value is None.
        :paramtype top: int
        :keyword skip: Skips the first n results. Default value is None.
        :paramtype skip: int
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional.
                    "value": [
                        {
                            "objectId": "str",  # The dataflow ID. Required.
                            "configuredBy": "str",  # Optional. The dataflow owner.
                            "description": "str",  # Optional. The dataflow description.
                            "modelUrl": "str",  # Optional. A URL to the dataflow
                              definition file (model.json).
                            "modifiedBy": "str",  # Optional. The user that modified the
                              dataflow.
                            "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. The
                              date and time that the dataflow was last modified.
                            "name": "str",  # Optional. The dataflow name.
                            "users": [
                                {
                                    "identifier": "str",  # Identifier of the
                                      principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "DataflowUserAccessRight": "str",  #
                                      Optional. The access right that a user has for the dataflow
                                      (permission level). Known values are: "None", "Read",
                                      "ReadWrite", "ReadReshare", and "Owner".
                                    "displayName": "str",  # Optional. Display
                                      name of the principal.
                                    "emailAddress": "str",  # Optional. Email
                                      address of the user.
                                    "graphId": "str",  # Optional. Identifier of
                                      the principal in Microsoft Graph. Only available for admin APIs.
                                    "profile": {
                                        "id": "str",  # The service principal
                                          profile ID. Required.
                                        "displayName": "str"  # Optional. The
                                          service principal profile name.
                                    },
                                    "userType": "str"  # Optional. Type of the
                                      user.
                                }
                            ]
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_dataflows_get_dataflows_in_group_as_admin_request(
            group_id=group_id,
            filter=filter,
            top=top,
            skip=skip,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_dataflows_as_admin(
        self, *, filter: Optional[str] = None, top: Optional[int] = None, skip: Optional[int] = None, **kwargs: Any
    ) -> JSON:
        """Returns a list of dataflows for the organization.

        Permissions
        -----------


        * The user must have administrator rights (such as Office 365 Global Administrator or Power BI
        Service Administrator) or authenticate using a service principal.
        * Delegated permissions are supported.

        When running under service prinicipal authentication, an app **must not** have any
        admin-consent required premissions for Power BI set on it in the Azure portal.

        Required Scope
        --------------

        Tenant.Read.All or Tenant.ReadWrite.All

        Relevant only when authenticating via a standard delegated admin access token. Must not be
        present when authentication via a service principal is used.
        :code:`<br>`:code:`<br>`.

        :keyword filter: Filters the results, based on a boolean condition. Default value is None.
        :paramtype filter: str
        :keyword top: Returns only the first n results. Default value is None.
        :paramtype top: int
        :keyword skip: Skips the first n results. Default value is None.
        :paramtype skip: int
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional. OData context.
                    "value": [
                        {
                            "objectId": "str",  # The dataflow ID. Required.
                            "configuredBy": "str",  # Optional. The dataflow owner.
                            "description": "str",  # Optional. The dataflow description.
                            "modelUrl": "str",  # Optional. A URL to the dataflow
                              definition file (model.json).
                            "modifiedBy": "str",  # Optional. The user that modified the
                              dataflow.
                            "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. The
                              date and time that the dataflow was last modified.
                            "name": "str",  # Optional. The dataflow name.
                            "users": [
                                {
                                    "identifier": "str",  # Identifier of the
                                      principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "DataflowUserAccessRight": "str",  #
                                      Optional. The access right that a user has for the dataflow
                                      (permission level). Known values are: "None", "Read",
                                      "ReadWrite", "ReadReshare", and "Owner".
                                    "displayName": "str",  # Optional. Display
                                      name of the principal.
                                    "emailAddress": "str",  # Optional. Email
                                      address of the user.
                                    "graphId": "str",  # Optional. Identifier of
                                      the principal in Microsoft Graph. Only available for admin APIs.
                                    "profile": {
                                        "id": "str",  # The service principal
                                          profile ID. Required.
                                        "displayName": "str"  # Optional. The
                                          service principal profile name.
                                    },
                                    "userType": "str"  # Optional. Type of the
                                      user.
                                }
                            ],
                            "workspaceId": "str"  # Optional. The dataflow workspace ID.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_dataflows_get_dataflows_as_admin_request(
            filter=filter,
            top=top,
            skip=skip,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def export_dataflow_as_admin(self, dataflow_id: str, **kwargs: Any) -> AsyncIterator[bytes]:
        """Exports the definition for the specified dataflow to a JSON file.

        Permissions
        -----------


        * The user must have administrator rights (such as Office 365 Global Administrator or Power BI
        Service Administrator) or authenticate using a service principal.
        * Delegated permissions are supported.

        When running under service prinicipal authentication, an app **must not** have any
        admin-consent required premissions for Power BI set on it in the Azure portal.

        Required Scope
        --------------

        Tenant.Read.All or Tenant.ReadWrite.All

        Relevant only when authenticating via a standard delegated admin access token. Must not be
        present when authentication via a service principal is used.
        :code:`<br>`:code:`<br>`.

        :param dataflow_id: The dataflow ID. Required.
        :type dataflow_id: str
        :return: Async iterator of the response bytes
        :rtype: AsyncIterator[bytes]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        _request = build_dataflows_export_dataflow_as_admin_request(
            dataflow_id=dataflow_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, cast(AsyncIterator[bytes], deserialized), {})  # type: ignore

        return cast(AsyncIterator[bytes], deserialized)  # type: ignore

    @distributed_trace_async
    async def get_dataflow_datasources_as_admin(self, dataflow_id: str, **kwargs: Any) -> JSON:
        """Returns a list of data sources for the specified dataflow.

        Deleted data sources will still appear in the response. This may include both cloud and
        on-premise data gateway sources. For more information see `Dataflows considerations and
        limitations </power-bi/transform-model/dataflows/dataflows-features-limitations>`_.

        Permissions
        -----------


        * The user must have administrator rights (such as Office 365 Global Administrator or Power BI
        Service Administrator) or authenticate using a service principal.
        * Delegated permissions are supported.

        When running under service prinicipal authentication, an app **must not** have any
        admin-consent required premissions for Power BI set on it in the Azure portal.

        Required Scope
        --------------

        Tenant.Read.All or Tenant.ReadWrite.All

        Relevant only when authenticating via a standard delegated admin access token. Must not be
        present when authentication via a service principal is used.
        :code:`<br>`:code:`<br>`.

        :param dataflow_id: The dataflow ID. Required.
        :type dataflow_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional. OData context.
                    "value": [
                        {
                            "connectionDetails": {
                                "account": "str",  # Optional. The connection
                                  account.
                                "classInfo": "str",  # Optional. The connection class
                                  information.
                                "database": "str",  # Optional. The connection
                                  database.
                                "domain": "str",  # Optional. The connection domain.
                                "emailAddress": "str",  # Optional. The connection
                                  email address.
                                "kind": "str",  # Optional. The connection kind.
                                "loginServer": "str",  # Optional. The connection
                                  login server.
                                "path": "str",  # Optional. The connection path.
                                "server": "str",  # Optional. The connection server.
                                "url": "str"  # Optional. The connection URL.
                            },
                            "connectionString": "str",  # Optional. (Deprecated) The data
                              source connection string. Available only for DirectQuery.
                            "datasourceId": "str",  # Optional. The bound data source ID,
                              which is empty when not bound to a gateway.
                            "datasourceType": "str",  # Optional. The data source type.
                            "gatewayId": "str",  # Optional. The bound gateway ID, which
                              is empty when not bound to a gateway. When using a gateway cluster, the
                              gateway ID refers to the primary (first) gateway in the cluster and is
                              similar to the gateway cluster ID.
                            "name": "str"  # Optional. (Deprecated) The data source name.
                              Available only for DirectQuery.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_dataflows_get_dataflow_datasources_as_admin_request(
            dataflow_id=dataflow_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_dataflow_users_as_admin(self, dataflow_id: str, **kwargs: Any) -> JSON:
        """Returns a list of users that have access to the specified dataflow.

        Permissions
        -----------


        * The user must have administrator rights (such as Office 365 Global Administrator or Power BI
        Service Administrator) or authenticate using a service principal.
        * Delegated permissions are supported.

        When running under service prinicipal authentication, an app **must not** have any
        admin-consent required premissions for Power BI set on it in the Azure portal.

        Required Scope
        --------------

        Tenant.Read.All or Tenant.ReadWrite.All

        Relevant only when authenticating via a standard delegated admin access token. Must not be
        present when authentication via a service principal is used.

        Limitations
        -----------

        Maximum 200 requests per hour.
        :code:`<br>`:code:`<br>`.

        :param dataflow_id: The dataflow ID. Required.
        :type dataflow_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional.
                    "value": [
                        {
                            "identifier": "str",  # Identifier of the principal.
                              Required.
                            "principalType": "str",  # The principal type. Required.
                              Known values are: "None", "User", "Group", and "App".
                            "DataflowUserAccessRight": "str",  # Optional. The access
                              right that a user has for the dataflow (permission level). Known values
                              are: "None", "Read", "ReadWrite", "ReadReshare", and "Owner".
                            "displayName": "str",  # Optional. Display name of the
                              principal.
                            "emailAddress": "str",  # Optional. Email address of the
                              user.
                            "graphId": "str",  # Optional. Identifier of the principal in
                              Microsoft Graph. Only available for admin APIs.
                            "profile": {
                                "id": "str",  # The service principal profile ID.
                                  Required.
                                "displayName": "str"  # Optional. The service
                                  principal profile name.
                            },
                            "userType": "str"  # Optional. Type of the user.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_dataflows_get_dataflow_users_as_admin_request(
            dataflow_id=dataflow_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore


class GatewaysOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~power_bi_client.aio.PowerBIClient`'s
        :attr:`gateways` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get_gateways(self, **kwargs: Any) -> JSON:
        """Returns a list of gateways for which the user is an admin.

        Permissions
        -----------

        The user must have gateway admin permissions.

        Required Scope
        --------------

        Dataset.ReadWrite.All or Dataset.Read.All

        Limitations
        -----------

        Virtual network (VNet) gateways aren't supported.
        :code:`<br>`:code:`<br>`.

        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional.
                    "value": [
                        {
                            "id": "str",  # The gateway ID. When using a gateway cluster,
                              the gateway ID refers to the primary (first) gateway in the cluster and
                              is similar to the gateway cluster ID. Required.
                            "gatewayAnnotation": "str",  # Optional. Gateway metadata in
                              JSON format.
                            "gatewayStatus": "str",  # Optional. The gateway connectivity
                              status.
                            "name": "str",  # Optional. The gateway name.
                            "publicKey": {
                                "exponent": "str",  # Optional. The public key
                                  exponent.
                                "modulus": "str"  # Optional. The public key modulus.
                            },
                            "type": "str"  # Optional. The gateway type.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_gateways_get_gateways_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_gateway(self, gateway_id: str, **kwargs: Any) -> JSON:
        """Returns the specified gateway.

        Permissions
        -----------

        The user must have gateway admin permissions.

        Required Scope
        --------------

        Dataset.ReadWrite.All or Dataset.Read.All

        Limitations
        -----------

        Virtual network (VNet) gateways aren't supported.
        :code:`<br>`:code:`<br>`.

        :param gateway_id: The gateway ID. When using a gateway cluster, the gateway ID refers to the
         primary (first) gateway in the cluster. In such cases, gateway ID is similar to gateway cluster
         ID. Required.
        :type gateway_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # The gateway ID. When using a gateway cluster, the gateway ID
                      refers to the primary (first) gateway in the cluster and is similar to the
                      gateway cluster ID. Required.
                    "gatewayAnnotation": "str",  # Optional. Gateway metadata in JSON format.
                    "gatewayStatus": "str",  # Optional. The gateway connectivity status.
                    "name": "str",  # Optional. The gateway name.
                    "publicKey": {
                        "exponent": "str",  # Optional. The public key exponent.
                        "modulus": "str"  # Optional. The public key modulus.
                    },
                    "type": "str"  # Optional. The gateway type.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_gateways_get_gateway_request(
            gateway_id=gateway_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_datasources(self, gateway_id: str, **kwargs: Any) -> JSON:
        """Returns a list of data sources from the specified gateway.

        Permissions
        -----------

        The user must have gateway admin permissions.

        Required Scope
        --------------

        Dataset.ReadWrite.All or Dataset.Read.All

        Limitations
        -----------

        Virtual network (VNet) gateways aren't supported.
        :code:`<br>`:code:`<br>`.

        :param gateway_id: The gateway ID. When using a gateway cluster, the gateway ID refers to the
         primary (first) gateway in the cluster. In such cases, gateway ID is similar to gateway cluster
         ID. Required.
        :type gateway_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional. OData context.
                    "value": [
                        {
                            "credentialType": "str",  # The type of data source
                              `credential </power-bi/developer/embedded/configure-credentials>`_.
                              Required. Known values are: "Basic", "Windows", "Anonymous", "OAuth2",
                              "Key", and "SAS".
                            "gatewayId": "str",  # The associated gateway ID. When using
                              a gateway cluster, the gateway ID refers to the primary (first) gateway
                              in the cluster and is similar to the gateway cluster ID. Required.
                            "id": "str",  # The unique ID for the data source. Required.
                            "connectionDetails": "str",  # Optional. Connection details
                              in JSON format.
                            "credentialDetails": {
                                "useEndUserOAuth2Credentials": bool  # Optional.
                                  Whether the end-user Azure AD identity (OAuth 2.0 credentials) is
                                  used when connecting to the data source in DirectQuery mode. Use with
                                  data sources that support `single sign-on (SSO)
                                  </power-bi/connect-data/power-bi-data-sources#single-sign-on-sso-for-directquery-sources>`_.
                            },
                            "datasourceName": "str",  # Optional. The name of the data
                              source.
                            "datasourceType": "str"  # Optional. The type of `data source
                              </power-bi/connect-data/power-bi-data-sources>`_.  .. list-table::
                              :header-rows: 1     * - API name for the data source      -       -     *
                              - ActiveDirectory      - AdobeAnalytics      - AdoDotNet    * -
                              AnalysisServices      - AzureBlobs      - AzureDataLakeStorage    * -
                              AzureMarketplace      - AzureTables      - BizTalk    * - CDPA      -
                              CustomConnector      - CustomHttpApi    * - DB2      - Essbase      -
                              EventHub    * - Excel      - Exchange      - Extension    * - Facebook
                              - File      - Folder    * - GoogleAnalytics      - Hdfs      - HDInsight
                              * - Informix      - MQ      - MySql    * - OData      - ODBC      - OleDb
                              * - Oracle      - PostgreSql      - PowerQueryMashup     * - PubNub
                              - Salesforce      - SAPBW    * - SAPBWMessageServer      - SapErp      -
                              SAPHana    * - SharePoint      - SharePointDocLib      - SharePointList
                              * - Sql      - Sybase      - Teradata    * - UIFlow      - Web.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_gateways_get_datasources_request(
            gateway_id=gateway_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def create_datasource(
        self,
        gateway_id: str,
        datasource_to_gateway_request: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Creates a new data source on the specified on-premises gateway.

        :code:`<br>`On premises data source credentials must be encrypted. The ``encryptedConnection``
        parameter must be set to ``Encrypted`` and the credentials should be encrypted using the
        gateway public key.

        See the `Create Gateway DataSource
        <https://github.com/microsoft/PowerBI-Developer-Samples/blob/master/PowerShell%20Scripts/CreateDatasource.ps1>`_
        PowerShell script for an example of using this API, this script uses the PowerShell script
        mentioned in the note below for encrypting the credentials.

        ..

           [!NOTE]
           To encrypt credentials, see `Configure credentials programmatically
        </power-bi/developer/embedded/configure-credentials>`_ for Power BI and review the
        EncryptCredentials `.NET Core
        <https://github.com/microsoft/PowerBI-Developer-Samples/tree/master/.NET%20Core/EncryptCredentials>`_\
        , `Java
        <https://github.com/microsoft/PowerBI-Developer-Samples/tree/master/Java/EncryptCredentials>`_\
        , `Python
        <https://github.com/microsoft/PowerBI-Developer-Samples/tree/master/Python/Encrypt%20credentials>`_
        and `PowerShell
        <https://github.com/microsoft/PowerBI-Developer-Samples/blob/master/PowerShell%20Scripts/EncryptGatewayCredentials.ps1>`_
        examples.


        Permissions
        -----------

        Supports only on-premises gateways and the user must have gateway admin permissions

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------


        * Virtual network (VNet) and Cloud gateways aren't supported.
        * OAuth2 as a credential type isn't supported.
          :code:`<br>`:code:`<br>`.

        :param gateway_id: The gateway ID. When using a gateway cluster, the gateway ID refers to the
         primary (first) gateway in the cluster. In such cases, gateway ID is similar to gateway cluster
         ID. Required.
        :type gateway_id: str
        :param datasource_to_gateway_request: A request to create a new data source on a gateway.
         Required.
        :type datasource_to_gateway_request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                datasource_to_gateway_request = {
                    "connectionDetails": "str",  # The connection details. Required.
                    "credentialDetails": {
                        "credentialType": "str",  # The credential type. Required. Known
                          values are: "Basic", "Windows", "Anonymous", "OAuth2", "Key", and "SAS".
                        "credentials": "str",  # The credentials, which depend on the
                          'credentialType' value. For more information, see `Update Datasource
                          </rest/api/power-bi/gateways/update-datasource#examples>`_ examples.
                          Required.
                        "encryptedConnection": "str",  # Whether to encrypt the data source
                          connection. The API call will fail if you select encryption and Power BI is
                          unable to establish an encrypted connection with the data source. Required.
                          Known values are: "Encrypted" and "NotEncrypted".
                        "encryptionAlgorithm": "str",  # The encryption algorithm. For a
                          cloud data source, specify ``None``. For an on-premises data source, specify
                          ``RSA-OAEP`` and use the gateway public key to encrypt the credentials.
                          Required. Known values are: "None" and "RSA-OAEP".
                        "privacyLevel": "str",  # The privacy level, which is relevant when
                          combining data from multiple sources. Required. Known values are: "None",
                          "Public", "Organizational", and "Private".
                        "useCallerAADIdentity": bool,  # Optional. Whether the Azure AD
                          identity (OAuth 2.0 credentials) of the API caller (which must be the data
                          source owner) will be used to configure data source credentials (the owner
                          OAuth access token). Typically, you would either use this flag or
                          ``useEndUserOAuth2Credentials``.
                        "useEndUserOAuth2Credentials": bool  # Optional. Whether the end-user
                          Azure AD identity (OAuth 2.0 credentials) is used when connecting to the data
                          source in DirectQuery mode. Use with data sources that support `single
                          sign-on (SSO)
                          </power-bi/connect-data/power-bi-data-sources#single-sign-on-sso-for-directquery-sources>`_.
                          Typically, you would either use this flag or ``useCallerAADIdentity``.
                    },
                    "dataSourceName": "str",  # The data source name. Required.
                    "dataSourceType": "str"  # The data source type. Required.
                }

                # response body for status code(s): 201
                response == {
                    "credentialType": "str",  # The type of data source `credential
                      </power-bi/developer/embedded/configure-credentials>`_. Required. Known values
                      are: "Basic", "Windows", "Anonymous", "OAuth2", "Key", and "SAS".
                    "gatewayId": "str",  # The associated gateway ID. When using a gateway
                      cluster, the gateway ID refers to the primary (first) gateway in the cluster and
                      is similar to the gateway cluster ID. Required.
                    "id": "str",  # The unique ID for the data source. Required.
                    "connectionDetails": "str",  # Optional. Connection details in JSON format.
                    "credentialDetails": {
                        "useEndUserOAuth2Credentials": bool  # Optional. Whether the end-user
                          Azure AD identity (OAuth 2.0 credentials) is used when connecting to the data
                          source in DirectQuery mode. Use with data sources that support `single
                          sign-on (SSO)
                          </power-bi/connect-data/power-bi-data-sources#single-sign-on-sso-for-directquery-sources>`_.
                    },
                    "datasourceName": "str",  # Optional. The name of the data source.
                    "datasourceType": "str"  # Optional. The type of `data source
                      </power-bi/connect-data/power-bi-data-sources>`_.  .. list-table::
                      :header-rows: 1     * - API name for the data source      -       -     * -
                      ActiveDirectory      - AdobeAnalytics      - AdoDotNet    * - AnalysisServices
                      - AzureBlobs      - AzureDataLakeStorage    * - AzureMarketplace      -
                      AzureTables      - BizTalk    * - CDPA      - CustomConnector      -
                      CustomHttpApi    * - DB2      - Essbase      - EventHub    * - Excel      -
                      Exchange      - Extension    * - Facebook      - File      - Folder    * -
                      GoogleAnalytics      - Hdfs      - HDInsight    * - Informix      - MQ      -
                      MySql    * - OData      - ODBC      - OleDb    * - Oracle      - PostgreSql
                      - PowerQueryMashup     * - PubNub      - Salesforce      - SAPBW    * -
                      SAPBWMessageServer      - SapErp      - SAPHana    * - SharePoint      -
                      SharePointDocLib      - SharePointList    * - Sql      - Sybase      - Teradata
                      * - UIFlow      - Web.
                }
        """

    @overload
    async def create_datasource(
        self,
        gateway_id: str,
        datasource_to_gateway_request: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Creates a new data source on the specified on-premises gateway.

        :code:`<br>`On premises data source credentials must be encrypted. The ``encryptedConnection``
        parameter must be set to ``Encrypted`` and the credentials should be encrypted using the
        gateway public key.

        See the `Create Gateway DataSource
        <https://github.com/microsoft/PowerBI-Developer-Samples/blob/master/PowerShell%20Scripts/CreateDatasource.ps1>`_
        PowerShell script for an example of using this API, this script uses the PowerShell script
        mentioned in the note below for encrypting the credentials.

        ..

           [!NOTE]
           To encrypt credentials, see `Configure credentials programmatically
        </power-bi/developer/embedded/configure-credentials>`_ for Power BI and review the
        EncryptCredentials `.NET Core
        <https://github.com/microsoft/PowerBI-Developer-Samples/tree/master/.NET%20Core/EncryptCredentials>`_\
        , `Java
        <https://github.com/microsoft/PowerBI-Developer-Samples/tree/master/Java/EncryptCredentials>`_\
        , `Python
        <https://github.com/microsoft/PowerBI-Developer-Samples/tree/master/Python/Encrypt%20credentials>`_
        and `PowerShell
        <https://github.com/microsoft/PowerBI-Developer-Samples/blob/master/PowerShell%20Scripts/EncryptGatewayCredentials.ps1>`_
        examples.


        Permissions
        -----------

        Supports only on-premises gateways and the user must have gateway admin permissions

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------


        * Virtual network (VNet) and Cloud gateways aren't supported.
        * OAuth2 as a credential type isn't supported.
          :code:`<br>`:code:`<br>`.

        :param gateway_id: The gateway ID. When using a gateway cluster, the gateway ID refers to the
         primary (first) gateway in the cluster. In such cases, gateway ID is similar to gateway cluster
         ID. Required.
        :type gateway_id: str
        :param datasource_to_gateway_request: A request to create a new data source on a gateway.
         Required.
        :type datasource_to_gateway_request: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "credentialType": "str",  # The type of data source `credential
                      </power-bi/developer/embedded/configure-credentials>`_. Required. Known values
                      are: "Basic", "Windows", "Anonymous", "OAuth2", "Key", and "SAS".
                    "gatewayId": "str",  # The associated gateway ID. When using a gateway
                      cluster, the gateway ID refers to the primary (first) gateway in the cluster and
                      is similar to the gateway cluster ID. Required.
                    "id": "str",  # The unique ID for the data source. Required.
                    "connectionDetails": "str",  # Optional. Connection details in JSON format.
                    "credentialDetails": {
                        "useEndUserOAuth2Credentials": bool  # Optional. Whether the end-user
                          Azure AD identity (OAuth 2.0 credentials) is used when connecting to the data
                          source in DirectQuery mode. Use with data sources that support `single
                          sign-on (SSO)
                          </power-bi/connect-data/power-bi-data-sources#single-sign-on-sso-for-directquery-sources>`_.
                    },
                    "datasourceName": "str",  # Optional. The name of the data source.
                    "datasourceType": "str"  # Optional. The type of `data source
                      </power-bi/connect-data/power-bi-data-sources>`_.  .. list-table::
                      :header-rows: 1     * - API name for the data source      -       -     * -
                      ActiveDirectory      - AdobeAnalytics      - AdoDotNet    * - AnalysisServices
                      - AzureBlobs      - AzureDataLakeStorage    * - AzureMarketplace      -
                      AzureTables      - BizTalk    * - CDPA      - CustomConnector      -
                      CustomHttpApi    * - DB2      - Essbase      - EventHub    * - Excel      -
                      Exchange      - Extension    * - Facebook      - File      - Folder    * -
                      GoogleAnalytics      - Hdfs      - HDInsight    * - Informix      - MQ      -
                      MySql    * - OData      - ODBC      - OleDb    * - Oracle      - PostgreSql
                      - PowerQueryMashup     * - PubNub      - Salesforce      - SAPBW    * -
                      SAPBWMessageServer      - SapErp      - SAPHana    * - SharePoint      -
                      SharePointDocLib      - SharePointList    * - Sql      - Sybase      - Teradata
                      * - UIFlow      - Web.
                }
        """

    @distributed_trace_async
    async def create_datasource(
        self, gateway_id: str, datasource_to_gateway_request: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Creates a new data source on the specified on-premises gateway.

        :code:`<br>`On premises data source credentials must be encrypted. The ``encryptedConnection``
        parameter must be set to ``Encrypted`` and the credentials should be encrypted using the
        gateway public key.

        See the `Create Gateway DataSource
        <https://github.com/microsoft/PowerBI-Developer-Samples/blob/master/PowerShell%20Scripts/CreateDatasource.ps1>`_
        PowerShell script for an example of using this API, this script uses the PowerShell script
        mentioned in the note below for encrypting the credentials.

        ..

           [!NOTE]
           To encrypt credentials, see `Configure credentials programmatically
        </power-bi/developer/embedded/configure-credentials>`_ for Power BI and review the
        EncryptCredentials `.NET Core
        <https://github.com/microsoft/PowerBI-Developer-Samples/tree/master/.NET%20Core/EncryptCredentials>`_\
        , `Java
        <https://github.com/microsoft/PowerBI-Developer-Samples/tree/master/Java/EncryptCredentials>`_\
        , `Python
        <https://github.com/microsoft/PowerBI-Developer-Samples/tree/master/Python/Encrypt%20credentials>`_
        and `PowerShell
        <https://github.com/microsoft/PowerBI-Developer-Samples/blob/master/PowerShell%20Scripts/EncryptGatewayCredentials.ps1>`_
        examples.


        Permissions
        -----------

        Supports only on-premises gateways and the user must have gateway admin permissions

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------


        * Virtual network (VNet) and Cloud gateways aren't supported.
        * OAuth2 as a credential type isn't supported.
          :code:`<br>`:code:`<br>`.

        :param gateway_id: The gateway ID. When using a gateway cluster, the gateway ID refers to the
         primary (first) gateway in the cluster. In such cases, gateway ID is similar to gateway cluster
         ID. Required.
        :type gateway_id: str
        :param datasource_to_gateway_request: A request to create a new data source on a gateway. Is
         either a JSON type or a IO type. Required.
        :type datasource_to_gateway_request: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                datasource_to_gateway_request = {
                    "connectionDetails": "str",  # The connection details. Required.
                    "credentialDetails": {
                        "credentialType": "str",  # The credential type. Required. Known
                          values are: "Basic", "Windows", "Anonymous", "OAuth2", "Key", and "SAS".
                        "credentials": "str",  # The credentials, which depend on the
                          'credentialType' value. For more information, see `Update Datasource
                          </rest/api/power-bi/gateways/update-datasource#examples>`_ examples.
                          Required.
                        "encryptedConnection": "str",  # Whether to encrypt the data source
                          connection. The API call will fail if you select encryption and Power BI is
                          unable to establish an encrypted connection with the data source. Required.
                          Known values are: "Encrypted" and "NotEncrypted".
                        "encryptionAlgorithm": "str",  # The encryption algorithm. For a
                          cloud data source, specify ``None``. For an on-premises data source, specify
                          ``RSA-OAEP`` and use the gateway public key to encrypt the credentials.
                          Required. Known values are: "None" and "RSA-OAEP".
                        "privacyLevel": "str",  # The privacy level, which is relevant when
                          combining data from multiple sources. Required. Known values are: "None",
                          "Public", "Organizational", and "Private".
                        "useCallerAADIdentity": bool,  # Optional. Whether the Azure AD
                          identity (OAuth 2.0 credentials) of the API caller (which must be the data
                          source owner) will be used to configure data source credentials (the owner
                          OAuth access token). Typically, you would either use this flag or
                          ``useEndUserOAuth2Credentials``.
                        "useEndUserOAuth2Credentials": bool  # Optional. Whether the end-user
                          Azure AD identity (OAuth 2.0 credentials) is used when connecting to the data
                          source in DirectQuery mode. Use with data sources that support `single
                          sign-on (SSO)
                          </power-bi/connect-data/power-bi-data-sources#single-sign-on-sso-for-directquery-sources>`_.
                          Typically, you would either use this flag or ``useCallerAADIdentity``.
                    },
                    "dataSourceName": "str",  # The data source name. Required.
                    "dataSourceType": "str"  # The data source type. Required.
                }

                # response body for status code(s): 201
                response == {
                    "credentialType": "str",  # The type of data source `credential
                      </power-bi/developer/embedded/configure-credentials>`_. Required. Known values
                      are: "Basic", "Windows", "Anonymous", "OAuth2", "Key", and "SAS".
                    "gatewayId": "str",  # The associated gateway ID. When using a gateway
                      cluster, the gateway ID refers to the primary (first) gateway in the cluster and
                      is similar to the gateway cluster ID. Required.
                    "id": "str",  # The unique ID for the data source. Required.
                    "connectionDetails": "str",  # Optional. Connection details in JSON format.
                    "credentialDetails": {
                        "useEndUserOAuth2Credentials": bool  # Optional. Whether the end-user
                          Azure AD identity (OAuth 2.0 credentials) is used when connecting to the data
                          source in DirectQuery mode. Use with data sources that support `single
                          sign-on (SSO)
                          </power-bi/connect-data/power-bi-data-sources#single-sign-on-sso-for-directquery-sources>`_.
                    },
                    "datasourceName": "str",  # Optional. The name of the data source.
                    "datasourceType": "str"  # Optional. The type of `data source
                      </power-bi/connect-data/power-bi-data-sources>`_.  .. list-table::
                      :header-rows: 1     * - API name for the data source      -       -     * -
                      ActiveDirectory      - AdobeAnalytics      - AdoDotNet    * - AnalysisServices
                      - AzureBlobs      - AzureDataLakeStorage    * - AzureMarketplace      -
                      AzureTables      - BizTalk    * - CDPA      - CustomConnector      -
                      CustomHttpApi    * - DB2      - Essbase      - EventHub    * - Excel      -
                      Exchange      - Extension    * - Facebook      - File      - Folder    * -
                      GoogleAnalytics      - Hdfs      - HDInsight    * - Informix      - MQ      -
                      MySql    * - OData      - ODBC      - OleDb    * - Oracle      - PostgreSql
                      - PowerQueryMashup     * - PubNub      - Salesforce      - SAPBW    * -
                      SAPBWMessageServer      - SapErp      - SAPHana    * - SharePoint      -
                      SharePointDocLib      - SharePointList    * - Sql      - Sybase      - Teradata
                      * - UIFlow      - Web.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(datasource_to_gateway_request, (IOBase, bytes)):
            _content = datasource_to_gateway_request
        else:
            _json = datasource_to_gateway_request

        _request = build_gateways_create_datasource_request(
            gateway_id=gateway_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_datasource(self, gateway_id: str, datasource_id: str, **kwargs: Any) -> JSON:
        """Returns the specified data source from the specified gateway.

        Permissions
        -----------

        The user must have gateway admin permissions.

        Required Scope
        --------------

        Dataset.ReadWrite.All or Dataset.Read.All

        Limitations
        -----------

        Virtual network (VNet) gateways aren't supported.
        :code:`<br>`:code:`<br>`.

        :param gateway_id: The gateway ID. When using a gateway cluster, the gateway ID refers to the
         primary (first) gateway in the cluster. In such cases, gateway ID is similar to gateway cluster
         ID. Required.
        :type gateway_id: str
        :param datasource_id: The data source ID. Required.
        :type datasource_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "credentialType": "str",  # The type of data source `credential
                      </power-bi/developer/embedded/configure-credentials>`_. Required. Known values
                      are: "Basic", "Windows", "Anonymous", "OAuth2", "Key", and "SAS".
                    "gatewayId": "str",  # The associated gateway ID. When using a gateway
                      cluster, the gateway ID refers to the primary (first) gateway in the cluster and
                      is similar to the gateway cluster ID. Required.
                    "id": "str",  # The unique ID for the data source. Required.
                    "connectionDetails": "str",  # Optional. Connection details in JSON format.
                    "credentialDetails": {
                        "useEndUserOAuth2Credentials": bool  # Optional. Whether the end-user
                          Azure AD identity (OAuth 2.0 credentials) is used when connecting to the data
                          source in DirectQuery mode. Use with data sources that support `single
                          sign-on (SSO)
                          </power-bi/connect-data/power-bi-data-sources#single-sign-on-sso-for-directquery-sources>`_.
                    },
                    "datasourceName": "str",  # Optional. The name of the data source.
                    "datasourceType": "str"  # Optional. The type of `data source
                      </power-bi/connect-data/power-bi-data-sources>`_.  .. list-table::
                      :header-rows: 1     * - API name for the data source      -       -     * -
                      ActiveDirectory      - AdobeAnalytics      - AdoDotNet    * - AnalysisServices
                      - AzureBlobs      - AzureDataLakeStorage    * - AzureMarketplace      -
                      AzureTables      - BizTalk    * - CDPA      - CustomConnector      -
                      CustomHttpApi    * - DB2      - Essbase      - EventHub    * - Excel      -
                      Exchange      - Extension    * - Facebook      - File      - Folder    * -
                      GoogleAnalytics      - Hdfs      - HDInsight    * - Informix      - MQ      -
                      MySql    * - OData      - ODBC      - OleDb    * - Oracle      - PostgreSql
                      - PowerQueryMashup     * - PubNub      - Salesforce      - SAPBW    * -
                      SAPBWMessageServer      - SapErp      - SAPHana    * - SharePoint      -
                      SharePointDocLib      - SharePointList    * - Sql      - Sybase      - Teradata
                      * - UIFlow      - Web.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_gateways_get_datasource_request(
            gateway_id=gateway_id,
            datasource_id=datasource_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def delete_datasource(  # pylint: disable=inconsistent-return-statements
        self, gateway_id: str, datasource_id: str, **kwargs: Any
    ) -> None:
        """Deletes the specified data source from the specified gateway.

        Permissions
        -----------

        The user must have gateway admin permissions.

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------

        Virtual network (VNet) gateways aren't supported.
        :code:`<br>`:code:`<br>`.

        :param gateway_id: The gateway ID. When using a gateway cluster, the gateway ID refers to the
         primary (first) gateway in the cluster. In such cases, gateway ID is similar to gateway cluster
         ID. Required.
        :type gateway_id: str
        :param datasource_id: The data source ID. Required.
        :type datasource_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_gateways_delete_datasource_request(
            gateway_id=gateway_id,
            datasource_id=datasource_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def update_datasource(  # pylint: disable=inconsistent-return-statements
        self,
        gateway_id: str,
        datasource_id: str,
        update_datasource_request: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Updates the credentials of the specified data source from the specified gateway.

        On Premises data source credentials must be encrypted, as described in the `On-premise
        encrypted credentials example
        </rest/api/power-bi/gateways/update-datasource#on-premise-encrypted-credentials-example>`_.

        ..

           [!NOTE]


           * To encrypt credentials, see `Configure credentials programmatically
        </power-bi/developer/embedded/configure-credentials>`_ for Power BI and review the
        EncryptCredentials `.NET Core
        <https://github.com/microsoft/PowerBI-Developer-Samples/tree/master/.NET%20Core/EncryptCredentials>`_\
        , `Java
        <https://github.com/microsoft/PowerBI-Developer-Samples/tree/master/Java/EncryptCredentials>`_
        and `Python
        <https://github.com/microsoft/PowerBI-Developer-Samples/tree/master/Python/Encrypt%20credentials>`_
        examples.
           * Windows credentials before encryption look like the credentials in the credentials of
        `Basic credentials example
        </rest/api/power-bi/gateways/update-datasource#basic-credentials-example>`_.


        When changing from single sign-on to other credential types, such as ``Basic`` or ``OAuth2``\ ,
        set the parameter ``useEndUserOAuth2Credentials`` to ``false`` as described in the `Basic
        credentials example
        </rest/api/power-bi/gateways/update-datasource#basic-credentials-example>`_.

        OAuth 2.0 credentials are valid as long as the provided token is valid. When using the OAuth
        2.0 credential type, do the following:


        * Set the OAuth 2.0 token audience correctly, according to the data source type.
        * Send the OAuth 2.0 token in the payload as shown in the `OAuth 2.0 credentials example
        </rest/api/power-bi/gateways/update-datasource#oauth-2.0-credentials-example>`_.
        * If you're using **Extension** data sources, don't set ``useCallerAADIdentity`` to ``true``.

        Permissions
        -----------


        * With on-premises gateways, the user must have gateway admin permissions.
        * With cloud data sources, user must be the data source owner. Use `Datasets - Take Over API
        </rest/api/power-bi/datasets/take-over-in-group>`_ to transfer ownership over the specified
        dataset or `Paginated reports - Take Over API </rest/api/power-bi/reports/take-over-in-group>`_
        to transfer ownership of the data sources over the specified paginated report.
        * This API call can be called by a service principal profile. For more information see:
        `Service principal profiles in Power BI Embedded
        </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------


        * When setting OAuth credentials, a refresh token isn't incorporated as it is when setting
        credentials through the UI in Power BI service. Therefore, credentials can only be used for one
        hour.
        * Virtual network (VNet) gateways aren't supported.
        * SAS Token credentials are supported only with AzureBlobStorage and AzureDataLakeStorage.
          :code:`<br>`:code:`<br>`.

        :param gateway_id: The gateway ID. When using a gateway cluster, the gateway ID refers to the
         primary (first) gateway in the cluster. In such cases, gateway ID is similar to gateway cluster
         ID. Required.
        :type gateway_id: str
        :param datasource_id: The data source ID. Required.
        :type datasource_id: str
        :param update_datasource_request: The update data source request. Required.
        :type update_datasource_request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                update_datasource_request = {
                    "credentialDetails": {
                        "credentialType": "str",  # The credential type. Required. Known
                          values are: "Basic", "Windows", "Anonymous", "OAuth2", "Key", and "SAS".
                        "credentials": "str",  # The credentials, which depend on the
                          'credentialType' value. For more information, see `Update Datasource
                          </rest/api/power-bi/gateways/update-datasource#examples>`_ examples.
                          Required.
                        "encryptedConnection": "str",  # Whether to encrypt the data source
                          connection. The API call will fail if you select encryption and Power BI is
                          unable to establish an encrypted connection with the data source. Required.
                          Known values are: "Encrypted" and "NotEncrypted".
                        "encryptionAlgorithm": "str",  # The encryption algorithm. For a
                          cloud data source, specify ``None``. For an on-premises data source, specify
                          ``RSA-OAEP`` and use the gateway public key to encrypt the credentials.
                          Required. Known values are: "None" and "RSA-OAEP".
                        "privacyLevel": "str",  # The privacy level, which is relevant when
                          combining data from multiple sources. Required. Known values are: "None",
                          "Public", "Organizational", and "Private".
                        "useCallerAADIdentity": bool,  # Optional. Whether the Azure AD
                          identity (OAuth 2.0 credentials) of the API caller (which must be the data
                          source owner) will be used to configure data source credentials (the owner
                          OAuth access token). Typically, you would either use this flag or
                          ``useEndUserOAuth2Credentials``.
                        "useEndUserOAuth2Credentials": bool  # Optional. Whether the end-user
                          Azure AD identity (OAuth 2.0 credentials) is used when connecting to the data
                          source in DirectQuery mode. Use with data sources that support `single
                          sign-on (SSO)
                          </power-bi/connect-data/power-bi-data-sources#single-sign-on-sso-for-directquery-sources>`_.
                          Typically, you would either use this flag or ``useCallerAADIdentity``.
                    }
                }
        """

    @overload
    async def update_datasource(  # pylint: disable=inconsistent-return-statements
        self,
        gateway_id: str,
        datasource_id: str,
        update_datasource_request: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Updates the credentials of the specified data source from the specified gateway.

        On Premises data source credentials must be encrypted, as described in the `On-premise
        encrypted credentials example
        </rest/api/power-bi/gateways/update-datasource#on-premise-encrypted-credentials-example>`_.

        ..

           [!NOTE]


           * To encrypt credentials, see `Configure credentials programmatically
        </power-bi/developer/embedded/configure-credentials>`_ for Power BI and review the
        EncryptCredentials `.NET Core
        <https://github.com/microsoft/PowerBI-Developer-Samples/tree/master/.NET%20Core/EncryptCredentials>`_\
        , `Java
        <https://github.com/microsoft/PowerBI-Developer-Samples/tree/master/Java/EncryptCredentials>`_
        and `Python
        <https://github.com/microsoft/PowerBI-Developer-Samples/tree/master/Python/Encrypt%20credentials>`_
        examples.
           * Windows credentials before encryption look like the credentials in the credentials of
        `Basic credentials example
        </rest/api/power-bi/gateways/update-datasource#basic-credentials-example>`_.


        When changing from single sign-on to other credential types, such as ``Basic`` or ``OAuth2``\ ,
        set the parameter ``useEndUserOAuth2Credentials`` to ``false`` as described in the `Basic
        credentials example
        </rest/api/power-bi/gateways/update-datasource#basic-credentials-example>`_.

        OAuth 2.0 credentials are valid as long as the provided token is valid. When using the OAuth
        2.0 credential type, do the following:


        * Set the OAuth 2.0 token audience correctly, according to the data source type.
        * Send the OAuth 2.0 token in the payload as shown in the `OAuth 2.0 credentials example
        </rest/api/power-bi/gateways/update-datasource#oauth-2.0-credentials-example>`_.
        * If you're using **Extension** data sources, don't set ``useCallerAADIdentity`` to ``true``.

        Permissions
        -----------


        * With on-premises gateways, the user must have gateway admin permissions.
        * With cloud data sources, user must be the data source owner. Use `Datasets - Take Over API
        </rest/api/power-bi/datasets/take-over-in-group>`_ to transfer ownership over the specified
        dataset or `Paginated reports - Take Over API </rest/api/power-bi/reports/take-over-in-group>`_
        to transfer ownership of the data sources over the specified paginated report.
        * This API call can be called by a service principal profile. For more information see:
        `Service principal profiles in Power BI Embedded
        </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------


        * When setting OAuth credentials, a refresh token isn't incorporated as it is when setting
        credentials through the UI in Power BI service. Therefore, credentials can only be used for one
        hour.
        * Virtual network (VNet) gateways aren't supported.
        * SAS Token credentials are supported only with AzureBlobStorage and AzureDataLakeStorage.
          :code:`<br>`:code:`<br>`.

        :param gateway_id: The gateway ID. When using a gateway cluster, the gateway ID refers to the
         primary (first) gateway in the cluster. In such cases, gateway ID is similar to gateway cluster
         ID. Required.
        :type gateway_id: str
        :param datasource_id: The data source ID. Required.
        :type datasource_id: str
        :param update_datasource_request: The update data source request. Required.
        :type update_datasource_request: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_datasource(  # pylint: disable=inconsistent-return-statements
        self, gateway_id: str, datasource_id: str, update_datasource_request: Union[JSON, IO], **kwargs: Any
    ) -> None:
        """Updates the credentials of the specified data source from the specified gateway.

        On Premises data source credentials must be encrypted, as described in the `On-premise
        encrypted credentials example
        </rest/api/power-bi/gateways/update-datasource#on-premise-encrypted-credentials-example>`_.

        ..

           [!NOTE]


           * To encrypt credentials, see `Configure credentials programmatically
        </power-bi/developer/embedded/configure-credentials>`_ for Power BI and review the
        EncryptCredentials `.NET Core
        <https://github.com/microsoft/PowerBI-Developer-Samples/tree/master/.NET%20Core/EncryptCredentials>`_\
        , `Java
        <https://github.com/microsoft/PowerBI-Developer-Samples/tree/master/Java/EncryptCredentials>`_
        and `Python
        <https://github.com/microsoft/PowerBI-Developer-Samples/tree/master/Python/Encrypt%20credentials>`_
        examples.
           * Windows credentials before encryption look like the credentials in the credentials of
        `Basic credentials example
        </rest/api/power-bi/gateways/update-datasource#basic-credentials-example>`_.


        When changing from single sign-on to other credential types, such as ``Basic`` or ``OAuth2``\ ,
        set the parameter ``useEndUserOAuth2Credentials`` to ``false`` as described in the `Basic
        credentials example
        </rest/api/power-bi/gateways/update-datasource#basic-credentials-example>`_.

        OAuth 2.0 credentials are valid as long as the provided token is valid. When using the OAuth
        2.0 credential type, do the following:


        * Set the OAuth 2.0 token audience correctly, according to the data source type.
        * Send the OAuth 2.0 token in the payload as shown in the `OAuth 2.0 credentials example
        </rest/api/power-bi/gateways/update-datasource#oauth-2.0-credentials-example>`_.
        * If you're using **Extension** data sources, don't set ``useCallerAADIdentity`` to ``true``.

        Permissions
        -----------


        * With on-premises gateways, the user must have gateway admin permissions.
        * With cloud data sources, user must be the data source owner. Use `Datasets - Take Over API
        </rest/api/power-bi/datasets/take-over-in-group>`_ to transfer ownership over the specified
        dataset or `Paginated reports - Take Over API </rest/api/power-bi/reports/take-over-in-group>`_
        to transfer ownership of the data sources over the specified paginated report.
        * This API call can be called by a service principal profile. For more information see:
        `Service principal profiles in Power BI Embedded
        </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------


        * When setting OAuth credentials, a refresh token isn't incorporated as it is when setting
        credentials through the UI in Power BI service. Therefore, credentials can only be used for one
        hour.
        * Virtual network (VNet) gateways aren't supported.
        * SAS Token credentials are supported only with AzureBlobStorage and AzureDataLakeStorage.
          :code:`<br>`:code:`<br>`.

        :param gateway_id: The gateway ID. When using a gateway cluster, the gateway ID refers to the
         primary (first) gateway in the cluster. In such cases, gateway ID is similar to gateway cluster
         ID. Required.
        :type gateway_id: str
        :param datasource_id: The data source ID. Required.
        :type datasource_id: str
        :param update_datasource_request: The update data source request. Is either a JSON type or a IO
         type. Required.
        :type update_datasource_request: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                update_datasource_request = {
                    "credentialDetails": {
                        "credentialType": "str",  # The credential type. Required. Known
                          values are: "Basic", "Windows", "Anonymous", "OAuth2", "Key", and "SAS".
                        "credentials": "str",  # The credentials, which depend on the
                          'credentialType' value. For more information, see `Update Datasource
                          </rest/api/power-bi/gateways/update-datasource#examples>`_ examples.
                          Required.
                        "encryptedConnection": "str",  # Whether to encrypt the data source
                          connection. The API call will fail if you select encryption and Power BI is
                          unable to establish an encrypted connection with the data source. Required.
                          Known values are: "Encrypted" and "NotEncrypted".
                        "encryptionAlgorithm": "str",  # The encryption algorithm. For a
                          cloud data source, specify ``None``. For an on-premises data source, specify
                          ``RSA-OAEP`` and use the gateway public key to encrypt the credentials.
                          Required. Known values are: "None" and "RSA-OAEP".
                        "privacyLevel": "str",  # The privacy level, which is relevant when
                          combining data from multiple sources. Required. Known values are: "None",
                          "Public", "Organizational", and "Private".
                        "useCallerAADIdentity": bool,  # Optional. Whether the Azure AD
                          identity (OAuth 2.0 credentials) of the API caller (which must be the data
                          source owner) will be used to configure data source credentials (the owner
                          OAuth access token). Typically, you would either use this flag or
                          ``useEndUserOAuth2Credentials``.
                        "useEndUserOAuth2Credentials": bool  # Optional. Whether the end-user
                          Azure AD identity (OAuth 2.0 credentials) is used when connecting to the data
                          source in DirectQuery mode. Use with data sources that support `single
                          sign-on (SSO)
                          </power-bi/connect-data/power-bi-data-sources#single-sign-on-sso-for-directquery-sources>`_.
                          Typically, you would either use this flag or ``useCallerAADIdentity``.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(update_datasource_request, (IOBase, bytes)):
            _content = update_datasource_request
        else:
            _json = update_datasource_request

        _request = build_gateways_update_datasource_request(
            gateway_id=gateway_id,
            datasource_id=datasource_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get_datasource_status(  # pylint: disable=inconsistent-return-statements
        self, gateway_id: str, datasource_id: str, **kwargs: Any
    ) -> None:
        """Checks the connectivity status of the specified data source from the specified gateway.

        Permissions
        -----------

        The user must have gateway admin permissions.

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------

        Virtual network (VNet) gateways aren't supported.
        :code:`<br>`:code:`<br>`.

        :param gateway_id: The gateway ID. When using a gateway cluster, the gateway ID refers to the
         primary (first) gateway in the cluster. In such cases, gateway ID is similar to gateway cluster
         ID. Required.
        :type gateway_id: str
        :param datasource_id: The data source ID. Required.
        :type datasource_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_gateways_get_datasource_status_request(
            gateway_id=gateway_id,
            datasource_id=datasource_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get_datasource_users(self, gateway_id: str, datasource_id: str, **kwargs: Any) -> JSON:
        """Returns a list of users who have access to the specified data source.

        Permissions
        -----------

        The user must have gateway admin permissions.

        Required Scope
        --------------

        Dataset.ReadWrite.All or Dataset.Read.All

        Limitations
        -----------

        Virtual network (VNet) gateways aren't supported.
        :code:`<br>`:code:`<br>`.

        :param gateway_id: The gateway ID. When using a gateway cluster, the gateway ID refers to the
         primary (first) gateway in the cluster. In such cases, gateway ID is similar to gateway cluster
         ID. Required.
        :type gateway_id: str
        :param datasource_id: The data source ID. Required.
        :type datasource_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional.
                    "value": [
                        {
                            "datasourceAccessRight": "str",  # The access right
                              (permission level) that a user has on the data source. Required. Known
                              values are: "None", "Read", and "ReadOverrideEffectiveIdentity".
                            "displayName": "str",  # Optional. The display name of the
                              principal.
                            "emailAddress": "str",  # Optional. The email address of the
                              user.
                            "identifier": "str",  # Optional. The `object ID
                              </power-bi/developer/embedded/embedded-troubleshoot#what-is-the-difference-between-application-object-id-and-principal-object-id>`_
                              of the principal.
                            "principalType": "str",  # Optional. The principal type.
                              Known values are: "None", "User", "Group", and "App".
                            "profile": {
                                "id": "str",  # The service principal profile ID.
                                  Required.
                                "displayName": "str"  # Optional. The service
                                  principal profile name.
                            }
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_gateways_get_datasource_users_request(
            gateway_id=gateway_id,
            datasource_id=datasource_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def add_datasource_user(  # pylint: disable=inconsistent-return-statements
        self,
        gateway_id: str,
        datasource_id: str,
        add_user_to_datasource_request: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Grants or updates the permissions required to use the specified data source for the specified
        user.

        Permissions
        -----------

        The user must have gateway admin permissions.

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------

        Virtual network (VNet) gateways aren't supported.
        Adding groups through the API is not supported.
        :code:`<br>`:code:`<br>`.

        :param gateway_id: The gateway ID. When using a gateway cluster, the gateway ID refers to the
         primary (first) gateway in the cluster. In such cases, gateway ID is similar to gateway cluster
         ID. Required.
        :type gateway_id: str
        :param datasource_id: The data source ID. Required.
        :type datasource_id: str
        :param add_user_to_datasource_request: The add user to data source request. Required.
        :type add_user_to_datasource_request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                add_user_to_datasource_request = {
                    "datasourceAccessRight": "str",  # The access right (permission level) that a
                      user has on the data source. Required. Known values are: "None", "Read", and
                      "ReadOverrideEffectiveIdentity".
                    "displayName": "str",  # Optional. The display name of the principal.
                    "emailAddress": "str",  # Optional. The email address of the user.
                    "identifier": "str",  # Optional. The `object ID
                      </power-bi/developer/embedded/embedded-troubleshoot#what-is-the-difference-between-application-object-id-and-principal-object-id>`_
                      of the principal.
                    "principalType": "str",  # Optional. The principal type. Known values are:
                      "None", "User", "Group", and "App".
                    "profile": {
                        "id": "str",  # The service principal profile ID. Required.
                        "displayName": "str"  # Optional. The service principal profile name.
                    }
                }
        """

    @overload
    async def add_datasource_user(  # pylint: disable=inconsistent-return-statements
        self,
        gateway_id: str,
        datasource_id: str,
        add_user_to_datasource_request: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Grants or updates the permissions required to use the specified data source for the specified
        user.

        Permissions
        -----------

        The user must have gateway admin permissions.

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------

        Virtual network (VNet) gateways aren't supported.
        Adding groups through the API is not supported.
        :code:`<br>`:code:`<br>`.

        :param gateway_id: The gateway ID. When using a gateway cluster, the gateway ID refers to the
         primary (first) gateway in the cluster. In such cases, gateway ID is similar to gateway cluster
         ID. Required.
        :type gateway_id: str
        :param datasource_id: The data source ID. Required.
        :type datasource_id: str
        :param add_user_to_datasource_request: The add user to data source request. Required.
        :type add_user_to_datasource_request: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def add_datasource_user(  # pylint: disable=inconsistent-return-statements
        self, gateway_id: str, datasource_id: str, add_user_to_datasource_request: Union[JSON, IO], **kwargs: Any
    ) -> None:
        """Grants or updates the permissions required to use the specified data source for the specified
        user.

        Permissions
        -----------

        The user must have gateway admin permissions.

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------

        Virtual network (VNet) gateways aren't supported.
        Adding groups through the API is not supported.
        :code:`<br>`:code:`<br>`.

        :param gateway_id: The gateway ID. When using a gateway cluster, the gateway ID refers to the
         primary (first) gateway in the cluster. In such cases, gateway ID is similar to gateway cluster
         ID. Required.
        :type gateway_id: str
        :param datasource_id: The data source ID. Required.
        :type datasource_id: str
        :param add_user_to_datasource_request: The add user to data source request. Is either a JSON
         type or a IO type. Required.
        :type add_user_to_datasource_request: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                add_user_to_datasource_request = {
                    "datasourceAccessRight": "str",  # The access right (permission level) that a
                      user has on the data source. Required. Known values are: "None", "Read", and
                      "ReadOverrideEffectiveIdentity".
                    "displayName": "str",  # Optional. The display name of the principal.
                    "emailAddress": "str",  # Optional. The email address of the user.
                    "identifier": "str",  # Optional. The `object ID
                      </power-bi/developer/embedded/embedded-troubleshoot#what-is-the-difference-between-application-object-id-and-principal-object-id>`_
                      of the principal.
                    "principalType": "str",  # Optional. The principal type. Known values are:
                      "None", "User", "Group", and "App".
                    "profile": {
                        "id": "str",  # The service principal profile ID. Required.
                        "displayName": "str"  # Optional. The service principal profile name.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(add_user_to_datasource_request, (IOBase, bytes)):
            _content = add_user_to_datasource_request
        else:
            _json = add_user_to_datasource_request

        _request = build_gateways_add_datasource_user_request(
            gateway_id=gateway_id,
            datasource_id=datasource_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def delete_datasource_user(  # pylint: disable=inconsistent-return-statements
        self, gateway_id: str, datasource_id: str, email_adress: str, *, profile_id: Optional[str] = None, **kwargs: Any
    ) -> None:
        """Removes the specified user from the specified data source.

        Permissions
        -----------

        The user must have gateway admin permissions.

        Required Scope
        --------------

        Dataset.ReadWrite.All

        Limitations
        -----------

        Virtual network (VNet) gateways aren't supported.
        :code:`<br>`:code:`<br>`.

        :param gateway_id: The gateway ID. When using a gateway cluster, the gateway ID refers to the
         primary (first) gateway in the cluster. In such cases, gateway ID is similar to gateway cluster
         ID. Required.
        :type gateway_id: str
        :param datasource_id: The data source ID. Required.
        :type datasource_id: str
        :param email_adress: The user's email address or the object ID of the service principal.
         Required.
        :type email_adress: str
        :keyword profile_id: The service principal profile ID to delete. Default value is None.
        :paramtype profile_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_gateways_delete_datasource_user_request(
            gateway_id=gateway_id,
            datasource_id=datasource_id,
            email_adress=email_adress,
            profile_id=profile_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class GroupsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~power_bi_client.aio.PowerBIClient`'s
        :attr:`groups` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get_groups(
        self, *, filter: Optional[str] = None, top: Optional[int] = None, skip: Optional[int] = None, **kwargs: Any
    ) -> JSON:
        """Returns a list of workspaces the user has access to.

        When user permissions to a workspace have been recently updated, the new permissions might not
        be immediately available through API calls. To refresh user permissions, use the `Refresh User
        Permissions </rest/api/power-bi/users/refresh-user-permissions>`_ API call.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Workspace.Read.All or Workspace.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :keyword filter: Filters the results, based on a boolean condition. Default value is None.
        :paramtype filter: str
        :keyword top: Returns only the first n results. Default value is None.
        :paramtype top: int
        :keyword skip: Skips the first n results. Default value is None.
        :paramtype skip: int
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional. OData context.
                    "value": [
                        {
                            "id": "str",  # The workspace ID. Required.
                            "capacityId": "str",  # Optional. The capacity ID.
                            "dataflowStorageId": "str",  # Optional. The Power BI
                              dataflow storage account ID.
                            "isOnDedicatedCapacity": bool,  # Optional. Whether the group
                              is assigned to a dedicated capacity.
                            "isReadOnly": bool,  # Optional. Whether the group is
                              read-only.
                            "logAnalyticsWorkspace": {
                                "resourceGroup": "str",  # The resource group within
                                  the subscription where the resource resides. Required.
                                "resourceName": "str",  # The name of the resource.
                                  Required.
                                "subscriptionId": "str",  # The Azure subscription
                                  where the resource resides. Required.
                                "id": "str"  # Optional. An identifier for the
                                  resource within Power BI.
                            },
                            "name": "str"  # Optional. The group name.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_groups_get_groups_request(
            filter=filter,
            top=top,
            skip=skip,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def create_group(
        self,
        request_parameters: JSON,
        *,
        workspace_v2: Optional[bool] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Creates a new workspace.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Workspace.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param request_parameters: Create group request parameters. Required.
        :type request_parameters: JSON
        :keyword workspace_v2: (Preview feature) Whether to create a workspace. The only supported
         value is ``true``. Default value is None.
        :paramtype workspace_v2: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                request_parameters = {
                    "name": "str"  # The name of the newly created group. Required.
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # The workspace ID. Required.
                    "capacityId": "str",  # Optional. The capacity ID.
                    "dataflowStorageId": "str",  # Optional. The Power BI dataflow storage
                      account ID.
                    "isOnDedicatedCapacity": bool,  # Optional. Whether the group is assigned to
                      a dedicated capacity.
                    "isReadOnly": bool,  # Optional. Whether the group is read-only.
                    "logAnalyticsWorkspace": {
                        "resourceGroup": "str",  # The resource group within the subscription
                          where the resource resides. Required.
                        "resourceName": "str",  # The name of the resource. Required.
                        "subscriptionId": "str",  # The Azure subscription where the resource
                          resides. Required.
                        "id": "str"  # Optional. An identifier for the resource within Power
                          BI.
                    },
                    "name": "str"  # Optional. The group name.
                }
        """

    @overload
    async def create_group(
        self,
        request_parameters: IO,
        *,
        workspace_v2: Optional[bool] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Creates a new workspace.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Workspace.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param request_parameters: Create group request parameters. Required.
        :type request_parameters: IO
        :keyword workspace_v2: (Preview feature) Whether to create a workspace. The only supported
         value is ``true``. Default value is None.
        :paramtype workspace_v2: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # The workspace ID. Required.
                    "capacityId": "str",  # Optional. The capacity ID.
                    "dataflowStorageId": "str",  # Optional. The Power BI dataflow storage
                      account ID.
                    "isOnDedicatedCapacity": bool,  # Optional. Whether the group is assigned to
                      a dedicated capacity.
                    "isReadOnly": bool,  # Optional. Whether the group is read-only.
                    "logAnalyticsWorkspace": {
                        "resourceGroup": "str",  # The resource group within the subscription
                          where the resource resides. Required.
                        "resourceName": "str",  # The name of the resource. Required.
                        "subscriptionId": "str",  # The Azure subscription where the resource
                          resides. Required.
                        "id": "str"  # Optional. An identifier for the resource within Power
                          BI.
                    },
                    "name": "str"  # Optional. The group name.
                }
        """

    @distributed_trace_async
    async def create_group(
        self, request_parameters: Union[JSON, IO], *, workspace_v2: Optional[bool] = None, **kwargs: Any
    ) -> JSON:
        """Creates a new workspace.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Workspace.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param request_parameters: Create group request parameters. Is either a JSON type or a IO type.
         Required.
        :type request_parameters: JSON or IO
        :keyword workspace_v2: (Preview feature) Whether to create a workspace. The only supported
         value is ``true``. Default value is None.
        :paramtype workspace_v2: bool
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                request_parameters = {
                    "name": "str"  # The name of the newly created group. Required.
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # The workspace ID. Required.
                    "capacityId": "str",  # Optional. The capacity ID.
                    "dataflowStorageId": "str",  # Optional. The Power BI dataflow storage
                      account ID.
                    "isOnDedicatedCapacity": bool,  # Optional. Whether the group is assigned to
                      a dedicated capacity.
                    "isReadOnly": bool,  # Optional. Whether the group is read-only.
                    "logAnalyticsWorkspace": {
                        "resourceGroup": "str",  # The resource group within the subscription
                          where the resource resides. Required.
                        "resourceName": "str",  # The name of the resource. Required.
                        "subscriptionId": "str",  # The Azure subscription where the resource
                          resides. Required.
                        "id": "str"  # Optional. An identifier for the resource within Power
                          BI.
                    },
                    "name": "str"  # Optional. The group name.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(request_parameters, (IOBase, bytes)):
            _content = request_parameters
        else:
            _json = request_parameters

        _request = build_groups_create_group_request(
            workspace_v2=workspace_v2,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def delete_group(  # pylint: disable=inconsistent-return-statements
        self, group_id: str, **kwargs: Any
    ) -> None:
        """Deletes the specified workspace.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Workspace.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID to delete. Required.
        :type group_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_groups_delete_group_request(
            group_id=group_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get_group_users(
        self, group_id: str, *, top: Optional[int] = None, skip: Optional[int] = None, **kwargs: Any
    ) -> JSON:
        """Returns a list of users that have access to the specified workspace.

        When user permissions to a workspace have been recently updated, the new permissions might not
        be immediately available through API calls. As a result, this API call might return an HTTP 401
        error when a user has permissions to a workspace. To refresh user permissions, use the `Refresh
        User Permissions </rest/api/power-bi/users/refresh-user-permissions>`_ API call.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Workspace.Read.All or Workspace.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :keyword top: Returns only the first n results. Default value is None.
        :paramtype top: int
        :keyword skip: Skips the first n results. Default value is None.
        :paramtype skip: int
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional.
                    "value": [
                        {
                            "groupUserAccessRight": "str",  # The access right
                              (permission level) that a user has on the workspace. Required. Known
                              values are: "None", "Member", "Admin", "Contributor", and "Viewer".
                            "identifier": "str",  # Identifier of the principal.
                              Required.
                            "principalType": "str",  # The principal type. Required.
                              Known values are: "None", "User", "Group", and "App".
                            "displayName": "str",  # Optional. Display name of the
                              principal.
                            "emailAddress": "str",  # Optional. Email address of the
                              user.
                            "graphId": "str",  # Optional. Identifier of the principal in
                              Microsoft Graph. Only available for admin APIs.
                            "profile": {
                                "id": "str",  # The service principal profile ID.
                                  Required.
                                "displayName": "str"  # Optional. The service
                                  principal profile name.
                            },
                            "userType": "str"  # Optional. Type of the user.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_groups_get_group_users_request(
            group_id=group_id,
            top=top,
            skip=skip,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def add_group_user(  # pylint: disable=inconsistent-return-statements
        self, group_id: str, user_details: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Grants the specified user the specified permissions to the specified workspace.

        When user permissions to a workspace have been recently updated, the new permissions might not
        be immediately available through API calls. To refresh user permissions, use the `Refresh User
        Permissions </rest/api/power-bi/users/refresh-user-permissions>`_ API call.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Workspace.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param user_details: Details of user access right. Required.
        :type user_details: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                user_details = {
                    "groupUserAccessRight": "str",  # The access right (permission level) that a
                      user has on the workspace. Required. Known values are: "None", "Member", "Admin",
                      "Contributor", and "Viewer".
                    "identifier": "str",  # Identifier of the principal. Required.
                    "principalType": "str",  # The principal type. Required. Known values are:
                      "None", "User", "Group", and "App".
                    "displayName": "str",  # Optional. Display name of the principal.
                    "emailAddress": "str",  # Optional. Email address of the user.
                    "graphId": "str",  # Optional. Identifier of the principal in Microsoft
                      Graph. Only available for admin APIs.
                    "profile": {
                        "id": "str",  # The service principal profile ID. Required.
                        "displayName": "str"  # Optional. The service principal profile name.
                    },
                    "userType": "str"  # Optional. Type of the user.
                }
        """

    @overload
    async def add_group_user(  # pylint: disable=inconsistent-return-statements
        self, group_id: str, user_details: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Grants the specified user the specified permissions to the specified workspace.

        When user permissions to a workspace have been recently updated, the new permissions might not
        be immediately available through API calls. To refresh user permissions, use the `Refresh User
        Permissions </rest/api/power-bi/users/refresh-user-permissions>`_ API call.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Workspace.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param user_details: Details of user access right. Required.
        :type user_details: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def add_group_user(  # pylint: disable=inconsistent-return-statements
        self, group_id: str, user_details: Union[JSON, IO], **kwargs: Any
    ) -> None:
        """Grants the specified user the specified permissions to the specified workspace.

        When user permissions to a workspace have been recently updated, the new permissions might not
        be immediately available through API calls. To refresh user permissions, use the `Refresh User
        Permissions </rest/api/power-bi/users/refresh-user-permissions>`_ API call.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Workspace.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param user_details: Details of user access right. Is either a JSON type or a IO type.
         Required.
        :type user_details: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                user_details = {
                    "groupUserAccessRight": "str",  # The access right (permission level) that a
                      user has on the workspace. Required. Known values are: "None", "Member", "Admin",
                      "Contributor", and "Viewer".
                    "identifier": "str",  # Identifier of the principal. Required.
                    "principalType": "str",  # The principal type. Required. Known values are:
                      "None", "User", "Group", and "App".
                    "displayName": "str",  # Optional. Display name of the principal.
                    "emailAddress": "str",  # Optional. Email address of the user.
                    "graphId": "str",  # Optional. Identifier of the principal in Microsoft
                      Graph. Only available for admin APIs.
                    "profile": {
                        "id": "str",  # The service principal profile ID. Required.
                        "displayName": "str"  # Optional. The service principal profile name.
                    },
                    "userType": "str"  # Optional. Type of the user.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(user_details, (IOBase, bytes)):
            _content = user_details
        else:
            _json = user_details

        _request = build_groups_add_group_user_request(
            group_id=group_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def update_group_user(  # pylint: disable=inconsistent-return-statements
        self, group_id: str, user_details: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Updates the specified user permissions to the specified workspace.

        When user permissions to a workspace have been recently updated, the new permissions might not
        be immediately available through API calls. To refresh user permissions, use the `Refresh User
        Permissions </rest/api/power-bi/users/refresh-user-permissions>`_ API call.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Workspace.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param user_details: Details of user access right. Required.
        :type user_details: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                user_details = {
                    "groupUserAccessRight": "str",  # The access right (permission level) that a
                      user has on the workspace. Required. Known values are: "None", "Member", "Admin",
                      "Contributor", and "Viewer".
                    "identifier": "str",  # Identifier of the principal. Required.
                    "principalType": "str",  # The principal type. Required. Known values are:
                      "None", "User", "Group", and "App".
                    "displayName": "str",  # Optional. Display name of the principal.
                    "emailAddress": "str",  # Optional. Email address of the user.
                    "graphId": "str",  # Optional. Identifier of the principal in Microsoft
                      Graph. Only available for admin APIs.
                    "profile": {
                        "id": "str",  # The service principal profile ID. Required.
                        "displayName": "str"  # Optional. The service principal profile name.
                    },
                    "userType": "str"  # Optional. Type of the user.
                }
        """

    @overload
    async def update_group_user(  # pylint: disable=inconsistent-return-statements
        self, group_id: str, user_details: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Updates the specified user permissions to the specified workspace.

        When user permissions to a workspace have been recently updated, the new permissions might not
        be immediately available through API calls. To refresh user permissions, use the `Refresh User
        Permissions </rest/api/power-bi/users/refresh-user-permissions>`_ API call.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Workspace.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param user_details: Details of user access right. Required.
        :type user_details: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_group_user(  # pylint: disable=inconsistent-return-statements
        self, group_id: str, user_details: Union[JSON, IO], **kwargs: Any
    ) -> None:
        """Updates the specified user permissions to the specified workspace.

        When user permissions to a workspace have been recently updated, the new permissions might not
        be immediately available through API calls. To refresh user permissions, use the `Refresh User
        Permissions </rest/api/power-bi/users/refresh-user-permissions>`_ API call.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Workspace.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param user_details: Details of user access right. Is either a JSON type or a IO type.
         Required.
        :type user_details: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                user_details = {
                    "groupUserAccessRight": "str",  # The access right (permission level) that a
                      user has on the workspace. Required. Known values are: "None", "Member", "Admin",
                      "Contributor", and "Viewer".
                    "identifier": "str",  # Identifier of the principal. Required.
                    "principalType": "str",  # The principal type. Required. Known values are:
                      "None", "User", "Group", and "App".
                    "displayName": "str",  # Optional. Display name of the principal.
                    "emailAddress": "str",  # Optional. Email address of the user.
                    "graphId": "str",  # Optional. Identifier of the principal in Microsoft
                      Graph. Only available for admin APIs.
                    "profile": {
                        "id": "str",  # The service principal profile ID. Required.
                        "displayName": "str"  # Optional. The service principal profile name.
                    },
                    "userType": "str"  # Optional. Type of the user.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(user_details, (IOBase, bytes)):
            _content = user_details
        else:
            _json = user_details

        _request = build_groups_update_group_user_request(
            group_id=group_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def delete_user_in_group(  # pylint: disable=inconsistent-return-statements
        self, group_id: str, user: str, *, profile_id: Optional[str] = None, **kwargs: Any
    ) -> None:
        """Deletes the specified user permissions from the specified workspace.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Workspace.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param user: The email address of the user or object ID of the service principal to delete.
         Required.
        :type user: str
        :keyword profile_id: The service principal profile ID to delete. Default value is None.
        :paramtype profile_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_groups_delete_user_in_group_request(
            group_id=group_id,
            user=user,
            profile_id=profile_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def assign_my_workspace_to_capacity(  # pylint: disable=inconsistent-return-statements
        self, request_parameters: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Assigns **My workspace** to the specified capacity.

        To unassign **My workspace** from a capacity, provide an empty GUID (\
        ``00000000-0000-0000-0000-000000000000``\ ) as the ``capacityId``.

        Permissions
        -----------

        The user must have administrator rights or Assign permission on the capacity.

        Required Scope
        --------------

        Capacity.ReadWrite.All and Workspace.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param request_parameters: Assign to capacity parameters. Required.
        :type request_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                request_parameters = {
                    "capacityId": "str"  # The capacity ID. To unassign from a capacity, use an
                      empty GUID ("" ``00000000-0000-0000-0000-000000000000``"" ). Required.
                }
        """

    @overload
    async def assign_my_workspace_to_capacity(  # pylint: disable=inconsistent-return-statements
        self, request_parameters: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Assigns **My workspace** to the specified capacity.

        To unassign **My workspace** from a capacity, provide an empty GUID (\
        ``00000000-0000-0000-0000-000000000000``\ ) as the ``capacityId``.

        Permissions
        -----------

        The user must have administrator rights or Assign permission on the capacity.

        Required Scope
        --------------

        Capacity.ReadWrite.All and Workspace.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param request_parameters: Assign to capacity parameters. Required.
        :type request_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def assign_my_workspace_to_capacity(  # pylint: disable=inconsistent-return-statements
        self, request_parameters: Union[JSON, IO], **kwargs: Any
    ) -> None:
        """Assigns **My workspace** to the specified capacity.

        To unassign **My workspace** from a capacity, provide an empty GUID (\
        ``00000000-0000-0000-0000-000000000000``\ ) as the ``capacityId``.

        Permissions
        -----------

        The user must have administrator rights or Assign permission on the capacity.

        Required Scope
        --------------

        Capacity.ReadWrite.All and Workspace.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param request_parameters: Assign to capacity parameters. Is either a JSON type or a IO type.
         Required.
        :type request_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                request_parameters = {
                    "capacityId": "str"  # The capacity ID. To unassign from a capacity, use an
                      empty GUID ("" ``00000000-0000-0000-0000-000000000000``"" ). Required.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(request_parameters, (IOBase, bytes)):
            _content = request_parameters
        else:
            _json = request_parameters

        _request = build_groups_assign_my_workspace_to_capacity_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def assign_to_capacity(  # pylint: disable=inconsistent-return-statements
        self, group_id: str, request_parameters: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Assigns the specified workspace to the specified capacity.

        To unassign **My workspace** from a capacity, provide an empty GUID (\
        ``00000000-0000-0000-0000-000000000000``\ ) as the ``capacityId``.

        Permissions
        -----------


        * The user must have administrator rights or assign permissions on the capacity.
        * This API call can be called by a service principal profile. For more information see:
        `Service principal profiles in Power BI Embedded
        </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Capacity.ReadWrite.All and Workspace.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param request_parameters: Assign to capacity parameters. Required.
        :type request_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                request_parameters = {
                    "capacityId": "str"  # The capacity ID. To unassign from a capacity, use an
                      empty GUID ("" ``00000000-0000-0000-0000-000000000000``"" ). Required.
                }
        """

    @overload
    async def assign_to_capacity(  # pylint: disable=inconsistent-return-statements
        self, group_id: str, request_parameters: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Assigns the specified workspace to the specified capacity.

        To unassign **My workspace** from a capacity, provide an empty GUID (\
        ``00000000-0000-0000-0000-000000000000``\ ) as the ``capacityId``.

        Permissions
        -----------


        * The user must have administrator rights or assign permissions on the capacity.
        * This API call can be called by a service principal profile. For more information see:
        `Service principal profiles in Power BI Embedded
        </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Capacity.ReadWrite.All and Workspace.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param request_parameters: Assign to capacity parameters. Required.
        :type request_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def assign_to_capacity(  # pylint: disable=inconsistent-return-statements
        self, group_id: str, request_parameters: Union[JSON, IO], **kwargs: Any
    ) -> None:
        """Assigns the specified workspace to the specified capacity.

        To unassign **My workspace** from a capacity, provide an empty GUID (\
        ``00000000-0000-0000-0000-000000000000``\ ) as the ``capacityId``.

        Permissions
        -----------


        * The user must have administrator rights or assign permissions on the capacity.
        * This API call can be called by a service principal profile. For more information see:
        `Service principal profiles in Power BI Embedded
        </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Capacity.ReadWrite.All and Workspace.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param request_parameters: Assign to capacity parameters. Is either a JSON type or a IO type.
         Required.
        :type request_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                request_parameters = {
                    "capacityId": "str"  # The capacity ID. To unassign from a capacity, use an
                      empty GUID ("" ``00000000-0000-0000-0000-000000000000``"" ). Required.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(request_parameters, (IOBase, bytes)):
            _content = request_parameters
        else:
            _json = request_parameters

        _request = build_groups_assign_to_capacity_request(
            group_id=group_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def capacity_assignment_status_my_workspace(self, **kwargs: Any) -> JSON:
        """Gets the status of the **My workspace** assignment-to-capacity operation.

        Required Scope
        --------------

        Workspace.Read.All and Workspace.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "status": "str",  # The status of a workspace assign-to-capacity operation.
                      Required. Known values are: "Pending", "InProgress", "CompletedSuccessfully", and
                      "AssignmentFailed".
                    "activityId": "str",  # Optional. The activity ID of the assignment operation
                      (provided in case of an assignment failure).
                    "capacityId": "str",  # Optional. The capacity ID.
                    "endTime": "2020-02-20 00:00:00",  # Optional. The end date and time of a
                      workspace assignment operation.
                    "startTime": "2020-02-20 00:00:00"  # Optional. The start date and time of a
                      workspace assignment operation.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_groups_capacity_assignment_status_my_workspace_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def capacity_assignment_status(self, group_id: str, **kwargs: Any) -> JSON:
        """Gets the status of the assignment-to-capacity operation for the specified workspace.

        Permissions
        -----------


        * The user must have administrator rights or assign permissions on the capacity.
        * This API call can be called by a service principal profile. For more information see:
        `Service principal profiles in Power BI Embedded
        </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        Workspace.Read.All and Workspace.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "status": "str",  # The status of a workspace assign-to-capacity operation.
                      Required. Known values are: "Pending", "InProgress", "CompletedSuccessfully", and
                      "AssignmentFailed".
                    "activityId": "str",  # Optional. The activity ID of the assignment operation
                      (provided in case of an assignment failure).
                    "capacityId": "str",  # Optional. The capacity ID.
                    "endTime": "2020-02-20 00:00:00",  # Optional. The end date and time of a
                      workspace assignment operation.
                    "startTime": "2020-02-20 00:00:00"  # Optional. The start date and time of a
                      workspace assignment operation.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_groups_capacity_assignment_status_request(
            group_id=group_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def assign_to_dataflow_storage(  # pylint: disable=inconsistent-return-statements
        self, group_id: str, request_parameters: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Assigns the specified workspace to the specified dataflow storage account.

        To perform this operation, the user must be an admin on the specified workspace and the Power
        BI dataflow storage account must be enabled.

        To unassign the specified workspace from a Power BI dataflow storage account, provide an empty
        GUID (\ ``00000000-0000-0000-0000-000000000000``\ ) as the ``dataflowStorageId``.

        Required Scope
        --------------

        StorageAccount.ReadWrite.All and Workspace.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param request_parameters: Assign to Power BI dataflow storage account parameters. Required.
        :type request_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                request_parameters = {
                    "dataflowStorageId": "str"  # The Power BI dataflow storage account ID. To
                      unassign the specified workspace from a Power BI dataflow storage account, use an
                      empty GUID ("" ``00000000-0000-0000-0000-000000000000``"" ). Required.
                }
        """

    @overload
    async def assign_to_dataflow_storage(  # pylint: disable=inconsistent-return-statements
        self, group_id: str, request_parameters: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Assigns the specified workspace to the specified dataflow storage account.

        To perform this operation, the user must be an admin on the specified workspace and the Power
        BI dataflow storage account must be enabled.

        To unassign the specified workspace from a Power BI dataflow storage account, provide an empty
        GUID (\ ``00000000-0000-0000-0000-000000000000``\ ) as the ``dataflowStorageId``.

        Required Scope
        --------------

        StorageAccount.ReadWrite.All and Workspace.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param request_parameters: Assign to Power BI dataflow storage account parameters. Required.
        :type request_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def assign_to_dataflow_storage(  # pylint: disable=inconsistent-return-statements
        self, group_id: str, request_parameters: Union[JSON, IO], **kwargs: Any
    ) -> None:
        """Assigns the specified workspace to the specified dataflow storage account.

        To perform this operation, the user must be an admin on the specified workspace and the Power
        BI dataflow storage account must be enabled.

        To unassign the specified workspace from a Power BI dataflow storage account, provide an empty
        GUID (\ ``00000000-0000-0000-0000-000000000000``\ ) as the ``dataflowStorageId``.

        Required Scope
        --------------

        StorageAccount.ReadWrite.All and Workspace.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param request_parameters: Assign to Power BI dataflow storage account parameters. Is either a
         JSON type or a IO type. Required.
        :type request_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                request_parameters = {
                    "dataflowStorageId": "str"  # The Power BI dataflow storage account ID. To
                      unassign the specified workspace from a Power BI dataflow storage account, use an
                      empty GUID ("" ``00000000-0000-0000-0000-000000000000``"" ). Required.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(request_parameters, (IOBase, bytes)):
            _content = request_parameters
        else:
            _json = request_parameters

        _request = build_groups_assign_to_dataflow_storage_request(
            group_id=group_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get_groups_as_admin(
        self,
        *,
        top: int,
        expand: Optional[str] = None,
        filter: Optional[str] = None,
        skip: Optional[int] = None,
        **kwargs: Any
    ) -> JSON:
        """Returns a list of workspaces for the organization.

        Permissions
        -----------


        * The user must have administrator rights (such as Office 365 Global Administrator or Power BI
        Service Administrator) or authenticate using a service principal.
        * Delegated permissions are supported.

        When running under service prinicipal authentication, an app **must not** have any
        admin-consent required premissions for Power BI set on it in the Azure portal.

        Required Scope
        --------------

        Tenant.Read.All or Tenant.ReadWrite.All

        Relevant only when authenticating via a standard delegated admin access token. Must not be
        present when authentication via a service principal is used.

        Limitations
        -----------

        Maximum 50 requests per hour, per tenant. This call will also time out after 30 seconds to
        prevent adverse effect on the Power BI service.
        :code:`<br>`:code:`<br>`.

        :keyword top: Returns only the first n results. This parameter is mandatory and must be in the
         range of 1-5000. Required.
        :paramtype top: int
        :keyword expand: Accepts a comma-separated list of data types, which will be expanded inline in
         the response. Supports ``users``\ , ``reports``\ , ``dashboards``\ , ``datasets``\ ,
         ``dataflows``\ , and ``workbooks``. Default value is None.
        :paramtype expand: str
        :keyword filter: Filters the results based on a boolean condition. Default value is None.
        :paramtype filter: str
        :keyword skip: Skips the first n results. Use with top to fetch results beyond the first 5000.
         Default value is None.
        :paramtype skip: int
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional. OData context.
                    "value": [
                        {
                            "id": "str",  # The workspace ID. Required.
                            "capacityId": "str",  # Optional. The capacity ID.
                            "dashboards": [
                                {
                                    "id": "str",  # The dashboard ID. Required.
                                    "appId": "str",  # Optional. The app ID,
                                      returned only if the dashboard belongs to an app.
                                    "displayName": "str",  # Optional. The
                                      display name of the dashboard.
                                    "embedUrl": "str",  # Optional. The embed URL
                                      of the dashboard.
                                    "isReadOnly": bool,  # Optional. Whether the
                                      dashboard is read-only.
                                    "subscriptions": [
                                        {
                                            "id": "str",  # The
                                              subscription ID. Required.
                                            "artifactDisplayName": "str",
                                              # Optional. The name of the subscribed Power BI item
                                              (such as a report or a dashboard).
                                            "artifactId": "str",  #
                                              Optional. The ID of the subscribed Power BI item (such as
                                              a report or a dashboard).
                                            "artifactType": "str",  #
                                              Optional. The type of Power BI item (for example a
                                              ``Report``"" , ``Dashboard``"" , or ``Dataset``"" ).
                                            "attachmentFormat": "str",  #
                                              Optional. Format of the report attached in the email
                                              subscription.
                                            "endDate": "2020-02-20
                                              00:00:00",  # Optional. The end date and time of the
                                              email subscription.
                                            "frequency": "str",  #
                                              Optional. The frequency of the email subscription.
                                            "isEnabled": bool,  #
                                              Optional. Whether the email subscription is enabled.
                                            "linkToContent": bool,  #
                                              Optional. Whether a subscription link exists in the email
                                              subscription.
                                            "previewImage": bool,  #
                                              Optional. Whether a screenshot of the report exists in
                                              the email subscription.
                                            "startDate": "2020-02-20
                                              00:00:00",  # Optional. The start date and time of the
                                              email subscription.
                                            "subArtifactDisplayName":
                                              "str",  # Optional. The page name of the subscribed Power
                                              BI item, if it's a report.
                                            "title": "str",  # Optional.
                                              The app name.
                                            "users": [
                                                {
                                                    "identifier":
                                                      "str",  # Identifier of the principal. Required.
                "principalType": "str",  # The principal type.
                                                      Required. Known values are: "None", "User",
                                                      "Group", and "App".
                "displayName": "str",  # Optional. Display name
                                                      of the principal.
                "emailAddress": "str",  # Optional. Email address
                                                      of the user.
                                                    "graphId":
                                                      "str",  # Optional. Identifier of the principal
                                                      in Microsoft Graph. Only available for admin
                                                      APIs.
                                                    "profile": {
                                                        "id":
                                                          "str",  # The service principal profile ID.
                                                          Required.
                "displayName": "str"  # Optional. The service
                                                          principal profile name.
                                                    },
                                                    "userType":
                                                      "str"  # Optional. Type of the user.
                                                }
                                            ]
                                        }
                                    ],
                                    "tiles": [
                                        {
                                            "id": "str",  # The tile ID.
                                              Required.
                                            "colSpan": 0,  # Optional.
                                              The number of tile span columns.
                                            "datasetId": "str",  #
                                              Optional. The dataset ID. Available only for tiles
                                              created from a report or by using a dataset, such as Q&A
                                              tiles.
                                            "embedData": "str",  #
                                              Optional. The embed data for the tile.
                                            "embedUrl": "str",  #
                                              Optional. The embed URL of the tile.
                                            "reportId": "str",  #
                                              Optional. The report ID. Available only for tiles created
                                              from a report.
                                            "rowSpan": 0,  # Optional.
                                              The number of tile span rows.
                                            "title": "str"  # Optional.
                                              The display name of the tile.
                                        }
                                    ],
                                    "users": [
                                        {
                                            "dashboardUserAccessRight":
                                              "str",  # The access right that the user has for the
                                              dashboard (permission level). Required. Known values are:
                                              "None", "Read", "ReadWrite", "ReadReshare", "ReadCopy",
                                              and "Owner".
                                            "identifier": "str",  #
                                              Identifier of the principal. Required.
                                            "principalType": "str",  #
                                              The principal type. Required. Known values are: "None",
                                              "User", "Group", and "App".
                                            "displayName": "str",  #
                                              Optional. Display name of the principal.
                                            "emailAddress": "str",  #
                                              Optional. Email address of the user.
                                            "graphId": "str",  #
                                              Optional. Identifier of the principal in Microsoft Graph.
                                              Only available for admin APIs.
                                            "profile": {
                                                "id": "str",  # The
                                                  service principal profile ID. Required.
                                                "displayName": "str"
                                                  # Optional. The service principal profile name.
                                            },
                                            "userType": "str"  #
                                              Optional. Type of the user.
                                        }
                                    ],
                                    "webUrl": "str",  # Optional. The web URL of
                                      the dashboard.
                                    "workspaceId": "str"  # Optional. The
                                      workspace ID (GUID) of the dashboard. This property will be
                                      returned only in GetDashboardsAsAdmin.
                                }
                            ],
                            "dataflowStorageId": "str",  # Optional. The Power BI
                              dataflow storage account ID.
                            "dataflows": [
                                {
                                    "objectId": "str",  # The dataflow ID.
                                      Required.
                                    "configuredBy": "str",  # Optional. The
                                      dataflow owner.
                                    "description": "str",  # Optional. The
                                      dataflow description.
                                    "modelUrl": "str",  # Optional. A URL to the
                                      dataflow definition file (model.json).
                                    "modifiedBy": "str",  # Optional. The user
                                      that modified the dataflow.
                                    "modifiedDateTime": "2020-02-20 00:00:00",  #
                                      Optional. The date and time that the dataflow was last modified.
                                    "name": "str",  # Optional. The dataflow
                                      name.
                                    "users": [
                                        {
                                            "identifier": "str",  #
                                              Identifier of the principal. Required.
                                            "principalType": "str",  #
                                              The principal type. Required. Known values are: "None",
                                              "User", "Group", and "App".
                                            "DataflowUserAccessRight":
                                              "str",  # Optional. The access right that a user has for
                                              the dataflow (permission level). Known values are:
                                              "None", "Read", "ReadWrite", "ReadReshare", and "Owner".
                                            "displayName": "str",  #
                                              Optional. Display name of the principal.
                                            "emailAddress": "str",  #
                                              Optional. Email address of the user.
                                            "graphId": "str",  #
                                              Optional. Identifier of the principal in Microsoft Graph.
                                              Only available for admin APIs.
                                            "profile": {
                                                "id": "str",  # The
                                                  service principal profile ID. Required.
                                                "displayName": "str"
                                                  # Optional. The service principal profile name.
                                            },
                                            "userType": "str"  #
                                              Optional. Type of the user.
                                        }
                                    ],
                                    "workspaceId": "str"  # Optional. The
                                      dataflow workspace ID.
                                }
                            ],
                            "datasets": [
                                {
                                    "id": "str",  # The dataset ID. Required.
                                    "ContentProviderType": "str",  # Optional.
                                      The content provider type for the dataset.
                                    "CreateReportEmbedURL": "str",  # Optional.
                                      The dataset create report embed URL.
                                    "CreatedDate": "2020-02-20 00:00:00",  #
                                      Optional. The dataset creation date and time.
                                    "Encryption": {
                                        "EncryptionStatus": "str"  #
                                          Optional. Dataset encryption status. Known values are:
                                          "Unknown", "NotSupported", "InSyncWithWorkspace", and
                                          "NotInSyncWithWorkspace".
                                    },
                                    "IsEffectiveIdentityRequired": bool,  #
                                      Optional. Whether the dataset requires an effective identity,
                                      which you must send in a `GenerateToken
                                      </rest/api/power-bi/embed-token/generate-token>`_ API call.
                                    "IsEffectiveIdentityRolesRequired": bool,  #
                                      Optional. Whether row-level security is defined inside the Power
                                      BI .pbix file. If so, you must specify a role.
                                    "IsInPlaceSharingEnabled": bool,  # Optional.
                                      Whether the dataset can be shared with external users to be
                                      consumed in their own tenant.
                                    "IsOnPremGatewayRequired": bool,  # Optional.
                                      Whether the dataset requires an on-premises data gateway.
                                    "IsRefreshable": bool,  # Optional. Whether
                                      the dataset is refreshable or not. A Power BI refreshable dataset
                                      is a dataset that has been refreshed at least once, or for which
                                      a valid refresh schedule exists.
                                    "QnaEmbedURL": "str",  # Optional. The
                                      dataset Q&A embed URL.
                                    "addRowsAPIEnabled": bool,  # Optional.
                                      Whether the dataset allows adding new rows.
                                    "configuredBy": "str",  # Optional. The
                                      dataset owner.
                                    "description": "str",  # Optional. The
                                      dataset description.
                                    "name": "str",  # Optional. The dataset name.
                                    "queryScaleOutSettings": {
                                        "autoSyncReadOnlyReplicas": bool,  #
                                          Optional. Whether the dataset automatically syncs read-only
                                          replicas.
                                        "maxReadOnlyReplicas": 0  # Optional.
                                          Maximum number of read-only replicas for the dataset (0-64,
                                          -1 for automatic number of replicas).
                                    },
                                    "targetStorageMode": "str",  # Optional. The
                                      dataset storage mode.
                                    "upstreamDataflows": [
                                        {
                                            "groupId": "str",  #
                                              Optional. The target group ID.
                                            "targetDataflowId": "str"  #
                                              Optional. The target dataflow ID.
                                        }
                                    ],
                                    "users": [
                                        {
                                            "datasetUserAccessRight":
                                              "str",  # The access right that the user has for the
                                              dataset (permission level). Required. Known values are:
                                              "None", "Read", "ReadWrite", "ReadReshare",
                                              "ReadWriteReshare", "ReadExplore", "ReadReshareExplore",
                                              "ReadWriteExplore", and "ReadWriteReshareExplore".
                                            "identifier": "str",  #
                                              Identifier of the principal. Required.
                                            "principalType": "str",  #
                                              The principal type. Required. Known values are: "None",
                                              "User", "Group", and "App".
                                            "displayName": "str",  #
                                              Optional. Display name of the principal.
                                            "emailAddress": "str",  #
                                              Optional. Email address of the user.
                                            "graphId": "str",  #
                                              Optional. Identifier of the principal in Microsoft Graph.
                                              Only available for admin APIs.
                                            "profile": {
                                                "id": "str",  # The
                                                  service principal profile ID. Required.
                                                "displayName": "str"
                                                  # Optional. The service principal profile name.
                                            },
                                            "userType": "str"  #
                                              Optional. Type of the user.
                                        }
                                    ],
                                    "webUrl": "str",  # Optional. The web URL of
                                      the dataset.
                                    "workspaceId": "str"  # Optional. The dataset
                                      workspace ID. This property will be returned only in
                                      GetDatasetsAsAdmin.
                                }
                            ],
                            "description": "str",  # Optional. The group description.
                            "hasWorkspaceLevelSettings": bool,  # Optional. Whether the
                              workspace has custom settings.
                            "isOnDedicatedCapacity": bool,  # Optional. Whether the group
                              is assigned to a dedicated capacity.
                            "isReadOnly": bool,  # Optional. Whether the group is
                              read-only.
                            "logAnalyticsWorkspace": {
                                "resourceGroup": "str",  # The resource group within
                                  the subscription where the resource resides. Required.
                                "resourceName": "str",  # The name of the resource.
                                  Required.
                                "subscriptionId": "str",  # The Azure subscription
                                  where the resource resides. Required.
                                "id": "str"  # Optional. An identifier for the
                                  resource within Power BI.
                            },
                            "name": "str",  # Optional. The group name.
                            "pipelineId": "str",  # Optional. The deployment pipeline ID
                              that the workspace is assigned to.
                            "reports": [
                                {
                                    "id": "str",  # The report ID. Required.
                                    "appId": "str",  # Optional. The app ID,
                                      returned only if the report belongs to an app.
                                    "createdBy": "str",  # Optional. The report
                                      owner. Available only for reports created after June 2019.
                                    "createdDateTime": "2020-02-20 00:00:00",  #
                                      Optional. The report creation date and time.
                                    "datasetId": "str",  # Optional. The dataset
                                      ID of the report.
                                    "description": "str",  # Optional. The report
                                      description.
                                    "embedUrl": "str",  # Optional. The embed URL
                                      of the report.
                                    "modifiedBy": "str",  # Optional. The last
                                      user that modified the report.
                                    "modifiedDateTime": "2020-02-20 00:00:00",  #
                                      Optional. The date and time that the report was last modified.
                                    "name": "str",  # Optional. The name of the
                                      report.
                                    "reportType": "str",  # Optional. The report
                                      type. "PaginatedReport"
                                    "subscriptions": [
                                        {
                                            "id": "str",  # The
                                              subscription ID. Required.
                                            "artifactDisplayName": "str",
                                              # Optional. The name of the subscribed Power BI item
                                              (such as a report or a dashboard).
                                            "artifactId": "str",  #
                                              Optional. The ID of the subscribed Power BI item (such as
                                              a report or a dashboard).
                                            "artifactType": "str",  #
                                              Optional. The type of Power BI item (for example a
                                              ``Report``"" , ``Dashboard``"" , or ``Dataset``"" ).
                                            "attachmentFormat": "str",  #
                                              Optional. Format of the report attached in the email
                                              subscription.
                                            "endDate": "2020-02-20
                                              00:00:00",  # Optional. The end date and time of the
                                              email subscription.
                                            "frequency": "str",  #
                                              Optional. The frequency of the email subscription.
                                            "isEnabled": bool,  #
                                              Optional. Whether the email subscription is enabled.
                                            "linkToContent": bool,  #
                                              Optional. Whether a subscription link exists in the email
                                              subscription.
                                            "previewImage": bool,  #
                                              Optional. Whether a screenshot of the report exists in
                                              the email subscription.
                                            "startDate": "2020-02-20
                                              00:00:00",  # Optional. The start date and time of the
                                              email subscription.
                                            "subArtifactDisplayName":
                                              "str",  # Optional. The page name of the subscribed Power
                                              BI item, if it's a report.
                                            "title": "str",  # Optional.
                                              The app name.
                                            "users": [
                                                {
                                                    "identifier":
                                                      "str",  # Identifier of the principal. Required.
                "principalType": "str",  # The principal type.
                                                      Required. Known values are: "None", "User",
                                                      "Group", and "App".
                "displayName": "str",  # Optional. Display name
                                                      of the principal.
                "emailAddress": "str",  # Optional. Email address
                                                      of the user.
                                                    "graphId":
                                                      "str",  # Optional. Identifier of the principal
                                                      in Microsoft Graph. Only available for admin
                                                      APIs.
                                                    "profile": {
                                                        "id":
                                                          "str",  # The service principal profile ID.
                                                          Required.
                "displayName": "str"  # Optional. The service
                                                          principal profile name.
                                                    },
                                                    "userType":
                                                      "str"  # Optional. Type of the user.
                                                }
                                            ]
                                        }
                                    ],
                                    "users": [
                                        {
                                            "identifier": "str",  #
                                              Identifier of the principal. Required.
                                            "principalType": "str",  #
                                              The principal type. Required. Known values are: "None",
                                              "User", "Group", and "App".
                                            "reportUserAccessRight":
                                              "str",  # The access right that the user has for the
                                              report (permission level). Required. Known values are:
                                              "None", "Read", "ReadWrite", "ReadReshare", "ReadCopy",
                                              and "Owner".
                                            "displayName": "str",  #
                                              Optional. Display name of the principal.
                                            "emailAddress": "str",  #
                                              Optional. Email address of the user.
                                            "graphId": "str",  #
                                              Optional. Identifier of the principal in Microsoft Graph.
                                              Only available for admin APIs.
                                            "profile": {
                                                "id": "str",  # The
                                                  service principal profile ID. Required.
                                                "displayName": "str"
                                                  # Optional. The service principal profile name.
                                            },
                                            "userType": "str"  #
                                              Optional. Type of the user.
                                        }
                                    ],
                                    "webUrl": "str",  # Optional. The web URL of
                                      the report.
                                    "workspaceId": "str"  # Optional. The
                                      workspace ID (GUID) of the report. This property will be returned
                                      only in GetReportsAsAdmin.
                                }
                            ],
                            "state": "str",  # Optional. The group state.
                            "type": "str",  # Optional. The type of group being returned.
                              Known values are: "PersonalGroup", "Personal", "Workspace", and "Group".
                            "users": [
                                {
                                    "groupUserAccessRight": "str",  # The access
                                      right (permission level) that a user has on the workspace.
                                      Required. Known values are: "None", "Member", "Admin",
                                      "Contributor", and "Viewer".
                                    "identifier": "str",  # Identifier of the
                                      principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "displayName": "str",  # Optional. Display
                                      name of the principal.
                                    "emailAddress": "str",  # Optional. Email
                                      address of the user.
                                    "graphId": "str",  # Optional. Identifier of
                                      the principal in Microsoft Graph. Only available for admin APIs.
                                    "profile": {
                                        "id": "str",  # The service principal
                                          profile ID. Required.
                                        "displayName": "str"  # Optional. The
                                          service principal profile name.
                                    },
                                    "userType": "str"  # Optional. Type of the
                                      user.
                                }
                            ],
                            "workbooks": [
                                {
                                    "datasetId": "str",  # Optional. The ID of
                                      the dataset associated with a workbook. Only applies if the
                                      workbook has an associated dataset.
                                    "name": "str"  # Optional. The workbook name.
                                }
                            ]
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_groups_get_groups_as_admin_request(
            top=top,
            expand=expand,
            filter=filter,
            skip=skip,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_group_as_admin(self, group_id: str, *, expand: Optional[str] = None, **kwargs: Any) -> JSON:
        """Returns a workspace for the organization.

        Permissions
        -----------


        * The user must have administrator rights (such as Office 365 Global Administrator or Power BI
        Service Administrator) or authenticate using a service principal.
        * Delegated permissions are supported.

        Required Scope
        --------------

        Tenant.Read.All or Tenant.ReadWrite.All

        Limitations
        -----------

        Maximum 200 requests per hour.
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :keyword expand: Accepts a comma-separated list of data types, which will be expanded inline in
         the response. Supports ``users``\ , ``reports``\ , ``dashboards``\ , ``datasets``\ ,
         ``dataflows``\ , and ``workbooks``. Default value is None.
        :paramtype expand: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # The workspace ID. Required.
                    "capacityId": "str",  # Optional. The capacity ID.
                    "dashboards": [
                        {
                            "id": "str",  # The dashboard ID. Required.
                            "appId": "str",  # Optional. The app ID, returned only if the
                              dashboard belongs to an app.
                            "displayName": "str",  # Optional. The display name of the
                              dashboard.
                            "embedUrl": "str",  # Optional. The embed URL of the
                              dashboard.
                            "isReadOnly": bool,  # Optional. Whether the dashboard is
                              read-only.
                            "subscriptions": [
                                {
                                    "id": "str",  # The subscription ID.
                                      Required.
                                    "artifactDisplayName": "str",  # Optional.
                                      The name of the subscribed Power BI item (such as a report or a
                                      dashboard).
                                    "artifactId": "str",  # Optional. The ID of
                                      the subscribed Power BI item (such as a report or a dashboard).
                                    "artifactType": "str",  # Optional. The type
                                      of Power BI item (for example a ``Report``"" , ``Dashboard``"" ,
                                      or ``Dataset``"" ).
                                    "attachmentFormat": "str",  # Optional.
                                      Format of the report attached in the email subscription.
                                    "endDate": "2020-02-20 00:00:00",  #
                                      Optional. The end date and time of the email subscription.
                                    "frequency": "str",  # Optional. The
                                      frequency of the email subscription.
                                    "isEnabled": bool,  # Optional. Whether the
                                      email subscription is enabled.
                                    "linkToContent": bool,  # Optional. Whether a
                                      subscription link exists in the email subscription.
                                    "previewImage": bool,  # Optional. Whether a
                                      screenshot of the report exists in the email subscription.
                                    "startDate": "2020-02-20 00:00:00",  #
                                      Optional. The start date and time of the email subscription.
                                    "subArtifactDisplayName": "str",  # Optional.
                                      The page name of the subscribed Power BI item, if it's a report.
                                    "title": "str",  # Optional. The app name.
                                    "users": [
                                        {
                                            "identifier": "str",  #
                                              Identifier of the principal. Required.
                                            "principalType": "str",  #
                                              The principal type. Required. Known values are: "None",
                                              "User", "Group", and "App".
                                            "displayName": "str",  #
                                              Optional. Display name of the principal.
                                            "emailAddress": "str",  #
                                              Optional. Email address of the user.
                                            "graphId": "str",  #
                                              Optional. Identifier of the principal in Microsoft Graph.
                                              Only available for admin APIs.
                                            "profile": {
                                                "id": "str",  # The
                                                  service principal profile ID. Required.
                                                "displayName": "str"
                                                  # Optional. The service principal profile name.
                                            },
                                            "userType": "str"  #
                                              Optional. Type of the user.
                                        }
                                    ]
                                }
                            ],
                            "tiles": [
                                {
                                    "id": "str",  # The tile ID. Required.
                                    "colSpan": 0,  # Optional. The number of tile
                                      span columns.
                                    "datasetId": "str",  # Optional. The dataset
                                      ID. Available only for tiles created from a report or by using a
                                      dataset, such as Q&A tiles.
                                    "embedData": "str",  # Optional. The embed
                                      data for the tile.
                                    "embedUrl": "str",  # Optional. The embed URL
                                      of the tile.
                                    "reportId": "str",  # Optional. The report
                                      ID. Available only for tiles created from a report.
                                    "rowSpan": 0,  # Optional. The number of tile
                                      span rows.
                                    "title": "str"  # Optional. The display name
                                      of the tile.
                                }
                            ],
                            "users": [
                                {
                                    "dashboardUserAccessRight": "str",  # The
                                      access right that the user has for the dashboard (permission
                                      level). Required. Known values are: "None", "Read", "ReadWrite",
                                      "ReadReshare", "ReadCopy", and "Owner".
                                    "identifier": "str",  # Identifier of the
                                      principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "displayName": "str",  # Optional. Display
                                      name of the principal.
                                    "emailAddress": "str",  # Optional. Email
                                      address of the user.
                                    "graphId": "str",  # Optional. Identifier of
                                      the principal in Microsoft Graph. Only available for admin APIs.
                                    "profile": {
                                        "id": "str",  # The service principal
                                          profile ID. Required.
                                        "displayName": "str"  # Optional. The
                                          service principal profile name.
                                    },
                                    "userType": "str"  # Optional. Type of the
                                      user.
                                }
                            ],
                            "webUrl": "str",  # Optional. The web URL of the dashboard.
                            "workspaceId": "str"  # Optional. The workspace ID (GUID) of
                              the dashboard. This property will be returned only in
                              GetDashboardsAsAdmin.
                        }
                    ],
                    "dataflowStorageId": "str",  # Optional. The Power BI dataflow storage
                      account ID.
                    "dataflows": [
                        {
                            "objectId": "str",  # The dataflow ID. Required.
                            "configuredBy": "str",  # Optional. The dataflow owner.
                            "description": "str",  # Optional. The dataflow description.
                            "modelUrl": "str",  # Optional. A URL to the dataflow
                              definition file (model.json).
                            "modifiedBy": "str",  # Optional. The user that modified the
                              dataflow.
                            "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. The
                              date and time that the dataflow was last modified.
                            "name": "str",  # Optional. The dataflow name.
                            "users": [
                                {
                                    "identifier": "str",  # Identifier of the
                                      principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "DataflowUserAccessRight": "str",  #
                                      Optional. The access right that a user has for the dataflow
                                      (permission level). Known values are: "None", "Read",
                                      "ReadWrite", "ReadReshare", and "Owner".
                                    "displayName": "str",  # Optional. Display
                                      name of the principal.
                                    "emailAddress": "str",  # Optional. Email
                                      address of the user.
                                    "graphId": "str",  # Optional. Identifier of
                                      the principal in Microsoft Graph. Only available for admin APIs.
                                    "profile": {
                                        "id": "str",  # The service principal
                                          profile ID. Required.
                                        "displayName": "str"  # Optional. The
                                          service principal profile name.
                                    },
                                    "userType": "str"  # Optional. Type of the
                                      user.
                                }
                            ],
                            "workspaceId": "str"  # Optional. The dataflow workspace ID.
                        }
                    ],
                    "datasets": [
                        {
                            "id": "str",  # The dataset ID. Required.
                            "ContentProviderType": "str",  # Optional. The content
                              provider type for the dataset.
                            "CreateReportEmbedURL": "str",  # Optional. The dataset
                              create report embed URL.
                            "CreatedDate": "2020-02-20 00:00:00",  # Optional. The
                              dataset creation date and time.
                            "Encryption": {
                                "EncryptionStatus": "str"  # Optional. Dataset
                                  encryption status. Known values are: "Unknown", "NotSupported",
                                  "InSyncWithWorkspace", and "NotInSyncWithWorkspace".
                            },
                            "IsEffectiveIdentityRequired": bool,  # Optional. Whether the
                              dataset requires an effective identity, which you must send in a
                              `GenerateToken </rest/api/power-bi/embed-token/generate-token>`_ API
                              call.
                            "IsEffectiveIdentityRolesRequired": bool,  # Optional.
                              Whether row-level security is defined inside the Power BI .pbix file. If
                              so, you must specify a role.
                            "IsInPlaceSharingEnabled": bool,  # Optional. Whether the
                              dataset can be shared with external users to be consumed in their own
                              tenant.
                            "IsOnPremGatewayRequired": bool,  # Optional. Whether the
                              dataset requires an on-premises data gateway.
                            "IsRefreshable": bool,  # Optional. Whether the dataset is
                              refreshable or not. A Power BI refreshable dataset is a dataset that has
                              been refreshed at least once, or for which a valid refresh schedule
                              exists.
                            "QnaEmbedURL": "str",  # Optional. The dataset Q&A embed URL.
                            "addRowsAPIEnabled": bool,  # Optional. Whether the dataset
                              allows adding new rows.
                            "configuredBy": "str",  # Optional. The dataset owner.
                            "description": "str",  # Optional. The dataset description.
                            "name": "str",  # Optional. The dataset name.
                            "queryScaleOutSettings": {
                                "autoSyncReadOnlyReplicas": bool,  # Optional.
                                  Whether the dataset automatically syncs read-only replicas.
                                "maxReadOnlyReplicas": 0  # Optional. Maximum number
                                  of read-only replicas for the dataset (0-64, -1 for automatic number
                                  of replicas).
                            },
                            "targetStorageMode": "str",  # Optional. The dataset storage
                              mode.
                            "upstreamDataflows": [
                                {
                                    "groupId": "str",  # Optional. The target
                                      group ID.
                                    "targetDataflowId": "str"  # Optional. The
                                      target dataflow ID.
                                }
                            ],
                            "users": [
                                {
                                    "datasetUserAccessRight": "str",  # The
                                      access right that the user has for the dataset (permission
                                      level). Required. Known values are: "None", "Read", "ReadWrite",
                                      "ReadReshare", "ReadWriteReshare", "ReadExplore",
                                      "ReadReshareExplore", "ReadWriteExplore", and
                                      "ReadWriteReshareExplore".
                                    "identifier": "str",  # Identifier of the
                                      principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "displayName": "str",  # Optional. Display
                                      name of the principal.
                                    "emailAddress": "str",  # Optional. Email
                                      address of the user.
                                    "graphId": "str",  # Optional. Identifier of
                                      the principal in Microsoft Graph. Only available for admin APIs.
                                    "profile": {
                                        "id": "str",  # The service principal
                                          profile ID. Required.
                                        "displayName": "str"  # Optional. The
                                          service principal profile name.
                                    },
                                    "userType": "str"  # Optional. Type of the
                                      user.
                                }
                            ],
                            "webUrl": "str",  # Optional. The web URL of the dataset.
                            "workspaceId": "str"  # Optional. The dataset workspace ID.
                              This property will be returned only in GetDatasetsAsAdmin.
                        }
                    ],
                    "description": "str",  # Optional. The group description.
                    "hasWorkspaceLevelSettings": bool,  # Optional. Whether the workspace has
                      custom settings.
                    "isOnDedicatedCapacity": bool,  # Optional. Whether the group is assigned to
                      a dedicated capacity.
                    "isReadOnly": bool,  # Optional. Whether the group is read-only.
                    "logAnalyticsWorkspace": {
                        "resourceGroup": "str",  # The resource group within the subscription
                          where the resource resides. Required.
                        "resourceName": "str",  # The name of the resource. Required.
                        "subscriptionId": "str",  # The Azure subscription where the resource
                          resides. Required.
                        "id": "str"  # Optional. An identifier for the resource within Power
                          BI.
                    },
                    "name": "str",  # Optional. The group name.
                    "pipelineId": "str",  # Optional. The deployment pipeline ID that the
                      workspace is assigned to.
                    "reports": [
                        {
                            "id": "str",  # The report ID. Required.
                            "appId": "str",  # Optional. The app ID, returned only if the
                              report belongs to an app.
                            "createdBy": "str",  # Optional. The report owner. Available
                              only for reports created after June 2019.
                            "createdDateTime": "2020-02-20 00:00:00",  # Optional. The
                              report creation date and time.
                            "datasetId": "str",  # Optional. The dataset ID of the
                              report.
                            "description": "str",  # Optional. The report description.
                            "embedUrl": "str",  # Optional. The embed URL of the report.
                            "modifiedBy": "str",  # Optional. The last user that modified
                              the report.
                            "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. The
                              date and time that the report was last modified.
                            "name": "str",  # Optional. The name of the report.
                            "reportType": "str",  # Optional. The report type.
                              "PaginatedReport"
                            "subscriptions": [
                                {
                                    "id": "str",  # The subscription ID.
                                      Required.
                                    "artifactDisplayName": "str",  # Optional.
                                      The name of the subscribed Power BI item (such as a report or a
                                      dashboard).
                                    "artifactId": "str",  # Optional. The ID of
                                      the subscribed Power BI item (such as a report or a dashboard).
                                    "artifactType": "str",  # Optional. The type
                                      of Power BI item (for example a ``Report``"" , ``Dashboard``"" ,
                                      or ``Dataset``"" ).
                                    "attachmentFormat": "str",  # Optional.
                                      Format of the report attached in the email subscription.
                                    "endDate": "2020-02-20 00:00:00",  #
                                      Optional. The end date and time of the email subscription.
                                    "frequency": "str",  # Optional. The
                                      frequency of the email subscription.
                                    "isEnabled": bool,  # Optional. Whether the
                                      email subscription is enabled.
                                    "linkToContent": bool,  # Optional. Whether a
                                      subscription link exists in the email subscription.
                                    "previewImage": bool,  # Optional. Whether a
                                      screenshot of the report exists in the email subscription.
                                    "startDate": "2020-02-20 00:00:00",  #
                                      Optional. The start date and time of the email subscription.
                                    "subArtifactDisplayName": "str",  # Optional.
                                      The page name of the subscribed Power BI item, if it's a report.
                                    "title": "str",  # Optional. The app name.
                                    "users": [
                                        {
                                            "identifier": "str",  #
                                              Identifier of the principal. Required.
                                            "principalType": "str",  #
                                              The principal type. Required. Known values are: "None",
                                              "User", "Group", and "App".
                                            "displayName": "str",  #
                                              Optional. Display name of the principal.
                                            "emailAddress": "str",  #
                                              Optional. Email address of the user.
                                            "graphId": "str",  #
                                              Optional. Identifier of the principal in Microsoft Graph.
                                              Only available for admin APIs.
                                            "profile": {
                                                "id": "str",  # The
                                                  service principal profile ID. Required.
                                                "displayName": "str"
                                                  # Optional. The service principal profile name.
                                            },
                                            "userType": "str"  #
                                              Optional. Type of the user.
                                        }
                                    ]
                                }
                            ],
                            "users": [
                                {
                                    "identifier": "str",  # Identifier of the
                                      principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "reportUserAccessRight": "str",  # The access
                                      right that the user has for the report (permission level).
                                      Required. Known values are: "None", "Read", "ReadWrite",
                                      "ReadReshare", "ReadCopy", and "Owner".
                                    "displayName": "str",  # Optional. Display
                                      name of the principal.
                                    "emailAddress": "str",  # Optional. Email
                                      address of the user.
                                    "graphId": "str",  # Optional. Identifier of
                                      the principal in Microsoft Graph. Only available for admin APIs.
                                    "profile": {
                                        "id": "str",  # The service principal
                                          profile ID. Required.
                                        "displayName": "str"  # Optional. The
                                          service principal profile name.
                                    },
                                    "userType": "str"  # Optional. Type of the
                                      user.
                                }
                            ],
                            "webUrl": "str",  # Optional. The web URL of the report.
                            "workspaceId": "str"  # Optional. The workspace ID (GUID) of
                              the report. This property will be returned only in GetReportsAsAdmin.
                        }
                    ],
                    "state": "str",  # Optional. The group state.
                    "type": "str",  # Optional. The type of group being returned. Known values
                      are: "PersonalGroup", "Personal", "Workspace", and "Group".
                    "users": [
                        {
                            "groupUserAccessRight": "str",  # The access right
                              (permission level) that a user has on the workspace. Required. Known
                              values are: "None", "Member", "Admin", "Contributor", and "Viewer".
                            "identifier": "str",  # Identifier of the principal.
                              Required.
                            "principalType": "str",  # The principal type. Required.
                              Known values are: "None", "User", "Group", and "App".
                            "displayName": "str",  # Optional. Display name of the
                              principal.
                            "emailAddress": "str",  # Optional. Email address of the
                              user.
                            "graphId": "str",  # Optional. Identifier of the principal in
                              Microsoft Graph. Only available for admin APIs.
                            "profile": {
                                "id": "str",  # The service principal profile ID.
                                  Required.
                                "displayName": "str"  # Optional. The service
                                  principal profile name.
                            },
                            "userType": "str"  # Optional. Type of the user.
                        }
                    ],
                    "workbooks": [
                        {
                            "datasetId": "str",  # Optional. The ID of the dataset
                              associated with a workbook. Only applies if the workbook has an
                              associated dataset.
                            "name": "str"  # Optional. The workbook name.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_groups_get_group_as_admin_request(
            group_id=group_id,
            expand=expand,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def update_group_as_admin(  # pylint: disable=inconsistent-return-statements
        self, group_id: str, group_properties: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Updates the properties of the specified workspace.

        Only the name, description and Log Analytics workspace can be updated. The name must be unique
        inside an organization. To unassign a Log Analytics workspace, explicitly set the value to
        null.

        Permissions
        -----------

        The user must have administrator rights (such as Office 365 Global Administrator or Power BI
        Service Administrator).

        Required Scope
        --------------

        Tenant.ReadWrite.All

        Limitations
        -----------

        Maximum 200 requests per hour.
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param group_properties: The properties to update. Required.
        :type group_properties: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                group_properties = {
                    "id": "str",  # The workspace ID. Required.
                    "capacityId": "str",  # Optional. The capacity ID.
                    "dashboards": [
                        {
                            "id": "str",  # The dashboard ID. Required.
                            "appId": "str",  # Optional. The app ID, returned only if the
                              dashboard belongs to an app.
                            "displayName": "str",  # Optional. The display name of the
                              dashboard.
                            "embedUrl": "str",  # Optional. The embed URL of the
                              dashboard.
                            "isReadOnly": bool,  # Optional. Whether the dashboard is
                              read-only.
                            "subscriptions": [
                                {
                                    "id": "str",  # The subscription ID.
                                      Required.
                                    "artifactDisplayName": "str",  # Optional.
                                      The name of the subscribed Power BI item (such as a report or a
                                      dashboard).
                                    "artifactId": "str",  # Optional. The ID of
                                      the subscribed Power BI item (such as a report or a dashboard).
                                    "artifactType": "str",  # Optional. The type
                                      of Power BI item (for example a ``Report``"" , ``Dashboard``"" ,
                                      or ``Dataset``"" ).
                                    "attachmentFormat": "str",  # Optional.
                                      Format of the report attached in the email subscription.
                                    "endDate": "2020-02-20 00:00:00",  #
                                      Optional. The end date and time of the email subscription.
                                    "frequency": "str",  # Optional. The
                                      frequency of the email subscription.
                                    "isEnabled": bool,  # Optional. Whether the
                                      email subscription is enabled.
                                    "linkToContent": bool,  # Optional. Whether a
                                      subscription link exists in the email subscription.
                                    "previewImage": bool,  # Optional. Whether a
                                      screenshot of the report exists in the email subscription.
                                    "startDate": "2020-02-20 00:00:00",  #
                                      Optional. The start date and time of the email subscription.
                                    "subArtifactDisplayName": "str",  # Optional.
                                      The page name of the subscribed Power BI item, if it's a report.
                                    "title": "str",  # Optional. The app name.
                                    "users": [
                                        {
                                            "identifier": "str",  #
                                              Identifier of the principal. Required.
                                            "principalType": "str",  #
                                              The principal type. Required. Known values are: "None",
                                              "User", "Group", and "App".
                                            "displayName": "str",  #
                                              Optional. Display name of the principal.
                                            "emailAddress": "str",  #
                                              Optional. Email address of the user.
                                            "graphId": "str",  #
                                              Optional. Identifier of the principal in Microsoft Graph.
                                              Only available for admin APIs.
                                            "profile": {
                                                "id": "str",  # The
                                                  service principal profile ID. Required.
                                                "displayName": "str"
                                                  # Optional. The service principal profile name.
                                            },
                                            "userType": "str"  #
                                              Optional. Type of the user.
                                        }
                                    ]
                                }
                            ],
                            "tiles": [
                                {
                                    "id": "str",  # The tile ID. Required.
                                    "colSpan": 0,  # Optional. The number of tile
                                      span columns.
                                    "datasetId": "str",  # Optional. The dataset
                                      ID. Available only for tiles created from a report or by using a
                                      dataset, such as Q&A tiles.
                                    "embedData": "str",  # Optional. The embed
                                      data for the tile.
                                    "embedUrl": "str",  # Optional. The embed URL
                                      of the tile.
                                    "reportId": "str",  # Optional. The report
                                      ID. Available only for tiles created from a report.
                                    "rowSpan": 0,  # Optional. The number of tile
                                      span rows.
                                    "title": "str"  # Optional. The display name
                                      of the tile.
                                }
                            ],
                            "users": [
                                {
                                    "dashboardUserAccessRight": "str",  # The
                                      access right that the user has for the dashboard (permission
                                      level). Required. Known values are: "None", "Read", "ReadWrite",
                                      "ReadReshare", "ReadCopy", and "Owner".
                                    "identifier": "str",  # Identifier of the
                                      principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "displayName": "str",  # Optional. Display
                                      name of the principal.
                                    "emailAddress": "str",  # Optional. Email
                                      address of the user.
                                    "graphId": "str",  # Optional. Identifier of
                                      the principal in Microsoft Graph. Only available for admin APIs.
                                    "profile": {
                                        "id": "str",  # The service principal
                                          profile ID. Required.
                                        "displayName": "str"  # Optional. The
                                          service principal profile name.
                                    },
                                    "userType": "str"  # Optional. Type of the
                                      user.
                                }
                            ],
                            "webUrl": "str",  # Optional. The web URL of the dashboard.
                            "workspaceId": "str"  # Optional. The workspace ID (GUID) of
                              the dashboard. This property will be returned only in
                              GetDashboardsAsAdmin.
                        }
                    ],
                    "dataflowStorageId": "str",  # Optional. The Power BI dataflow storage
                      account ID.
                    "dataflows": [
                        {
                            "objectId": "str",  # The dataflow ID. Required.
                            "configuredBy": "str",  # Optional. The dataflow owner.
                            "description": "str",  # Optional. The dataflow description.
                            "modelUrl": "str",  # Optional. A URL to the dataflow
                              definition file (model.json).
                            "modifiedBy": "str",  # Optional. The user that modified the
                              dataflow.
                            "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. The
                              date and time that the dataflow was last modified.
                            "name": "str",  # Optional. The dataflow name.
                            "users": [
                                {
                                    "identifier": "str",  # Identifier of the
                                      principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "DataflowUserAccessRight": "str",  #
                                      Optional. The access right that a user has for the dataflow
                                      (permission level). Known values are: "None", "Read",
                                      "ReadWrite", "ReadReshare", and "Owner".
                                    "displayName": "str",  # Optional. Display
                                      name of the principal.
                                    "emailAddress": "str",  # Optional. Email
                                      address of the user.
                                    "graphId": "str",  # Optional. Identifier of
                                      the principal in Microsoft Graph. Only available for admin APIs.
                                    "profile": {
                                        "id": "str",  # The service principal
                                          profile ID. Required.
                                        "displayName": "str"  # Optional. The
                                          service principal profile name.
                                    },
                                    "userType": "str"  # Optional. Type of the
                                      user.
                                }
                            ],
                            "workspaceId": "str"  # Optional. The dataflow workspace ID.
                        }
                    ],
                    "datasets": [
                        {
                            "id": "str",  # The dataset ID. Required.
                            "ContentProviderType": "str",  # Optional. The content
                              provider type for the dataset.
                            "CreateReportEmbedURL": "str",  # Optional. The dataset
                              create report embed URL.
                            "CreatedDate": "2020-02-20 00:00:00",  # Optional. The
                              dataset creation date and time.
                            "Encryption": {
                                "EncryptionStatus": "str"  # Optional. Dataset
                                  encryption status. Known values are: "Unknown", "NotSupported",
                                  "InSyncWithWorkspace", and "NotInSyncWithWorkspace".
                            },
                            "IsEffectiveIdentityRequired": bool,  # Optional. Whether the
                              dataset requires an effective identity, which you must send in a
                              `GenerateToken </rest/api/power-bi/embed-token/generate-token>`_ API
                              call.
                            "IsEffectiveIdentityRolesRequired": bool,  # Optional.
                              Whether row-level security is defined inside the Power BI .pbix file. If
                              so, you must specify a role.
                            "IsInPlaceSharingEnabled": bool,  # Optional. Whether the
                              dataset can be shared with external users to be consumed in their own
                              tenant.
                            "IsOnPremGatewayRequired": bool,  # Optional. Whether the
                              dataset requires an on-premises data gateway.
                            "IsRefreshable": bool,  # Optional. Whether the dataset is
                              refreshable or not. A Power BI refreshable dataset is a dataset that has
                              been refreshed at least once, or for which a valid refresh schedule
                              exists.
                            "QnaEmbedURL": "str",  # Optional. The dataset Q&A embed URL.
                            "addRowsAPIEnabled": bool,  # Optional. Whether the dataset
                              allows adding new rows.
                            "configuredBy": "str",  # Optional. The dataset owner.
                            "description": "str",  # Optional. The dataset description.
                            "name": "str",  # Optional. The dataset name.
                            "queryScaleOutSettings": {
                                "autoSyncReadOnlyReplicas": bool,  # Optional.
                                  Whether the dataset automatically syncs read-only replicas.
                                "maxReadOnlyReplicas": 0  # Optional. Maximum number
                                  of read-only replicas for the dataset (0-64, -1 for automatic number
                                  of replicas).
                            },
                            "targetStorageMode": "str",  # Optional. The dataset storage
                              mode.
                            "upstreamDataflows": [
                                {
                                    "groupId": "str",  # Optional. The target
                                      group ID.
                                    "targetDataflowId": "str"  # Optional. The
                                      target dataflow ID.
                                }
                            ],
                            "users": [
                                {
                                    "datasetUserAccessRight": "str",  # The
                                      access right that the user has for the dataset (permission
                                      level). Required. Known values are: "None", "Read", "ReadWrite",
                                      "ReadReshare", "ReadWriteReshare", "ReadExplore",
                                      "ReadReshareExplore", "ReadWriteExplore", and
                                      "ReadWriteReshareExplore".
                                    "identifier": "str",  # Identifier of the
                                      principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "displayName": "str",  # Optional. Display
                                      name of the principal.
                                    "emailAddress": "str",  # Optional. Email
                                      address of the user.
                                    "graphId": "str",  # Optional. Identifier of
                                      the principal in Microsoft Graph. Only available for admin APIs.
                                    "profile": {
                                        "id": "str",  # The service principal
                                          profile ID. Required.
                                        "displayName": "str"  # Optional. The
                                          service principal profile name.
                                    },
                                    "userType": "str"  # Optional. Type of the
                                      user.
                                }
                            ],
                            "webUrl": "str",  # Optional. The web URL of the dataset.
                            "workspaceId": "str"  # Optional. The dataset workspace ID.
                              This property will be returned only in GetDatasetsAsAdmin.
                        }
                    ],
                    "description": "str",  # Optional. The group description.
                    "hasWorkspaceLevelSettings": bool,  # Optional. Whether the workspace has
                      custom settings.
                    "isOnDedicatedCapacity": bool,  # Optional. Whether the group is assigned to
                      a dedicated capacity.
                    "isReadOnly": bool,  # Optional. Whether the group is read-only.
                    "logAnalyticsWorkspace": {
                        "resourceGroup": "str",  # The resource group within the subscription
                          where the resource resides. Required.
                        "resourceName": "str",  # The name of the resource. Required.
                        "subscriptionId": "str",  # The Azure subscription where the resource
                          resides. Required.
                        "id": "str"  # Optional. An identifier for the resource within Power
                          BI.
                    },
                    "name": "str",  # Optional. The group name.
                    "pipelineId": "str",  # Optional. The deployment pipeline ID that the
                      workspace is assigned to.
                    "reports": [
                        {
                            "id": "str",  # The report ID. Required.
                            "appId": "str",  # Optional. The app ID, returned only if the
                              report belongs to an app.
                            "createdBy": "str",  # Optional. The report owner. Available
                              only for reports created after June 2019.
                            "createdDateTime": "2020-02-20 00:00:00",  # Optional. The
                              report creation date and time.
                            "datasetId": "str",  # Optional. The dataset ID of the
                              report.
                            "description": "str",  # Optional. The report description.
                            "embedUrl": "str",  # Optional. The embed URL of the report.
                            "modifiedBy": "str",  # Optional. The last user that modified
                              the report.
                            "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. The
                              date and time that the report was last modified.
                            "name": "str",  # Optional. The name of the report.
                            "reportType": "str",  # Optional. The report type.
                              "PaginatedReport"
                            "subscriptions": [
                                {
                                    "id": "str",  # The subscription ID.
                                      Required.
                                    "artifactDisplayName": "str",  # Optional.
                                      The name of the subscribed Power BI item (such as a report or a
                                      dashboard).
                                    "artifactId": "str",  # Optional. The ID of
                                      the subscribed Power BI item (such as a report or a dashboard).
                                    "artifactType": "str",  # Optional. The type
                                      of Power BI item (for example a ``Report``"" , ``Dashboard``"" ,
                                      or ``Dataset``"" ).
                                    "attachmentFormat": "str",  # Optional.
                                      Format of the report attached in the email subscription.
                                    "endDate": "2020-02-20 00:00:00",  #
                                      Optional. The end date and time of the email subscription.
                                    "frequency": "str",  # Optional. The
                                      frequency of the email subscription.
                                    "isEnabled": bool,  # Optional. Whether the
                                      email subscription is enabled.
                                    "linkToContent": bool,  # Optional. Whether a
                                      subscription link exists in the email subscription.
                                    "previewImage": bool,  # Optional. Whether a
                                      screenshot of the report exists in the email subscription.
                                    "startDate": "2020-02-20 00:00:00",  #
                                      Optional. The start date and time of the email subscription.
                                    "subArtifactDisplayName": "str",  # Optional.
                                      The page name of the subscribed Power BI item, if it's a report.
                                    "title": "str",  # Optional. The app name.
                                    "users": [
                                        {
                                            "identifier": "str",  #
                                              Identifier of the principal. Required.
                                            "principalType": "str",  #
                                              The principal type. Required. Known values are: "None",
                                              "User", "Group", and "App".
                                            "displayName": "str",  #
                                              Optional. Display name of the principal.
                                            "emailAddress": "str",  #
                                              Optional. Email address of the user.
                                            "graphId": "str",  #
                                              Optional. Identifier of the principal in Microsoft Graph.
                                              Only available for admin APIs.
                                            "profile": {
                                                "id": "str",  # The
                                                  service principal profile ID. Required.
                                                "displayName": "str"
                                                  # Optional. The service principal profile name.
                                            },
                                            "userType": "str"  #
                                              Optional. Type of the user.
                                        }
                                    ]
                                }
                            ],
                            "users": [
                                {
                                    "identifier": "str",  # Identifier of the
                                      principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "reportUserAccessRight": "str",  # The access
                                      right that the user has for the report (permission level).
                                      Required. Known values are: "None", "Read", "ReadWrite",
                                      "ReadReshare", "ReadCopy", and "Owner".
                                    "displayName": "str",  # Optional. Display
                                      name of the principal.
                                    "emailAddress": "str",  # Optional. Email
                                      address of the user.
                                    "graphId": "str",  # Optional. Identifier of
                                      the principal in Microsoft Graph. Only available for admin APIs.
                                    "profile": {
                                        "id": "str",  # The service principal
                                          profile ID. Required.
                                        "displayName": "str"  # Optional. The
                                          service principal profile name.
                                    },
                                    "userType": "str"  # Optional. Type of the
                                      user.
                                }
                            ],
                            "webUrl": "str",  # Optional. The web URL of the report.
                            "workspaceId": "str"  # Optional. The workspace ID (GUID) of
                              the report. This property will be returned only in GetReportsAsAdmin.
                        }
                    ],
                    "state": "str",  # Optional. The group state.
                    "type": "str",  # Optional. The type of group being returned. Known values
                      are: "PersonalGroup", "Personal", "Workspace", and "Group".
                    "users": [
                        {
                            "groupUserAccessRight": "str",  # The access right
                              (permission level) that a user has on the workspace. Required. Known
                              values are: "None", "Member", "Admin", "Contributor", and "Viewer".
                            "identifier": "str",  # Identifier of the principal.
                              Required.
                            "principalType": "str",  # The principal type. Required.
                              Known values are: "None", "User", "Group", and "App".
                            "displayName": "str",  # Optional. Display name of the
                              principal.
                            "emailAddress": "str",  # Optional. Email address of the
                              user.
                            "graphId": "str",  # Optional. Identifier of the principal in
                              Microsoft Graph. Only available for admin APIs.
                            "profile": {
                                "id": "str",  # The service principal profile ID.
                                  Required.
                                "displayName": "str"  # Optional. The service
                                  principal profile name.
                            },
                            "userType": "str"  # Optional. Type of the user.
                        }
                    ],
                    "workbooks": [
                        {
                            "datasetId": "str",  # Optional. The ID of the dataset
                              associated with a workbook. Only applies if the workbook has an
                              associated dataset.
                            "name": "str"  # Optional. The workbook name.
                        }
                    ]
                }
        """

    @overload
    async def update_group_as_admin(  # pylint: disable=inconsistent-return-statements
        self, group_id: str, group_properties: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Updates the properties of the specified workspace.

        Only the name, description and Log Analytics workspace can be updated. The name must be unique
        inside an organization. To unassign a Log Analytics workspace, explicitly set the value to
        null.

        Permissions
        -----------

        The user must have administrator rights (such as Office 365 Global Administrator or Power BI
        Service Administrator).

        Required Scope
        --------------

        Tenant.ReadWrite.All

        Limitations
        -----------

        Maximum 200 requests per hour.
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param group_properties: The properties to update. Required.
        :type group_properties: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_group_as_admin(  # pylint: disable=inconsistent-return-statements
        self, group_id: str, group_properties: Union[JSON, IO], **kwargs: Any
    ) -> None:
        """Updates the properties of the specified workspace.

        Only the name, description and Log Analytics workspace can be updated. The name must be unique
        inside an organization. To unassign a Log Analytics workspace, explicitly set the value to
        null.

        Permissions
        -----------

        The user must have administrator rights (such as Office 365 Global Administrator or Power BI
        Service Administrator).

        Required Scope
        --------------

        Tenant.ReadWrite.All

        Limitations
        -----------

        Maximum 200 requests per hour.
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param group_properties: The properties to update. Is either a JSON type or a IO type.
         Required.
        :type group_properties: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                group_properties = {
                    "id": "str",  # The workspace ID. Required.
                    "capacityId": "str",  # Optional. The capacity ID.
                    "dashboards": [
                        {
                            "id": "str",  # The dashboard ID. Required.
                            "appId": "str",  # Optional. The app ID, returned only if the
                              dashboard belongs to an app.
                            "displayName": "str",  # Optional. The display name of the
                              dashboard.
                            "embedUrl": "str",  # Optional. The embed URL of the
                              dashboard.
                            "isReadOnly": bool,  # Optional. Whether the dashboard is
                              read-only.
                            "subscriptions": [
                                {
                                    "id": "str",  # The subscription ID.
                                      Required.
                                    "artifactDisplayName": "str",  # Optional.
                                      The name of the subscribed Power BI item (such as a report or a
                                      dashboard).
                                    "artifactId": "str",  # Optional. The ID of
                                      the subscribed Power BI item (such as a report or a dashboard).
                                    "artifactType": "str",  # Optional. The type
                                      of Power BI item (for example a ``Report``"" , ``Dashboard``"" ,
                                      or ``Dataset``"" ).
                                    "attachmentFormat": "str",  # Optional.
                                      Format of the report attached in the email subscription.
                                    "endDate": "2020-02-20 00:00:00",  #
                                      Optional. The end date and time of the email subscription.
                                    "frequency": "str",  # Optional. The
                                      frequency of the email subscription.
                                    "isEnabled": bool,  # Optional. Whether the
                                      email subscription is enabled.
                                    "linkToContent": bool,  # Optional. Whether a
                                      subscription link exists in the email subscription.
                                    "previewImage": bool,  # Optional. Whether a
                                      screenshot of the report exists in the email subscription.
                                    "startDate": "2020-02-20 00:00:00",  #
                                      Optional. The start date and time of the email subscription.
                                    "subArtifactDisplayName": "str",  # Optional.
                                      The page name of the subscribed Power BI item, if it's a report.
                                    "title": "str",  # Optional. The app name.
                                    "users": [
                                        {
                                            "identifier": "str",  #
                                              Identifier of the principal. Required.
                                            "principalType": "str",  #
                                              The principal type. Required. Known values are: "None",
                                              "User", "Group", and "App".
                                            "displayName": "str",  #
                                              Optional. Display name of the principal.
                                            "emailAddress": "str",  #
                                              Optional. Email address of the user.
                                            "graphId": "str",  #
                                              Optional. Identifier of the principal in Microsoft Graph.
                                              Only available for admin APIs.
                                            "profile": {
                                                "id": "str",  # The
                                                  service principal profile ID. Required.
                                                "displayName": "str"
                                                  # Optional. The service principal profile name.
                                            },
                                            "userType": "str"  #
                                              Optional. Type of the user.
                                        }
                                    ]
                                }
                            ],
                            "tiles": [
                                {
                                    "id": "str",  # The tile ID. Required.
                                    "colSpan": 0,  # Optional. The number of tile
                                      span columns.
                                    "datasetId": "str",  # Optional. The dataset
                                      ID. Available only for tiles created from a report or by using a
                                      dataset, such as Q&A tiles.
                                    "embedData": "str",  # Optional. The embed
                                      data for the tile.
                                    "embedUrl": "str",  # Optional. The embed URL
                                      of the tile.
                                    "reportId": "str",  # Optional. The report
                                      ID. Available only for tiles created from a report.
                                    "rowSpan": 0,  # Optional. The number of tile
                                      span rows.
                                    "title": "str"  # Optional. The display name
                                      of the tile.
                                }
                            ],
                            "users": [
                                {
                                    "dashboardUserAccessRight": "str",  # The
                                      access right that the user has for the dashboard (permission
                                      level). Required. Known values are: "None", "Read", "ReadWrite",
                                      "ReadReshare", "ReadCopy", and "Owner".
                                    "identifier": "str",  # Identifier of the
                                      principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "displayName": "str",  # Optional. Display
                                      name of the principal.
                                    "emailAddress": "str",  # Optional. Email
                                      address of the user.
                                    "graphId": "str",  # Optional. Identifier of
                                      the principal in Microsoft Graph. Only available for admin APIs.
                                    "profile": {
                                        "id": "str",  # The service principal
                                          profile ID. Required.
                                        "displayName": "str"  # Optional. The
                                          service principal profile name.
                                    },
                                    "userType": "str"  # Optional. Type of the
                                      user.
                                }
                            ],
                            "webUrl": "str",  # Optional. The web URL of the dashboard.
                            "workspaceId": "str"  # Optional. The workspace ID (GUID) of
                              the dashboard. This property will be returned only in
                              GetDashboardsAsAdmin.
                        }
                    ],
                    "dataflowStorageId": "str",  # Optional. The Power BI dataflow storage
                      account ID.
                    "dataflows": [
                        {
                            "objectId": "str",  # The dataflow ID. Required.
                            "configuredBy": "str",  # Optional. The dataflow owner.
                            "description": "str",  # Optional. The dataflow description.
                            "modelUrl": "str",  # Optional. A URL to the dataflow
                              definition file (model.json).
                            "modifiedBy": "str",  # Optional. The user that modified the
                              dataflow.
                            "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. The
                              date and time that the dataflow was last modified.
                            "name": "str",  # Optional. The dataflow name.
                            "users": [
                                {
                                    "identifier": "str",  # Identifier of the
                                      principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "DataflowUserAccessRight": "str",  #
                                      Optional. The access right that a user has for the dataflow
                                      (permission level). Known values are: "None", "Read",
                                      "ReadWrite", "ReadReshare", and "Owner".
                                    "displayName": "str",  # Optional. Display
                                      name of the principal.
                                    "emailAddress": "str",  # Optional. Email
                                      address of the user.
                                    "graphId": "str",  # Optional. Identifier of
                                      the principal in Microsoft Graph. Only available for admin APIs.
                                    "profile": {
                                        "id": "str",  # The service principal
                                          profile ID. Required.
                                        "displayName": "str"  # Optional. The
                                          service principal profile name.
                                    },
                                    "userType": "str"  # Optional. Type of the
                                      user.
                                }
                            ],
                            "workspaceId": "str"  # Optional. The dataflow workspace ID.
                        }
                    ],
                    "datasets": [
                        {
                            "id": "str",  # The dataset ID. Required.
                            "ContentProviderType": "str",  # Optional. The content
                              provider type for the dataset.
                            "CreateReportEmbedURL": "str",  # Optional. The dataset
                              create report embed URL.
                            "CreatedDate": "2020-02-20 00:00:00",  # Optional. The
                              dataset creation date and time.
                            "Encryption": {
                                "EncryptionStatus": "str"  # Optional. Dataset
                                  encryption status. Known values are: "Unknown", "NotSupported",
                                  "InSyncWithWorkspace", and "NotInSyncWithWorkspace".
                            },
                            "IsEffectiveIdentityRequired": bool,  # Optional. Whether the
                              dataset requires an effective identity, which you must send in a
                              `GenerateToken </rest/api/power-bi/embed-token/generate-token>`_ API
                              call.
                            "IsEffectiveIdentityRolesRequired": bool,  # Optional.
                              Whether row-level security is defined inside the Power BI .pbix file. If
                              so, you must specify a role.
                            "IsInPlaceSharingEnabled": bool,  # Optional. Whether the
                              dataset can be shared with external users to be consumed in their own
                              tenant.
                            "IsOnPremGatewayRequired": bool,  # Optional. Whether the
                              dataset requires an on-premises data gateway.
                            "IsRefreshable": bool,  # Optional. Whether the dataset is
                              refreshable or not. A Power BI refreshable dataset is a dataset that has
                              been refreshed at least once, or for which a valid refresh schedule
                              exists.
                            "QnaEmbedURL": "str",  # Optional. The dataset Q&A embed URL.
                            "addRowsAPIEnabled": bool,  # Optional. Whether the dataset
                              allows adding new rows.
                            "configuredBy": "str",  # Optional. The dataset owner.
                            "description": "str",  # Optional. The dataset description.
                            "name": "str",  # Optional. The dataset name.
                            "queryScaleOutSettings": {
                                "autoSyncReadOnlyReplicas": bool,  # Optional.
                                  Whether the dataset automatically syncs read-only replicas.
                                "maxReadOnlyReplicas": 0  # Optional. Maximum number
                                  of read-only replicas for the dataset (0-64, -1 for automatic number
                                  of replicas).
                            },
                            "targetStorageMode": "str",  # Optional. The dataset storage
                              mode.
                            "upstreamDataflows": [
                                {
                                    "groupId": "str",  # Optional. The target
                                      group ID.
                                    "targetDataflowId": "str"  # Optional. The
                                      target dataflow ID.
                                }
                            ],
                            "users": [
                                {
                                    "datasetUserAccessRight": "str",  # The
                                      access right that the user has for the dataset (permission
                                      level). Required. Known values are: "None", "Read", "ReadWrite",
                                      "ReadReshare", "ReadWriteReshare", "ReadExplore",
                                      "ReadReshareExplore", "ReadWriteExplore", and
                                      "ReadWriteReshareExplore".
                                    "identifier": "str",  # Identifier of the
                                      principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "displayName": "str",  # Optional. Display
                                      name of the principal.
                                    "emailAddress": "str",  # Optional. Email
                                      address of the user.
                                    "graphId": "str",  # Optional. Identifier of
                                      the principal in Microsoft Graph. Only available for admin APIs.
                                    "profile": {
                                        "id": "str",  # The service principal
                                          profile ID. Required.
                                        "displayName": "str"  # Optional. The
                                          service principal profile name.
                                    },
                                    "userType": "str"  # Optional. Type of the
                                      user.
                                }
                            ],
                            "webUrl": "str",  # Optional. The web URL of the dataset.
                            "workspaceId": "str"  # Optional. The dataset workspace ID.
                              This property will be returned only in GetDatasetsAsAdmin.
                        }
                    ],
                    "description": "str",  # Optional. The group description.
                    "hasWorkspaceLevelSettings": bool,  # Optional. Whether the workspace has
                      custom settings.
                    "isOnDedicatedCapacity": bool,  # Optional. Whether the group is assigned to
                      a dedicated capacity.
                    "isReadOnly": bool,  # Optional. Whether the group is read-only.
                    "logAnalyticsWorkspace": {
                        "resourceGroup": "str",  # The resource group within the subscription
                          where the resource resides. Required.
                        "resourceName": "str",  # The name of the resource. Required.
                        "subscriptionId": "str",  # The Azure subscription where the resource
                          resides. Required.
                        "id": "str"  # Optional. An identifier for the resource within Power
                          BI.
                    },
                    "name": "str",  # Optional. The group name.
                    "pipelineId": "str",  # Optional. The deployment pipeline ID that the
                      workspace is assigned to.
                    "reports": [
                        {
                            "id": "str",  # The report ID. Required.
                            "appId": "str",  # Optional. The app ID, returned only if the
                              report belongs to an app.
                            "createdBy": "str",  # Optional. The report owner. Available
                              only for reports created after June 2019.
                            "createdDateTime": "2020-02-20 00:00:00",  # Optional. The
                              report creation date and time.
                            "datasetId": "str",  # Optional. The dataset ID of the
                              report.
                            "description": "str",  # Optional. The report description.
                            "embedUrl": "str",  # Optional. The embed URL of the report.
                            "modifiedBy": "str",  # Optional. The last user that modified
                              the report.
                            "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. The
                              date and time that the report was last modified.
                            "name": "str",  # Optional. The name of the report.
                            "reportType": "str",  # Optional. The report type.
                              "PaginatedReport"
                            "subscriptions": [
                                {
                                    "id": "str",  # The subscription ID.
                                      Required.
                                    "artifactDisplayName": "str",  # Optional.
                                      The name of the subscribed Power BI item (such as a report or a
                                      dashboard).
                                    "artifactId": "str",  # Optional. The ID of
                                      the subscribed Power BI item (such as a report or a dashboard).
                                    "artifactType": "str",  # Optional. The type
                                      of Power BI item (for example a ``Report``"" , ``Dashboard``"" ,
                                      or ``Dataset``"" ).
                                    "attachmentFormat": "str",  # Optional.
                                      Format of the report attached in the email subscription.
                                    "endDate": "2020-02-20 00:00:00",  #
                                      Optional. The end date and time of the email subscription.
                                    "frequency": "str",  # Optional. The
                                      frequency of the email subscription.
                                    "isEnabled": bool,  # Optional. Whether the
                                      email subscription is enabled.
                                    "linkToContent": bool,  # Optional. Whether a
                                      subscription link exists in the email subscription.
                                    "previewImage": bool,  # Optional. Whether a
                                      screenshot of the report exists in the email subscription.
                                    "startDate": "2020-02-20 00:00:00",  #
                                      Optional. The start date and time of the email subscription.
                                    "subArtifactDisplayName": "str",  # Optional.
                                      The page name of the subscribed Power BI item, if it's a report.
                                    "title": "str",  # Optional. The app name.
                                    "users": [
                                        {
                                            "identifier": "str",  #
                                              Identifier of the principal. Required.
                                            "principalType": "str",  #
                                              The principal type. Required. Known values are: "None",
                                              "User", "Group", and "App".
                                            "displayName": "str",  #
                                              Optional. Display name of the principal.
                                            "emailAddress": "str",  #
                                              Optional. Email address of the user.
                                            "graphId": "str",  #
                                              Optional. Identifier of the principal in Microsoft Graph.
                                              Only available for admin APIs.
                                            "profile": {
                                                "id": "str",  # The
                                                  service principal profile ID. Required.
                                                "displayName": "str"
                                                  # Optional. The service principal profile name.
                                            },
                                            "userType": "str"  #
                                              Optional. Type of the user.
                                        }
                                    ]
                                }
                            ],
                            "users": [
                                {
                                    "identifier": "str",  # Identifier of the
                                      principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "reportUserAccessRight": "str",  # The access
                                      right that the user has for the report (permission level).
                                      Required. Known values are: "None", "Read", "ReadWrite",
                                      "ReadReshare", "ReadCopy", and "Owner".
                                    "displayName": "str",  # Optional. Display
                                      name of the principal.
                                    "emailAddress": "str",  # Optional. Email
                                      address of the user.
                                    "graphId": "str",  # Optional. Identifier of
                                      the principal in Microsoft Graph. Only available for admin APIs.
                                    "profile": {
                                        "id": "str",  # The service principal
                                          profile ID. Required.
                                        "displayName": "str"  # Optional. The
                                          service principal profile name.
                                    },
                                    "userType": "str"  # Optional. Type of the
                                      user.
                                }
                            ],
                            "webUrl": "str",  # Optional. The web URL of the report.
                            "workspaceId": "str"  # Optional. The workspace ID (GUID) of
                              the report. This property will be returned only in GetReportsAsAdmin.
                        }
                    ],
                    "state": "str",  # Optional. The group state.
                    "type": "str",  # Optional. The type of group being returned. Known values
                      are: "PersonalGroup", "Personal", "Workspace", and "Group".
                    "users": [
                        {
                            "groupUserAccessRight": "str",  # The access right
                              (permission level) that a user has on the workspace. Required. Known
                              values are: "None", "Member", "Admin", "Contributor", and "Viewer".
                            "identifier": "str",  # Identifier of the principal.
                              Required.
                            "principalType": "str",  # The principal type. Required.
                              Known values are: "None", "User", "Group", and "App".
                            "displayName": "str",  # Optional. Display name of the
                              principal.
                            "emailAddress": "str",  # Optional. Email address of the
                              user.
                            "graphId": "str",  # Optional. Identifier of the principal in
                              Microsoft Graph. Only available for admin APIs.
                            "profile": {
                                "id": "str",  # The service principal profile ID.
                                  Required.
                                "displayName": "str"  # Optional. The service
                                  principal profile name.
                            },
                            "userType": "str"  # Optional. Type of the user.
                        }
                    ],
                    "workbooks": [
                        {
                            "datasetId": "str",  # Optional. The ID of the dataset
                              associated with a workbook. Only applies if the workbook has an
                              associated dataset.
                            "name": "str"  # Optional. The workbook name.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(group_properties, (IOBase, bytes)):
            _content = group_properties
        else:
            _json = group_properties

        _request = build_groups_update_group_as_admin_request(
            group_id=group_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get_group_users_as_admin(self, group_id: str, **kwargs: Any) -> JSON:
        """Returns a list of users that have access to the specified workspace.

        Permissions
        -----------


        * The user must have administrator rights (such as Office 365 Global Administrator or Power BI
        Service Administrator) or authenticate using a service principal.
        * Delegated permissions are supported.

        When running under service prinicipal authentication, an app **must not** have any
        admin-consent required premissions for Power BI set on it in the Azure portal.

        Required Scope
        --------------

        Tenant.Read.All or Tenant.ReadWrite.All

        Relevant only when authenticating via a standard delegated admin access token. Must not be
        present when authentication via a service principal is used.

        Limitations
        -----------

        Maximum 200 requests per hour.
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional.
                    "value": [
                        {
                            "groupUserAccessRight": "str",  # The access right
                              (permission level) that a user has on the workspace. Required. Known
                              values are: "None", "Member", "Admin", "Contributor", and "Viewer".
                            "identifier": "str",  # Identifier of the principal.
                              Required.
                            "principalType": "str",  # The principal type. Required.
                              Known values are: "None", "User", "Group", and "App".
                            "displayName": "str",  # Optional. Display name of the
                              principal.
                            "emailAddress": "str",  # Optional. Email address of the
                              user.
                            "graphId": "str",  # Optional. Identifier of the principal in
                              Microsoft Graph. Only available for admin APIs.
                            "profile": {
                                "id": "str",  # The service principal profile ID.
                                  Required.
                                "displayName": "str"  # Optional. The service
                                  principal profile name.
                            },
                            "userType": "str"  # Optional. Type of the user.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_groups_get_group_users_as_admin_request(
            group_id=group_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def add_user_as_admin(  # pylint: disable=inconsistent-return-statements
        self, group_id: str, user_details: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Grants user permissions to the specified workspace.

        This API call only supports adding a user principle.

        Permissions
        -----------

        The user must have administrator rights (such as Office 365 Global Administrator or Power BI
        Service Administrator).

        Required Scope
        --------------

        Tenant.ReadWrite.All

        Limitations
        -----------

        Maximum 200 requests per hour.
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param user_details: Details of user access right. Required.
        :type user_details: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                user_details = {
                    "groupUserAccessRight": "str",  # The access right (permission level) that a
                      user has on the workspace. Required. Known values are: "None", "Member", "Admin",
                      "Contributor", and "Viewer".
                    "identifier": "str",  # Identifier of the principal. Required.
                    "principalType": "str",  # The principal type. Required. Known values are:
                      "None", "User", "Group", and "App".
                    "displayName": "str",  # Optional. Display name of the principal.
                    "emailAddress": "str",  # Optional. Email address of the user.
                    "graphId": "str",  # Optional. Identifier of the principal in Microsoft
                      Graph. Only available for admin APIs.
                    "profile": {
                        "id": "str",  # The service principal profile ID. Required.
                        "displayName": "str"  # Optional. The service principal profile name.
                    },
                    "userType": "str"  # Optional. Type of the user.
                }
        """

    @overload
    async def add_user_as_admin(  # pylint: disable=inconsistent-return-statements
        self, group_id: str, user_details: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Grants user permissions to the specified workspace.

        This API call only supports adding a user principle.

        Permissions
        -----------

        The user must have administrator rights (such as Office 365 Global Administrator or Power BI
        Service Administrator).

        Required Scope
        --------------

        Tenant.ReadWrite.All

        Limitations
        -----------

        Maximum 200 requests per hour.
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param user_details: Details of user access right. Required.
        :type user_details: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def add_user_as_admin(  # pylint: disable=inconsistent-return-statements
        self, group_id: str, user_details: Union[JSON, IO], **kwargs: Any
    ) -> None:
        """Grants user permissions to the specified workspace.

        This API call only supports adding a user principle.

        Permissions
        -----------

        The user must have administrator rights (such as Office 365 Global Administrator or Power BI
        Service Administrator).

        Required Scope
        --------------

        Tenant.ReadWrite.All

        Limitations
        -----------

        Maximum 200 requests per hour.
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param user_details: Details of user access right. Is either a JSON type or a IO type.
         Required.
        :type user_details: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                user_details = {
                    "groupUserAccessRight": "str",  # The access right (permission level) that a
                      user has on the workspace. Required. Known values are: "None", "Member", "Admin",
                      "Contributor", and "Viewer".
                    "identifier": "str",  # Identifier of the principal. Required.
                    "principalType": "str",  # The principal type. Required. Known values are:
                      "None", "User", "Group", and "App".
                    "displayName": "str",  # Optional. Display name of the principal.
                    "emailAddress": "str",  # Optional. Email address of the user.
                    "graphId": "str",  # Optional. Identifier of the principal in Microsoft
                      Graph. Only available for admin APIs.
                    "profile": {
                        "id": "str",  # The service principal profile ID. Required.
                        "displayName": "str"  # Optional. The service principal profile name.
                    },
                    "userType": "str"  # Optional. Type of the user.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(user_details, (IOBase, bytes)):
            _content = user_details
        else:
            _json = user_details

        _request = build_groups_add_user_as_admin_request(
            group_id=group_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def delete_user_as_admin(  # pylint: disable=inconsistent-return-statements
        self, group_id: str, user: str, *, profile_id: Optional[str] = None, **kwargs: Any
    ) -> None:
        """Removes user permissions from the specified workspace.

        This API call only supports adding a user principle.

        Permissions
        -----------

        The user must have administrator rights (such as Office 365 Global Administrator or Power BI
        Service Administrator).

        Required Scope
        --------------

        Tenant.ReadWrite.All

        Limitations
        -----------

        Maximum 200 requests per hour.
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param user: The user principal name (UPN) of the user to remove. Required.
        :type user: str
        :keyword profile_id: The service principal profile ID to delete. Default value is None.
        :paramtype profile_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_groups_delete_user_as_admin_request(
            group_id=group_id,
            user=user,
            profile_id=profile_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def restore_deleted_group_as_admin(  # pylint: disable=inconsistent-return-statements
        self, group_id: str, group_restore_request: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Restores a deleted workspace.

        Use this API call to restore workspaces.

        Permissions
        -----------

        The user must have administrator rights (such as Office 365 Global Administrator or Power BI
        Service Administrator).

        Required Scope
        --------------

        Tenant.ReadWrite.All

        Limitations
        -----------

        Maximum 200 requests per hour.
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param group_restore_request: Details of the group restore request. Required.
        :type group_restore_request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                group_restore_request = {
                    "emailAddress": "str",  # The email address of the owner of the group to be
                      restored. Required.
                    "name": "str"  # Optional. The name of the group to be restored.
                }
        """

    @overload
    async def restore_deleted_group_as_admin(  # pylint: disable=inconsistent-return-statements
        self, group_id: str, group_restore_request: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Restores a deleted workspace.

        Use this API call to restore workspaces.

        Permissions
        -----------

        The user must have administrator rights (such as Office 365 Global Administrator or Power BI
        Service Administrator).

        Required Scope
        --------------

        Tenant.ReadWrite.All

        Limitations
        -----------

        Maximum 200 requests per hour.
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param group_restore_request: Details of the group restore request. Required.
        :type group_restore_request: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def restore_deleted_group_as_admin(  # pylint: disable=inconsistent-return-statements
        self, group_id: str, group_restore_request: Union[JSON, IO], **kwargs: Any
    ) -> None:
        """Restores a deleted workspace.

        Use this API call to restore workspaces.

        Permissions
        -----------

        The user must have administrator rights (such as Office 365 Global Administrator or Power BI
        Service Administrator).

        Required Scope
        --------------

        Tenant.ReadWrite.All

        Limitations
        -----------

        Maximum 200 requests per hour.
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :param group_restore_request: Details of the group restore request. Is either a JSON type or a
         IO type. Required.
        :type group_restore_request: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                group_restore_request = {
                    "emailAddress": "str",  # The email address of the owner of the group to be
                      restored. Required.
                    "name": "str"  # Optional. The name of the group to be restored.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(group_restore_request, (IOBase, bytes)):
            _content = group_restore_request
        else:
            _json = group_restore_request

        _request = build_groups_restore_deleted_group_as_admin_request(
            group_id=group_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get_unused_artifacts_as_admin(
        self, group_id: str, *, continuation_token_parameter: Optional[str] = None, **kwargs: Any
    ) -> JSON:
        """Returns a list of datasets, reports, and dashboards that have not been used within 30 days for
        the specified workspace. This is a preview API call.

        Permissions
        -----------


        * The user must have administrator rights (such as Office 365 Global Administrator or Power BI
        Service Administrator) or authenticate using a service principal.
        * Delegated permissions are supported.

        Required Scope
        --------------

        Tenant.Read.All or Tenant.ReadWrite.All

        Limitations
        -----------

        Maximum 200 requests per hour.
        :code:`<br>`:code:`<br>`.

        :param group_id: The workspace ID. Required.
        :type group_id: str
        :keyword continuation_token_parameter: Token required to get the next chunk of the result set.
         Default value is None.
        :paramtype continuation_token_parameter: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "continuationToken": "str",  # Optional. Token to get the next chunk of the
                      result set.
                    "continuationUri": "str",  # Optional. The URI for the next chunk in the
                      result set.
                    "unusedArtifactEntities": [
                        {
                            "artifactId": "str",  # The ID of the Power BI item.
                              Required.
                            "artifactType": "str",  # The Power BI item type. Required.
                            "displayName": "str",  # The display name of the Power BI
                              item. Required.
                            "artifactSizeInMB": 0,  # Optional. The size of the Power BI
                              item in megabytes (if applicable).
                            "createdDateTime": "2020-02-20 00:00:00",  # Optional. The
                              creation time of the Power BI item (if applicable).
                            "lastAccessedDateTime": "2020-02-20 00:00:00"  # Optional.
                              The last access time of the Power BI item (if applicable).
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_groups_get_unused_artifacts_as_admin_request(
            group_id=group_id,
            continuation_token_parameter=continuation_token_parameter,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore


class CapacitiesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~power_bi_client.aio.PowerBIClient`'s
        :attr:`capacities` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get_capacities(self, **kwargs: Any) -> JSON:
        """Returns a list of capacities that the user has access to.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.
        The profile creator must have capacity permissions.

        Required Scope
        --------------

        Capacity.Read.All or Capacity.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional.
                    "value": [
                        {
                            "capacityUserAccessRight": "str",  # The access right a user
                              has on the capacity. Required. Known values are: "None", "Assign", and
                              "Admin".
                            "id": "str",  # The capacity ID. Required.
                            "state": "str",  # The capacity state. Required. Known values
                              are: "NotActivated", "Active", "Provisioning", "ProvisionFailed",
                              "Suspended", "PreSuspended", "Deleting", "Deleted", "Invalid", and
                              "UpdatingSku".
                            "admins": [
                                "str"  # Optional. An array of capacity admins.
                            ],
                            "displayName": "str",  # Optional. The display name of the
                              capacity.
                            "region": "str",  # Optional. The Azure region where the
                              capacity was provisioned.
                            "sku": "str",  # Optional. The capacity SKU.
                            "tenantKey": {
                                "createdAt": "2020-02-20 00:00:00",  # Optional. The
                                  creation date and time of the encryption key.
                                "id": "str",  # Optional. The ID of the encryption
                                  key.
                                "isDefault": bool,  # Optional. Whether the
                                  encryption key is the default key for the entire tenant. Any newly
                                  created capacity inherits the default key.
                                "keyVaultKeyIdentifier": "str",  # Optional. The URI
                                  that uniquely specifies the encryption key in Azure Key Vault.
                                "name": "str",  # Optional. The name of the
                                  encryption key.
                                "updatedAt": "2020-02-20 00:00:00"  # Optional. The
                                  last update date and time of the encryption key.
                            },
                            "tenantKeyId": "str"  # Optional. The ID of an encryption key
                              (only applicable to the admin route).
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_capacities_get_capacities_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_workloads(self, capacity_id: str, **kwargs: Any) -> JSON:
        """Returns the current state of the specified capacity workloads. If a workload is enabled, the
        percentage of maximum memory that the workload can consume is also returned.

        Workload APIs aren't relevant for `Gen2
        </power-bi/developer/embedded/power-bi-embedded-generation-2>`_ capacities.

        Required Scope
        --------------

        Capacity.Read.All or Capacity.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param capacity_id: The capacity ID. Required.
        :type capacity_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional.
                    "value": [
                        {
                            "state": "str",  # The capacity workload state. Required.
                              Known values are: "Disabled", "Enabled", and "Unsupported".
                            "maxMemoryPercentageSetByUser": 0,  # Optional. The
                              percentage of the maximum memory that a workload can consume (set by the
                              user).
                            "name": "str"  # Optional. The workload name.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_capacities_get_workloads_request(
            capacity_id=capacity_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_workload(self, capacity_id: str, workload_name: str, **kwargs: Any) -> JSON:
        """Returns the current state of a workload. If the workload is enabled, the percentage of maximum
        memory that the workload can consume is also returned.

        Workload APIs aren't relevant for `Gen2
        </power-bi/developer/embedded/power-bi-embedded-generation-2>`_ capacities.

        Required Scope
        --------------

        Capacity.Read.All or Capacity.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param capacity_id: The capacity ID. Required.
        :type capacity_id: str
        :param workload_name: The name of the workload. Required.
        :type workload_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "state": "str",  # The capacity workload state. Required. Known values are:
                      "Disabled", "Enabled", and "Unsupported".
                    "maxMemoryPercentageSetByUser": 0,  # Optional. The percentage of the maximum
                      memory that a workload can consume (set by the user).
                    "name": "str"  # Optional. The workload name.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_capacities_get_workload_request(
            capacity_id=capacity_id,
            workload_name=workload_name,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def patch_workload(  # pylint: disable=inconsistent-return-statements
        self,
        capacity_id: str,
        workload_name: str,
        workload: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Changes the state of a specific workload to *Enabled* or *Disabled*. When enabling a workload,
        specify the percentage of maximum memory that the workload can consume.

        Workload APIs aren't relevant for `Gen2
        </power-bi/developer/embedded/power-bi-embedded-generation-2>`_ capacities.

        Required Scope
        --------------

        Capacity.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param capacity_id: The capacity ID. Required.
        :type capacity_id: str
        :param workload_name: The name of the workload. Required.
        :type workload_name: str
        :param workload: Patch workload parameters. Required.
        :type workload: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                workload = {
                    "state": "str",  # The capacity workload state. Required. Known values are:
                      "Disabled", "Enabled", and "Unsupported".
                    "maxMemoryPercentageSetByUser": 0  # Optional. The percentage of the maximum
                      memory that a workload can consume (set by the user).
                }
        """

    @overload
    async def patch_workload(  # pylint: disable=inconsistent-return-statements
        self,
        capacity_id: str,
        workload_name: str,
        workload: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Changes the state of a specific workload to *Enabled* or *Disabled*. When enabling a workload,
        specify the percentage of maximum memory that the workload can consume.

        Workload APIs aren't relevant for `Gen2
        </power-bi/developer/embedded/power-bi-embedded-generation-2>`_ capacities.

        Required Scope
        --------------

        Capacity.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param capacity_id: The capacity ID. Required.
        :type capacity_id: str
        :param workload_name: The name of the workload. Required.
        :type workload_name: str
        :param workload: Patch workload parameters. Required.
        :type workload: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def patch_workload(  # pylint: disable=inconsistent-return-statements
        self, capacity_id: str, workload_name: str, workload: Union[JSON, IO], **kwargs: Any
    ) -> None:
        """Changes the state of a specific workload to *Enabled* or *Disabled*. When enabling a workload,
        specify the percentage of maximum memory that the workload can consume.

        Workload APIs aren't relevant for `Gen2
        </power-bi/developer/embedded/power-bi-embedded-generation-2>`_ capacities.

        Required Scope
        --------------

        Capacity.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param capacity_id: The capacity ID. Required.
        :type capacity_id: str
        :param workload_name: The name of the workload. Required.
        :type workload_name: str
        :param workload: Patch workload parameters. Is either a JSON type or a IO type. Required.
        :type workload: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                workload = {
                    "state": "str",  # The capacity workload state. Required. Known values are:
                      "Disabled", "Enabled", and "Unsupported".
                    "maxMemoryPercentageSetByUser": 0  # Optional. The percentage of the maximum
                      memory that a workload can consume (set by the user).
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(workload, (IOBase, bytes)):
            _content = workload
        else:
            _json = workload

        _request = build_capacities_patch_workload_request(
            capacity_id=capacity_id,
            workload_name=workload_name,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get_refreshables(
        self,
        *,
        top: int,
        expand: Optional[str] = None,
        filter: Optional[str] = None,
        skip: Optional[int] = None,
        **kwargs: Any
    ) -> JSON:
        """Returns a list of refreshables for all capacities that the user has access to.

        Power BI retains a seven-day refresh history for each dataset, up to a maximum of sixty
        refreshes.

        Required Scope
        --------------

        Capacity.Read.All or Capacity.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :keyword top: Returns only the first n results. Required.
        :paramtype top: int
        :keyword expand: Accepts a comma-separated list of data types, which will be expanded inline in
         the response. Supports ``capacities`` and ``groups``. Default value is None.
        :paramtype expand: str
        :keyword filter: Filters the results based on a boolean condition. Default value is None.
        :paramtype filter: str
        :keyword skip: Skips the first n results. Use with top to fetch results beyond the first 1000.
         Default value is None.
        :paramtype skip: int
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional. OData context.
                    "value": [
                        {
                            "averageDuration": 0.0,  # Optional. The average duration in
                              seconds of a refresh during the time window for which refresh data
                              exists.
                            "capacity": {
                                "capacityUserAccessRight": "str",  # The access right
                                  a user has on the capacity. Required. Known values are: "None",
                                  "Assign", and "Admin".
                                "id": "str",  # The capacity ID. Required.
                                "state": "str",  # The capacity state. Required.
                                  Known values are: "NotActivated", "Active", "Provisioning",
                                  "ProvisionFailed", "Suspended", "PreSuspended", "Deleting",
                                  "Deleted", "Invalid", and "UpdatingSku".
                                "admins": [
                                    "str"  # Optional. An array of capacity
                                      admins.
                                ],
                                "displayName": "str",  # Optional. The display name
                                  of the capacity.
                                "region": "str",  # Optional. The Azure region where
                                  the capacity was provisioned.
                                "sku": "str",  # Optional. The capacity SKU.
                                "tenantKey": {
                                    "createdAt": "2020-02-20 00:00:00",  #
                                      Optional. The creation date and time of the encryption key.
                                    "id": "str",  # Optional. The ID of the
                                      encryption key.
                                    "isDefault": bool,  # Optional. Whether the
                                      encryption key is the default key for the entire tenant. Any
                                      newly created capacity inherits the default key.
                                    "keyVaultKeyIdentifier": "str",  # Optional.
                                      The URI that uniquely specifies the encryption key in Azure Key
                                      Vault.
                                    "name": "str",  # Optional. The name of the
                                      encryption key.
                                    "updatedAt": "2020-02-20 00:00:00"  #
                                      Optional. The last update date and time of the encryption key.
                                },
                                "tenantKeyId": "str"  # Optional. The ID of an
                                  encryption key (only applicable to the admin route).
                            },
                            "configuredBy": [
                                "str"  # Optional. The refreshable owners.
                            ],
                            "endTime": "2020-02-20 00:00:00",  # Optional. The end time
                              of the window for which refresh data exists.
                            "group": {
                                "id": "str",  # The workspace ID. Required.
                                "name": "str"  # Optional. The group name.
                            },
                            "id": "str",  # Optional. The object ID of the refreshable.
                            "kind": "Dataset",  # Optional. Default value is "Dataset".
                              The refreshable kind.
                            "lastRefresh": {
                                "endTime": "2020-02-20 00:00:00",  # Optional. The
                                  end date and time of the refresh (may be empty if a refresh is in
                                  progress).
                                "refreshType": "str",  # Optional. The type of
                                  refresh request. Known values are: "Scheduled", "OnDemand", "ViaApi",
                                  "ViaXmlaEndpoint", "ViaEnhancedApi", and "OnDemandTraining".
                                "requestId": "str",  # Optional. The identifier of
                                  the refresh request. Provide this identifier in all service requests.
                                "serviceExceptionJson": "str",  # Optional. Failure
                                  error code in JSON format (empty if no error).
                                "startTime": "2020-02-20 00:00:00",  # Optional. The
                                  start date and time of the refresh.
                                "status": "str"  # Optional. * ``Unknown`` if the
                                  completion state is unknown or a refresh is in progress. *
                                  ``Completed`` for a successfully completed refresh. * ``Failed`` for
                                  an unsuccessful refresh ("" ``serviceExceptionJson`` will contain the
                                  error code). * ``Disabled`` if the refresh is disabled by a selective
                                  refresh.
                            },
                            "medianDuration": 0.0,  # Optional. The median duration in
                              seconds of a refresh within the time window for which refresh data
                              exists.
                            "name": "str",  # Optional. The display name of the
                              refreshable.
                            "refreshCount": 0,  # Optional. The number of refreshes
                              within the time window for which refresh data exists.
                            "refreshFailures": 0,  # Optional. The number of refresh
                              failures within the time window for which refresh data exists.
                            "refreshSchedule": {
                                "NotifyOption": "str",  # Optional. The notification
                                  option on termination of a scheduled refresh. Service principals only
                                  support the ``NoNotification`` value. Known values are:
                                  "NoNotification" and "MailOnFailure".
                                "days": [
                                    "str"  # Optional. The days on which to
                                      execute the refresh.
                                ],
                                "enabled": bool,  # Optional. Whether the refresh is
                                  enabled.
                                "localTimeZoneId": "str",  # Optional. The ID of the
                                  time zone to use. For more information, see `Time zone info
                                  </dotnet/api/system.timezoneinfo.id>`_.
                                "times": [
                                    "str"  # Optional. The times of day to
                                      execute the refresh.
                                ]
                            },
                            "refreshesPerDay": 0,  # Optional. The number of refreshes
                              per day (scheduled and on-demand) within the time window for which
                              refresh data exists.
                            "startTime": "2020-02-20 00:00:00"  # Optional. The start
                              time of the window for which refresh data exists.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_capacities_get_refreshables_request(
            top=top,
            expand=expand,
            filter=filter,
            skip=skip,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_refreshables_for_capacity(
        self,
        capacity_id: str,
        *,
        top: int,
        expand: Optional[str] = None,
        filter: Optional[str] = None,
        skip: Optional[int] = None,
        **kwargs: Any
    ) -> JSON:
        """Returns a list of refreshables for the specified capacity that the user has access to.

        Power BI retains a seven-day refresh history for each dataset, up to a maximum of sixty
        refreshes.

        Required Scope
        --------------

        Capacity.Read.All or Capacity.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param capacity_id: The capacity ID. Required.
        :type capacity_id: str
        :keyword top: Returns only the first n results. Required.
        :paramtype top: int
        :keyword expand: Accepts a comma-separated list of data types, which will be expanded inline in
         the response. Supports ``capacities`` and ``groups``. Default value is None.
        :paramtype expand: str
        :keyword filter: Filters the results based on a boolean condition. Default value is None.
        :paramtype filter: str
        :keyword skip: Skips the first n results. Use with top to fetch results beyond the first 1000.
         Default value is None.
        :paramtype skip: int
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional. OData context.
                    "value": [
                        {
                            "averageDuration": 0.0,  # Optional. The average duration in
                              seconds of a refresh during the time window for which refresh data
                              exists.
                            "capacity": {
                                "capacityUserAccessRight": "str",  # The access right
                                  a user has on the capacity. Required. Known values are: "None",
                                  "Assign", and "Admin".
                                "id": "str",  # The capacity ID. Required.
                                "state": "str",  # The capacity state. Required.
                                  Known values are: "NotActivated", "Active", "Provisioning",
                                  "ProvisionFailed", "Suspended", "PreSuspended", "Deleting",
                                  "Deleted", "Invalid", and "UpdatingSku".
                                "admins": [
                                    "str"  # Optional. An array of capacity
                                      admins.
                                ],
                                "displayName": "str",  # Optional. The display name
                                  of the capacity.
                                "region": "str",  # Optional. The Azure region where
                                  the capacity was provisioned.
                                "sku": "str",  # Optional. The capacity SKU.
                                "tenantKey": {
                                    "createdAt": "2020-02-20 00:00:00",  #
                                      Optional. The creation date and time of the encryption key.
                                    "id": "str",  # Optional. The ID of the
                                      encryption key.
                                    "isDefault": bool,  # Optional. Whether the
                                      encryption key is the default key for the entire tenant. Any
                                      newly created capacity inherits the default key.
                                    "keyVaultKeyIdentifier": "str",  # Optional.
                                      The URI that uniquely specifies the encryption key in Azure Key
                                      Vault.
                                    "name": "str",  # Optional. The name of the
                                      encryption key.
                                    "updatedAt": "2020-02-20 00:00:00"  #
                                      Optional. The last update date and time of the encryption key.
                                },
                                "tenantKeyId": "str"  # Optional. The ID of an
                                  encryption key (only applicable to the admin route).
                            },
                            "configuredBy": [
                                "str"  # Optional. The refreshable owners.
                            ],
                            "endTime": "2020-02-20 00:00:00",  # Optional. The end time
                              of the window for which refresh data exists.
                            "group": {
                                "id": "str",  # The workspace ID. Required.
                                "name": "str"  # Optional. The group name.
                            },
                            "id": "str",  # Optional. The object ID of the refreshable.
                            "kind": "Dataset",  # Optional. Default value is "Dataset".
                              The refreshable kind.
                            "lastRefresh": {
                                "endTime": "2020-02-20 00:00:00",  # Optional. The
                                  end date and time of the refresh (may be empty if a refresh is in
                                  progress).
                                "refreshType": "str",  # Optional. The type of
                                  refresh request. Known values are: "Scheduled", "OnDemand", "ViaApi",
                                  "ViaXmlaEndpoint", "ViaEnhancedApi", and "OnDemandTraining".
                                "requestId": "str",  # Optional. The identifier of
                                  the refresh request. Provide this identifier in all service requests.
                                "serviceExceptionJson": "str",  # Optional. Failure
                                  error code in JSON format (empty if no error).
                                "startTime": "2020-02-20 00:00:00",  # Optional. The
                                  start date and time of the refresh.
                                "status": "str"  # Optional. * ``Unknown`` if the
                                  completion state is unknown or a refresh is in progress. *
                                  ``Completed`` for a successfully completed refresh. * ``Failed`` for
                                  an unsuccessful refresh ("" ``serviceExceptionJson`` will contain the
                                  error code). * ``Disabled`` if the refresh is disabled by a selective
                                  refresh.
                            },
                            "medianDuration": 0.0,  # Optional. The median duration in
                              seconds of a refresh within the time window for which refresh data
                              exists.
                            "name": "str",  # Optional. The display name of the
                              refreshable.
                            "refreshCount": 0,  # Optional. The number of refreshes
                              within the time window for which refresh data exists.
                            "refreshFailures": 0,  # Optional. The number of refresh
                              failures within the time window for which refresh data exists.
                            "refreshSchedule": {
                                "NotifyOption": "str",  # Optional. The notification
                                  option on termination of a scheduled refresh. Service principals only
                                  support the ``NoNotification`` value. Known values are:
                                  "NoNotification" and "MailOnFailure".
                                "days": [
                                    "str"  # Optional. The days on which to
                                      execute the refresh.
                                ],
                                "enabled": bool,  # Optional. Whether the refresh is
                                  enabled.
                                "localTimeZoneId": "str",  # Optional. The ID of the
                                  time zone to use. For more information, see `Time zone info
                                  </dotnet/api/system.timezoneinfo.id>`_.
                                "times": [
                                    "str"  # Optional. The times of day to
                                      execute the refresh.
                                ]
                            },
                            "refreshesPerDay": 0,  # Optional. The number of refreshes
                              per day (scheduled and on-demand) within the time window for which
                              refresh data exists.
                            "startTime": "2020-02-20 00:00:00"  # Optional. The start
                              time of the window for which refresh data exists.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_capacities_get_refreshables_for_capacity_request(
            capacity_id=capacity_id,
            top=top,
            expand=expand,
            filter=filter,
            skip=skip,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_refreshable_for_capacity(
        self, capacity_id: str, refreshable_id: str, *, expand: Optional[str] = None, **kwargs: Any
    ) -> JSON:
        """Returns the specified refreshable for the specified capacity that the user has access to.

        Power BI retains a seven-day refresh history for each dataset, up to a maximum of sixty
        refreshes.

        Required Scope
        --------------

        Capacity.Read.All or Capacity.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param capacity_id: The capacity ID. Required.
        :type capacity_id: str
        :param refreshable_id: The refreshable ID. Required.
        :type refreshable_id: str
        :keyword expand: Accepts a comma-separated list of data types, which will be expanded inline in
         the response. Supports ``capacities`` and ``groups``. Default value is None.
        :paramtype expand: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional. OData context.
                    "value": [
                        {
                            "averageDuration": 0.0,  # Optional. The average duration in
                              seconds of a refresh during the time window for which refresh data
                              exists.
                            "capacity": {
                                "capacityUserAccessRight": "str",  # The access right
                                  a user has on the capacity. Required. Known values are: "None",
                                  "Assign", and "Admin".
                                "id": "str",  # The capacity ID. Required.
                                "state": "str",  # The capacity state. Required.
                                  Known values are: "NotActivated", "Active", "Provisioning",
                                  "ProvisionFailed", "Suspended", "PreSuspended", "Deleting",
                                  "Deleted", "Invalid", and "UpdatingSku".
                                "admins": [
                                    "str"  # Optional. An array of capacity
                                      admins.
                                ],
                                "displayName": "str",  # Optional. The display name
                                  of the capacity.
                                "region": "str",  # Optional. The Azure region where
                                  the capacity was provisioned.
                                "sku": "str",  # Optional. The capacity SKU.
                                "tenantKey": {
                                    "createdAt": "2020-02-20 00:00:00",  #
                                      Optional. The creation date and time of the encryption key.
                                    "id": "str",  # Optional. The ID of the
                                      encryption key.
                                    "isDefault": bool,  # Optional. Whether the
                                      encryption key is the default key for the entire tenant. Any
                                      newly created capacity inherits the default key.
                                    "keyVaultKeyIdentifier": "str",  # Optional.
                                      The URI that uniquely specifies the encryption key in Azure Key
                                      Vault.
                                    "name": "str",  # Optional. The name of the
                                      encryption key.
                                    "updatedAt": "2020-02-20 00:00:00"  #
                                      Optional. The last update date and time of the encryption key.
                                },
                                "tenantKeyId": "str"  # Optional. The ID of an
                                  encryption key (only applicable to the admin route).
                            },
                            "configuredBy": [
                                "str"  # Optional. The refreshable owners.
                            ],
                            "endTime": "2020-02-20 00:00:00",  # Optional. The end time
                              of the window for which refresh data exists.
                            "group": {
                                "id": "str",  # The workspace ID. Required.
                                "name": "str"  # Optional. The group name.
                            },
                            "id": "str",  # Optional. The object ID of the refreshable.
                            "kind": "Dataset",  # Optional. Default value is "Dataset".
                              The refreshable kind.
                            "lastRefresh": {
                                "endTime": "2020-02-20 00:00:00",  # Optional. The
                                  end date and time of the refresh (may be empty if a refresh is in
                                  progress).
                                "refreshType": "str",  # Optional. The type of
                                  refresh request. Known values are: "Scheduled", "OnDemand", "ViaApi",
                                  "ViaXmlaEndpoint", "ViaEnhancedApi", and "OnDemandTraining".
                                "requestId": "str",  # Optional. The identifier of
                                  the refresh request. Provide this identifier in all service requests.
                                "serviceExceptionJson": "str",  # Optional. Failure
                                  error code in JSON format (empty if no error).
                                "startTime": "2020-02-20 00:00:00",  # Optional. The
                                  start date and time of the refresh.
                                "status": "str"  # Optional. * ``Unknown`` if the
                                  completion state is unknown or a refresh is in progress. *
                                  ``Completed`` for a successfully completed refresh. * ``Failed`` for
                                  an unsuccessful refresh ("" ``serviceExceptionJson`` will contain the
                                  error code). * ``Disabled`` if the refresh is disabled by a selective
                                  refresh.
                            },
                            "medianDuration": 0.0,  # Optional. The median duration in
                              seconds of a refresh within the time window for which refresh data
                              exists.
                            "name": "str",  # Optional. The display name of the
                              refreshable.
                            "refreshCount": 0,  # Optional. The number of refreshes
                              within the time window for which refresh data exists.
                            "refreshFailures": 0,  # Optional. The number of refresh
                              failures within the time window for which refresh data exists.
                            "refreshSchedule": {
                                "NotifyOption": "str",  # Optional. The notification
                                  option on termination of a scheduled refresh. Service principals only
                                  support the ``NoNotification`` value. Known values are:
                                  "NoNotification" and "MailOnFailure".
                                "days": [
                                    "str"  # Optional. The days on which to
                                      execute the refresh.
                                ],
                                "enabled": bool,  # Optional. Whether the refresh is
                                  enabled.
                                "localTimeZoneId": "str",  # Optional. The ID of the
                                  time zone to use. For more information, see `Time zone info
                                  </dotnet/api/system.timezoneinfo.id>`_.
                                "times": [
                                    "str"  # Optional. The times of day to
                                      execute the refresh.
                                ]
                            },
                            "refreshesPerDay": 0,  # Optional. The number of refreshes
                              per day (scheduled and on-demand) within the time window for which
                              refresh data exists.
                            "startTime": "2020-02-20 00:00:00"  # Optional. The start
                              time of the window for which refresh data exists.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_capacities_get_refreshable_for_capacity_request(
            capacity_id=capacity_id,
            refreshable_id=refreshable_id,
            expand=expand,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def assign_workspaces_to_capacity(  # pylint: disable=inconsistent-return-statements
        self, request_parameters: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Assigns the specified workspaces to the specified Premium capacity.

        Permissions
        -----------

        The user must have administrator rights (such as Office 365 Global Administrator or Power BI
        Service Administrator).

        Required Scope
        --------------

        Tenant.Read.All or Tenant.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param request_parameters: Admin assign workspaces capacity parameters. Required.
        :type request_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                request_parameters = {
                    "capacityMigrationAssignments": [
                        {
                            "targetCapacityObjectId": "str",  # The premium capacity ID.
                              Required.
                            "workspacesToAssign": [
                                "str"  # The workspace IDs to migrate to a premium
                                  capacity. Required.
                            ]
                        }
                    ]
                }
        """

    @overload
    async def assign_workspaces_to_capacity(  # pylint: disable=inconsistent-return-statements
        self, request_parameters: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Assigns the specified workspaces to the specified Premium capacity.

        Permissions
        -----------

        The user must have administrator rights (such as Office 365 Global Administrator or Power BI
        Service Administrator).

        Required Scope
        --------------

        Tenant.Read.All or Tenant.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param request_parameters: Admin assign workspaces capacity parameters. Required.
        :type request_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def assign_workspaces_to_capacity(  # pylint: disable=inconsistent-return-statements
        self, request_parameters: Union[JSON, IO], **kwargs: Any
    ) -> None:
        """Assigns the specified workspaces to the specified Premium capacity.

        Permissions
        -----------

        The user must have administrator rights (such as Office 365 Global Administrator or Power BI
        Service Administrator).

        Required Scope
        --------------

        Tenant.Read.All or Tenant.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param request_parameters: Admin assign workspaces capacity parameters. Is either a JSON type
         or a IO type. Required.
        :type request_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                request_parameters = {
                    "capacityMigrationAssignments": [
                        {
                            "targetCapacityObjectId": "str",  # The premium capacity ID.
                              Required.
                            "workspacesToAssign": [
                                "str"  # The workspace IDs to migrate to a premium
                                  capacity. Required.
                            ]
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(request_parameters, (IOBase, bytes)):
            _content = request_parameters
        else:
            _json = request_parameters

        _request = build_capacities_assign_workspaces_to_capacity_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def unassign_workspaces_from_capacity(  # pylint: disable=inconsistent-return-statements
        self, request_parameters: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Unassigns the specified workspaces from capacity.

        Permissions
        -----------

        The user must have administrator rights (such as Office 365 Global Administrator or Power BI
        Service Administrator).

        Required Scope
        --------------

        Tenant.Read.All or Tenant.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param request_parameters: Admin assign workspaces to shared capacity parameters. Required.
        :type request_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                request_parameters = {
                    "workspacesToUnassign": [
                        "str"  # The workspaces to migrate to a shared capacity. Required.
                    ]
                }
        """

    @overload
    async def unassign_workspaces_from_capacity(  # pylint: disable=inconsistent-return-statements
        self, request_parameters: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Unassigns the specified workspaces from capacity.

        Permissions
        -----------

        The user must have administrator rights (such as Office 365 Global Administrator or Power BI
        Service Administrator).

        Required Scope
        --------------

        Tenant.Read.All or Tenant.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param request_parameters: Admin assign workspaces to shared capacity parameters. Required.
        :type request_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def unassign_workspaces_from_capacity(  # pylint: disable=inconsistent-return-statements
        self, request_parameters: Union[JSON, IO], **kwargs: Any
    ) -> None:
        """Unassigns the specified workspaces from capacity.

        Permissions
        -----------

        The user must have administrator rights (such as Office 365 Global Administrator or Power BI
        Service Administrator).

        Required Scope
        --------------

        Tenant.Read.All or Tenant.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param request_parameters: Admin assign workspaces to shared capacity parameters. Is either a
         JSON type or a IO type. Required.
        :type request_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                request_parameters = {
                    "workspacesToUnassign": [
                        "str"  # The workspaces to migrate to a shared capacity. Required.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(request_parameters, (IOBase, bytes)):
            _content = request_parameters
        else:
            _json = request_parameters

        _request = build_capacities_unassign_workspaces_from_capacity_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get_capacity_users_as_admin(self, capacity_id: str, **kwargs: Any) -> JSON:
        """Returns a list of users that have access to the specified workspace.

        Permissions
        -----------


        * The user must have administrator rights (such as Office 365 Global Administrator or Power BI
        Service Administrator).
        * Delegated permissions are supported.

        When running under service prinicipal authentication, an app **must not** have any
        admin-consent required premissions for Power BI set on it in the Azure portal.

        Required Scope
        --------------

        Tenant.Read.All or Tenant.ReadWrite.All

        Relevant only when authenticating via a standard delegated admin access token. Must not be
        present when authentication via a service principal is used.
        :code:`<br>`:code:`<br>`.

        :param capacity_id: The capacity ID. Required.
        :type capacity_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional.
                    "value": [
                        {
                            "capacityUserAccessRight": "str",  # The access right that
                              the user has on the capacity. Required. Known values are: "None",
                              "Assign", and "Admin".
                            "identifier": "str",  # Identifier of the principal.
                              Required.
                            "principalType": "str",  # The principal type. Required.
                              Known values are: "None", "User", "Group", and "App".
                            "displayName": "str",  # Optional. Display name of the
                              principal.
                            "emailAddress": "str",  # Optional. Email address of the
                              user.
                            "graphId": "str",  # Optional. Identifier of the principal in
                              Microsoft Graph. Only available for admin APIs.
                            "profile": {
                                "id": "str",  # The service principal profile ID.
                                  Required.
                                "displayName": "str"  # Optional. The service
                                  principal profile name.
                            },
                            "userType": "str"  # Optional. Type of the user.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_capacities_get_capacity_users_as_admin_request(
            capacity_id=capacity_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore


class AvailableFeaturesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~power_bi_client.aio.PowerBIClient`'s
        :attr:`available_features` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get_available_features(self, **kwargs: Any) -> JSON:
        """Returns a list of available features for the user.

        This API call doesn't require any scopes.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.
        :code:`<br>`:code:`<br>`.

        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "features": [
                        {
                            "extendedState": "str",  # The feature extended state.
                              Required. Known values are: "Enabled", "DisabledByAdmin", and
                              "UserNotLicensed".
                            "name": "str",  # The feature name. Required.
                            "state": "str",  # The feature state. Required. Known values
                              are: "Enabled" and "Disabled".
                            "additionalInfo": {
                                "Usage": 0  # Optional. Workspaces that aren't
                                  assigned to a capacity get a limited amount of `embed tokens
                                  </power-bi/developer/embedded/embed-tokens#embed-token>`_"" , to
                                  allow experimenting with the APIs. The ``Usage`` value represents the
                                  percentage of embed tokens that have been consumed. The ``Usage``
                                  value only applies to the **embed trial** feature. For more
                                  information, see `Development testing
                                  </power-bi/developer/embedded/move-to-production#development-testing>`_.
                            }
                        }
                    ],
                    "odata.context": "str"  # Optional.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_available_features_get_available_features_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_available_feature_by_name(self, feature_name: str, **kwargs: Any) -> JSON:
        """Returns the specified available feature for the user by name.

        This API call doesn't require any scopes.

        Permissions
        -----------

        This API call can be called by a service principal profile. For more information see: `Service
        principal profiles in Power BI Embedded </power-bi/developer/embedded/embed-multi-tenancy>`_.
        :code:`<br>`:code:`<br>`.

        :param feature_name: The feature name. Required.
        :type feature_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedState": "str",  # The feature extended state. Required. Known values
                      are: "Enabled", "DisabledByAdmin", and "UserNotLicensed".
                    "name": "str",  # The feature name. Required.
                    "state": "str",  # The feature state. Required. Known values are: "Enabled"
                      and "Disabled".
                    "additionalInfo": {
                        "Usage": 0  # Optional. Workspaces that aren't assigned to a capacity
                          get a limited amount of `embed tokens
                          </power-bi/developer/embedded/embed-tokens#embed-token>`_"" , to allow
                          experimenting with the APIs. The ``Usage`` value represents the percentage of
                          embed tokens that have been consumed. The ``Usage`` value only applies to the
                          **embed trial** feature. For more information, see `Development testing
                          </power-bi/developer/embedded/move-to-production#development-testing>`_.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_available_features_get_available_feature_by_name_request(
            feature_name=feature_name,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore


class PipelinesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~power_bi_client.aio.PowerBIClient`'s
        :attr:`pipelines` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get_pipelines(self, **kwargs: Any) -> JSON:
        """Returns a list of deployment pipelines that the user has access to.

        Required Scope
        --------------

        Pipeline.Read.All or Pipeline.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional. OData context.
                    "value": [
                        {
                            "id": "str",  # The deployment pipeline ID. Required.
                            "description": "str",  # Optional. The deployment pipeline
                              description.
                            "displayName": "str",  # Optional. The deployment pipeline
                              display name.
                            "stages": [
                                {
                                    "order": 0,  # The stage order, starting from
                                      zero. Required.
                                    "workspaceId": "str",  # Optional. The
                                      assigned workspace ID. Only applicable when there's an assigned
                                      workspace.
                                    "workspaceName": "str"  # Optional. The
                                      assigned workspace name. Only applicable when there's an assigned
                                      workspace and the user has access to the workspace.
                                }
                            ]
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_pipelines_get_pipelines_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def create_pipeline(
        self, create_pipeline_request: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Creates a new deployment pipeline.

        Required Scope
        --------------

        Pipeline.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param create_pipeline_request: The create pipeline request. Required.
        :type create_pipeline_request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                create_pipeline_request = {
                    "displayName": "str",  # The display name for the new deployment pipeline.
                      Required.
                    "description": "str"  # Optional. The description for the new deployment
                      pipeline.
                }

                # response body for status code(s): 201
                response == {
                    "id": "str",  # The deployment pipeline ID. Required.
                    "description": "str",  # Optional. The deployment pipeline description.
                    "displayName": "str",  # Optional. The deployment pipeline display name.
                    "stages": [
                        {
                            "order": 0,  # The stage order, starting from zero. Required.
                            "workspaceId": "str",  # Optional. The assigned workspace ID.
                              Only applicable when there's an assigned workspace.
                            "workspaceName": "str"  # Optional. The assigned workspace
                              name. Only applicable when there's an assigned workspace and the user has
                              access to the workspace.
                        }
                    ]
                }
        """

    @overload
    async def create_pipeline(
        self, create_pipeline_request: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Creates a new deployment pipeline.

        Required Scope
        --------------

        Pipeline.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param create_pipeline_request: The create pipeline request. Required.
        :type create_pipeline_request: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "id": "str",  # The deployment pipeline ID. Required.
                    "description": "str",  # Optional. The deployment pipeline description.
                    "displayName": "str",  # Optional. The deployment pipeline display name.
                    "stages": [
                        {
                            "order": 0,  # The stage order, starting from zero. Required.
                            "workspaceId": "str",  # Optional. The assigned workspace ID.
                              Only applicable when there's an assigned workspace.
                            "workspaceName": "str"  # Optional. The assigned workspace
                              name. Only applicable when there's an assigned workspace and the user has
                              access to the workspace.
                        }
                    ]
                }
        """

    @distributed_trace_async
    async def create_pipeline(self, create_pipeline_request: Union[JSON, IO], **kwargs: Any) -> JSON:
        """Creates a new deployment pipeline.

        Required Scope
        --------------

        Pipeline.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param create_pipeline_request: The create pipeline request. Is either a JSON type or a IO
         type. Required.
        :type create_pipeline_request: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                create_pipeline_request = {
                    "displayName": "str",  # The display name for the new deployment pipeline.
                      Required.
                    "description": "str"  # Optional. The description for the new deployment
                      pipeline.
                }

                # response body for status code(s): 201
                response == {
                    "id": "str",  # The deployment pipeline ID. Required.
                    "description": "str",  # Optional. The deployment pipeline description.
                    "displayName": "str",  # Optional. The deployment pipeline display name.
                    "stages": [
                        {
                            "order": 0,  # The stage order, starting from zero. Required.
                            "workspaceId": "str",  # Optional. The assigned workspace ID.
                              Only applicable when there's an assigned workspace.
                            "workspaceName": "str"  # Optional. The assigned workspace
                              name. Only applicable when there's an assigned workspace and the user has
                              access to the workspace.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(create_pipeline_request, (IOBase, bytes)):
            _content = create_pipeline_request
        else:
            _json = create_pipeline_request

        _request = build_pipelines_create_pipeline_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_pipeline(self, pipeline_id: str, *, expand: str = "stages", **kwargs: Any) -> JSON:
        """Returns the specified deployment pipeline.

        Required Scope
        --------------

        Pipeline.ReadWrite.All or Pipeline.Read.All
        :code:`<br>`:code:`<br>`.

        :param pipeline_id: The deployment pipeline ID. Required.
        :type pipeline_id: str
        :keyword expand: Accepts a comma-separated list of data types, which will be expanded inline in
         the response. Supports ``stages``. Default value is "stages".
        :paramtype expand: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # The deployment pipeline ID. Required.
                    "description": "str",  # Optional. The deployment pipeline description.
                    "displayName": "str",  # Optional. The deployment pipeline display name.
                    "stages": [
                        {
                            "order": 0,  # The stage order, starting from zero. Required.
                            "workspaceId": "str",  # Optional. The assigned workspace ID.
                              Only applicable when there's an assigned workspace.
                            "workspaceName": "str"  # Optional. The assigned workspace
                              name. Only applicable when there's an assigned workspace and the user has
                              access to the workspace.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_pipelines_get_pipeline_request(
            pipeline_id=pipeline_id,
            expand=expand,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def update_pipeline(
        self, pipeline_id: str, update_pipeline_request: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Updates the specified deployment pipeline.

        Required Scope
        --------------

        Pipeline.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param pipeline_id: The deployment pipeline ID. Required.
        :type pipeline_id: str
        :param update_pipeline_request: The update pipeline request. Required.
        :type update_pipeline_request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                update_pipeline_request = {
                    "description": "str",  # Optional. The updated description for the deployment
                      pipeline.
                    "displayName": "str"  # Optional. The updated display name for the deployment
                      pipeline.
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # The deployment pipeline ID. Required.
                    "description": "str",  # Optional. The deployment pipeline description.
                    "displayName": "str",  # Optional. The deployment pipeline display name.
                    "stages": [
                        {
                            "order": 0,  # The stage order, starting from zero. Required.
                            "workspaceId": "str",  # Optional. The assigned workspace ID.
                              Only applicable when there's an assigned workspace.
                            "workspaceName": "str"  # Optional. The assigned workspace
                              name. Only applicable when there's an assigned workspace and the user has
                              access to the workspace.
                        }
                    ]
                }
        """

    @overload
    async def update_pipeline(
        self, pipeline_id: str, update_pipeline_request: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Updates the specified deployment pipeline.

        Required Scope
        --------------

        Pipeline.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param pipeline_id: The deployment pipeline ID. Required.
        :type pipeline_id: str
        :param update_pipeline_request: The update pipeline request. Required.
        :type update_pipeline_request: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # The deployment pipeline ID. Required.
                    "description": "str",  # Optional. The deployment pipeline description.
                    "displayName": "str",  # Optional. The deployment pipeline display name.
                    "stages": [
                        {
                            "order": 0,  # The stage order, starting from zero. Required.
                            "workspaceId": "str",  # Optional. The assigned workspace ID.
                              Only applicable when there's an assigned workspace.
                            "workspaceName": "str"  # Optional. The assigned workspace
                              name. Only applicable when there's an assigned workspace and the user has
                              access to the workspace.
                        }
                    ]
                }
        """

    @distributed_trace_async
    async def update_pipeline(self, pipeline_id: str, update_pipeline_request: Union[JSON, IO], **kwargs: Any) -> JSON:
        """Updates the specified deployment pipeline.

        Required Scope
        --------------

        Pipeline.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param pipeline_id: The deployment pipeline ID. Required.
        :type pipeline_id: str
        :param update_pipeline_request: The update pipeline request. Is either a JSON type or a IO
         type. Required.
        :type update_pipeline_request: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                update_pipeline_request = {
                    "description": "str",  # Optional. The updated description for the deployment
                      pipeline.
                    "displayName": "str"  # Optional. The updated display name for the deployment
                      pipeline.
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # The deployment pipeline ID. Required.
                    "description": "str",  # Optional. The deployment pipeline description.
                    "displayName": "str",  # Optional. The deployment pipeline display name.
                    "stages": [
                        {
                            "order": 0,  # The stage order, starting from zero. Required.
                            "workspaceId": "str",  # Optional. The assigned workspace ID.
                              Only applicable when there's an assigned workspace.
                            "workspaceName": "str"  # Optional. The assigned workspace
                              name. Only applicable when there's an assigned workspace and the user has
                              access to the workspace.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(update_pipeline_request, (IOBase, bytes)):
            _content = update_pipeline_request
        else:
            _json = update_pipeline_request

        _request = build_pipelines_update_pipeline_request(
            pipeline_id=pipeline_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def delete_pipeline(  # pylint: disable=inconsistent-return-statements
        self, pipeline_id: str, **kwargs: Any
    ) -> None:
        """Deletes the specified deployment pipeline.

        Required Scope
        --------------

        Pipeline.ReadWrite.All

        Limitations
        -----------

        This operation will fail if there's an active deployment operation.
        :code:`<br>`:code:`<br>`.

        :param pipeline_id: The deployment pipeline ID. Required.
        :type pipeline_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_pipelines_delete_pipeline_request(
            pipeline_id=pipeline_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get_pipeline_users(self, pipeline_id: str, **kwargs: Any) -> JSON:
        """Returns a list of users that have access to the specified deployment pipeline.

        Required Scope
        --------------

        Pipeline.ReadWrite.All or Pipeline.Read.All
        :code:`<br>`:code:`<br>`.

        :param pipeline_id: The deployment pipeline ID. Required.
        :type pipeline_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional. OData context.
                    "value": [
                        {
                            "identifier": "str",  # For principal type ``User``"" ,
                              provide the *UPN*. Otherwise provide the `object ID
                              </power-bi/developer/embedded/embedded-troubleshoot#what-is-the-difference-between-application-object-id-and-principal-object-id>`_
                              of the principal. Required.
                            "principalType": "str",  # The principal type. Required.
                              Known values are: "None", "User", "Group", and "App".
                            "accessRight": "Admin"  # Optional. Default value is "Admin".
                              Required. The access right a user has for the deployment pipeline.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_pipelines_get_pipeline_users_request(
            pipeline_id=pipeline_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def update_pipeline_user(  # pylint: disable=inconsistent-return-statements
        self, pipeline_id: str, user_details: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Grants user permissions to the specified deployment pipeline.

        Required Scope
        --------------

        Pipeline.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param pipeline_id: The deployment pipeline ID. Required.
        :type pipeline_id: str
        :param user_details: Details of user access right. Required.
        :type user_details: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                user_details = {
                    "identifier": "str",  # For principal type ``User``"" , provide the *UPN*.
                      Otherwise provide the `object ID
                      </power-bi/developer/embedded/embedded-troubleshoot#what-is-the-difference-between-application-object-id-and-principal-object-id>`_
                      of the principal. Required.
                    "principalType": "str",  # The principal type. Required. Known values are:
                      "None", "User", "Group", and "App".
                    "accessRight": "Admin"  # Optional. Default value is "Admin". Required. The
                      access right a user has for the deployment pipeline.
                }
        """

    @overload
    async def update_pipeline_user(  # pylint: disable=inconsistent-return-statements
        self, pipeline_id: str, user_details: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Grants user permissions to the specified deployment pipeline.

        Required Scope
        --------------

        Pipeline.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param pipeline_id: The deployment pipeline ID. Required.
        :type pipeline_id: str
        :param user_details: Details of user access right. Required.
        :type user_details: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_pipeline_user(  # pylint: disable=inconsistent-return-statements
        self, pipeline_id: str, user_details: Union[JSON, IO], **kwargs: Any
    ) -> None:
        """Grants user permissions to the specified deployment pipeline.

        Required Scope
        --------------

        Pipeline.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param pipeline_id: The deployment pipeline ID. Required.
        :type pipeline_id: str
        :param user_details: Details of user access right. Is either a JSON type or a IO type.
         Required.
        :type user_details: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                user_details = {
                    "identifier": "str",  # For principal type ``User``"" , provide the *UPN*.
                      Otherwise provide the `object ID
                      </power-bi/developer/embedded/embedded-troubleshoot#what-is-the-difference-between-application-object-id-and-principal-object-id>`_
                      of the principal. Required.
                    "principalType": "str",  # The principal type. Required. Known values are:
                      "None", "User", "Group", and "App".
                    "accessRight": "Admin"  # Optional. Default value is "Admin". Required. The
                      access right a user has for the deployment pipeline.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(user_details, (IOBase, bytes)):
            _content = user_details
        else:
            _json = user_details

        _request = build_pipelines_update_pipeline_user_request(
            pipeline_id=pipeline_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def delete_pipeline_user(  # pylint: disable=inconsistent-return-statements
        self, pipeline_id: str, identifier: str, **kwargs: Any
    ) -> None:
        """Removes user permissions from the specified deployment pipeline.

        Required Scope
        --------------

        Pipeline.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param pipeline_id: The deployment pipeline ID. Required.
        :type pipeline_id: str
        :param identifier: To delete user pipeline permissions, provide the user principal name (UPN)
         of the user. To delete a service principal or a security group's pipeline permissions, provide
         the Object ID of the service principal or security group. Required.
        :type identifier: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_pipelines_delete_pipeline_user_request(
            pipeline_id=pipeline_id,
            identifier=identifier,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get_pipeline_stages(self, pipeline_id: str, **kwargs: Any) -> JSON:
        """Returns the stages of the specified deployment pipeline.

        Required Scope
        --------------

        Pipeline.ReadWrite.All or Pipeline.Read.All
        :code:`<br>`:code:`<br>`.

        :param pipeline_id: The deployment pipeline ID. Required.
        :type pipeline_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional. OData context.
                    "value": [
                        {
                            "order": 0,  # The stage order, starting from zero. Required.
                            "workspaceId": "str",  # Optional. The assigned workspace ID.
                              Only applicable when there's an assigned workspace.
                            "workspaceName": "str"  # Optional. The assigned workspace
                              name. Only applicable when there's an assigned workspace and the user has
                              access to the workspace.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_pipelines_get_pipeline_stages_request(
            pipeline_id=pipeline_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def assign_workspace(  # pylint: disable=inconsistent-return-statements
        self,
        pipeline_id: str,
        stage_order: int,
        assign_workspace_request: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Assigns the specified workspace to the specified deployment pipeline stage.

        Required Scope
        --------------

        Pipeline.ReadWrite.All and Workspace.ReadWrite.All

        Limitations
        -----------


        * The specified deployment pipeline stage isn't already assigned.
        * You must be an admin of the specified workspace.
        * The specified workspace isn't assigned to any other deployment pipeline.
        * This operation will fail if there's an active deployment operation.
          :code:`<br>`:code:`<br>`.

        :param pipeline_id: The deployment pipeline ID. Required.
        :type pipeline_id: str
        :param stage_order: The deployment pipeline stage order. Development (0), Test (1), Production
         (2). Required.
        :type stage_order: int
        :param assign_workspace_request: The assign workspace request. Required.
        :type assign_workspace_request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                assign_workspace_request = {
                    "workspaceId": "str"  # The workspace ID. Required.
                }
        """

    @overload
    async def assign_workspace(  # pylint: disable=inconsistent-return-statements
        self,
        pipeline_id: str,
        stage_order: int,
        assign_workspace_request: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Assigns the specified workspace to the specified deployment pipeline stage.

        Required Scope
        --------------

        Pipeline.ReadWrite.All and Workspace.ReadWrite.All

        Limitations
        -----------


        * The specified deployment pipeline stage isn't already assigned.
        * You must be an admin of the specified workspace.
        * The specified workspace isn't assigned to any other deployment pipeline.
        * This operation will fail if there's an active deployment operation.
          :code:`<br>`:code:`<br>`.

        :param pipeline_id: The deployment pipeline ID. Required.
        :type pipeline_id: str
        :param stage_order: The deployment pipeline stage order. Development (0), Test (1), Production
         (2). Required.
        :type stage_order: int
        :param assign_workspace_request: The assign workspace request. Required.
        :type assign_workspace_request: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def assign_workspace(  # pylint: disable=inconsistent-return-statements
        self, pipeline_id: str, stage_order: int, assign_workspace_request: Union[JSON, IO], **kwargs: Any
    ) -> None:
        """Assigns the specified workspace to the specified deployment pipeline stage.

        Required Scope
        --------------

        Pipeline.ReadWrite.All and Workspace.ReadWrite.All

        Limitations
        -----------


        * The specified deployment pipeline stage isn't already assigned.
        * You must be an admin of the specified workspace.
        * The specified workspace isn't assigned to any other deployment pipeline.
        * This operation will fail if there's an active deployment operation.
          :code:`<br>`:code:`<br>`.

        :param pipeline_id: The deployment pipeline ID. Required.
        :type pipeline_id: str
        :param stage_order: The deployment pipeline stage order. Development (0), Test (1), Production
         (2). Required.
        :type stage_order: int
        :param assign_workspace_request: The assign workspace request. Is either a JSON type or a IO
         type. Required.
        :type assign_workspace_request: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                assign_workspace_request = {
                    "workspaceId": "str"  # The workspace ID. Required.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(assign_workspace_request, (IOBase, bytes)):
            _content = assign_workspace_request
        else:
            _json = assign_workspace_request

        _request = build_pipelines_assign_workspace_request(
            pipeline_id=pipeline_id,
            stage_order=stage_order,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def unassign_workspace(  # pylint: disable=inconsistent-return-statements
        self, pipeline_id: str, stage_order: int, **kwargs: Any
    ) -> None:
        """Unassigns the workspace from the specified stage in the specified deployment pipeline.

        Required Scope
        --------------

        Pipeline.ReadWrite.All

        Limitations
        -----------

        This operation will fail if there's an active deployment operation.
        :code:`<br>`:code:`<br>`.

        :param pipeline_id: The deployment pipeline ID. Required.
        :type pipeline_id: str
        :param stage_order: The deployment pipeline stage order. Development (0), Test (1), Production
         (2). Required.
        :type stage_order: int
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_pipelines_unassign_workspace_request(
            pipeline_id=pipeline_id,
            stage_order=stage_order,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get_pipeline_stage_artifacts(self, pipeline_id: str, stage_order: int, **kwargs: Any) -> JSON:
        """Returns the supported items from the workspace assigned to the specified stage of the specified
        deployment pipeline.

        To learn about items that aren't supported in deployment pipelines, see `Unsupported items
        </power-bi/create-reports/deployment-pipelines-process#unsupported-items>`_.

        Permissions
        -----------

        The user must at least be a contributor on the workspace assigned to the specified stage. For
        more information, see `Permissions
        </power-bi/create-reports/deployment-pipelines-process#permissions>`_.

        Required Scope
        --------------

        Pipeline.ReadWrite.All or Pipeline.Read.All
        :code:`<br>`:code:`<br>`.

        :param pipeline_id: The deployment pipeline ID. Required.
        :type pipeline_id: str
        :param stage_order: The deployment pipeline stage order. Development (0), Test (1), Production
         (2). Required.
        :type stage_order: int
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "dashboards": [
                        {
                            "artifactId": "str",  # The Power BI item ID. Required.
                            "artifactDisplayName": "str",  # Optional. The Power BI item
                              display name.
                            "lastDeploymentTime": "2020-02-20 00:00:00",  # Optional. The
                              last deployment date and time of the Power BI item.
                            "sourceArtifactId": "str",  # Optional. The ID of the Power
                              BI item (such as a report or a dashboard) from the workspace assigned to
                              the source stage, which will update the current Power BI item upon
                              deployment. Applicable only when the user has at least contributor access
                              to the source stage workspace.
                            "targetArtifactId": "str"  # Optional. The ID of the Power BI
                              item (such as a report or a dashboard) from the workspace of the target
                              stage, which will be updated by the current Power BI item upon
                              deployment. Applicable only when the user has at least contributor access
                              to the target stage workspace.
                        }
                    ],
                    "dataflows": [
                        {
                            "artifactId": "str",  # The Power BI item ID. Required.
                            "artifactDisplayName": "str",  # Optional. The Power BI item
                              display name.
                            "lastDeploymentTime": "2020-02-20 00:00:00",  # Optional. The
                              last deployment date and time of the Power BI item.
                            "sourceArtifactId": "str",  # Optional. The ID of the Power
                              BI item (such as a report or a dashboard) from the workspace assigned to
                              the source stage, which will update the current Power BI item upon
                              deployment. Applicable only when the user has at least contributor access
                              to the source stage workspace.
                            "targetArtifactId": "str"  # Optional. The ID of the Power BI
                              item (such as a report or a dashboard) from the workspace of the target
                              stage, which will be updated by the current Power BI item upon
                              deployment. Applicable only when the user has at least contributor access
                              to the target stage workspace.
                        }
                    ],
                    "datamarts": [
                        {
                            "artifactId": "str",  # The Power BI item ID. Required.
                            "artifactDisplayName": "str",  # Optional. The Power BI item
                              display name.
                            "lastDeploymentTime": "2020-02-20 00:00:00",  # Optional. The
                              last deployment date and time of the Power BI item.
                            "sourceArtifactId": "str",  # Optional. The ID of the Power
                              BI item (such as a report or a dashboard) from the workspace assigned to
                              the source stage, which will update the current Power BI item upon
                              deployment. Applicable only when the user has at least contributor access
                              to the source stage workspace.
                            "targetArtifactId": "str"  # Optional. The ID of the Power BI
                              item (such as a report or a dashboard) from the workspace of the target
                              stage, which will be updated by the current Power BI item upon
                              deployment. Applicable only when the user has at least contributor access
                              to the target stage workspace.
                        }
                    ],
                    "datasets": [
                        {
                            "artifactId": "str",  # The Power BI item ID. Required.
                            "artifactDisplayName": "str",  # Optional. The Power BI item
                              display name.
                            "lastDeploymentTime": "2020-02-20 00:00:00",  # Optional. The
                              last deployment date and time of the Power BI item.
                            "sourceArtifactId": "str",  # Optional. The ID of the Power
                              BI item (such as a report or a dashboard) from the workspace assigned to
                              the source stage, which will update the current Power BI item upon
                              deployment. Applicable only when the user has at least contributor access
                              to the source stage workspace.
                            "targetArtifactId": "str"  # Optional. The ID of the Power BI
                              item (such as a report or a dashboard) from the workspace of the target
                              stage, which will be updated by the current Power BI item upon
                              deployment. Applicable only when the user has at least contributor access
                              to the target stage workspace.
                        }
                    ],
                    "reports": [
                        {
                            "artifactId": "str",  # The Power BI item ID. Required.
                            "artifactDisplayName": "str",  # Optional. The Power BI item
                              display name.
                            "lastDeploymentTime": "2020-02-20 00:00:00",  # Optional. The
                              last deployment date and time of the Power BI item.
                            "sourceArtifactId": "str",  # Optional. The ID of the Power
                              BI item (such as a report or a dashboard) from the workspace assigned to
                              the source stage, which will update the current Power BI item upon
                              deployment. Applicable only when the user has at least contributor access
                              to the source stage workspace.
                            "targetArtifactId": "str"  # Optional. The ID of the Power BI
                              item (such as a report or a dashboard) from the workspace of the target
                              stage, which will be updated by the current Power BI item upon
                              deployment. Applicable only when the user has at least contributor access
                              to the target stage workspace.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_pipelines_get_pipeline_stage_artifacts_request(
            pipeline_id=pipeline_id,
            stage_order=stage_order,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_pipeline_operations(self, pipeline_id: str, **kwargs: Any) -> JSON:
        """Returns a list of the up-to-20 most recent deploy operations performed on the specified
        deployment pipeline.

        Required Scope
        --------------

        Pipeline.ReadWrite.All or Pipeline.Read.All
        :code:`<br>`:code:`<br>`.

        :param pipeline_id: The deployment pipeline ID. Required.
        :type pipeline_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional. OData context.
                    "value": [
                        {
                            "id": "str",  # The operation ID. Required.
                            "lastUpdatedTime": "2020-02-20 00:00:00",  # The date and
                              time that the operation was last updated. Required.
                            "status": "str",  # The pipeline operation status. Required.
                              Known values are: "NotStarted", "Executing", "Succeeded", and "Failed".
                            "executionEndTime": "2020-02-20 00:00:00",  # Optional. The
                              date and time that the operation ended.
                            "executionPlan": {
                                "steps": [
                                    {
                                        "index": 0,  # The step index.
                                          Required.
                                        "status": "str",  # The status of the
                                          pipeline operation. Required. Known values are: "NotStarted",
                                          "Executing", "Succeeded", and "Failed".
                                        "type": "str",  # The type of
                                          deployment step. Required. Known values are:
                                          "DatasetDeployment", "ReportDeployment",
                                          "DashboardDeployment", "DataflowDeployment", and
                                          "DatamartDeployment".
                                        "error": {
                                            "errorCode": "str",  #
                                              Optional. The error code.
                                            "errorDetails": "str"  #
                                              Optional. Additional error details.
                                        },
                                        "preDeploymentDiffState": "str",  #
                                          Optional. Is an item new, different or identical to items in
                                          the target stage before deployment. Known values are: "New",
                                          "Different", and "NoDifference".
                                        "sourceAndTarget": {
                                            "source": "str",  # The ID of
                                              the Power BI item that's deployed from the source stage.
                                              Required.
                                            "sourceDisplayName": "str",
                                              # Optional. The display name of the Power BI item that's
                                              deployed from the source stage.
                                            "target": "str",  # Optional.
                                              The ID of the Power BI item that will be overwritten in
                                              the target stage. Only applies when overwriting a Power
                                              BI item.
                                            "targetDisplayName": "str",
                                              # Optional. The name of the Power BI item that will be
                                              overwritten in the target stage. Only applies when
                                              overwriting a Power BI item.
                                            "type": "str"  # Optional.
                                              The type of the Power BI item that will be overwritten in
                                              the target stage. Only applies when overwriting a Power
                                              BI item.
                                        }
                                    }
                                ]
                            },
                            "executionStartTime": "2020-02-20 00:00:00",  # Optional. The
                              date and time that the operation started.
                            "note": {
                                "content": "str",  # Text describing the deployment.
                                  Required.
                                "isTruncated": bool  # Indicates if the note is
                                  incomplete. True, only part of the note is returned. False, the note
                                  is complete. Required.
                            },
                            "performedBy": {
                                "principalType": "str",  # The type of user who
                                  performed the deployment. Required. Known values are: "None", "User",
                                  "Group", and "App".
                                "principalObjectID": "str",  # Optional. The ID of
                                  the service principal that performed the deployment.
                                "userPrincipalName": "str"  # Optional. The UPN of
                                  the user who performed the deployment.
                            },
                            "preDeploymentDiffInformation": {
                                "differentArtifactsCount": 0,  # The number of
                                  deployed items with differences between source and target stages,
                                  before deployment. Required.
                                "newArtifactsCount": 0,  # The number of new items
                                  deployed to the target stage. Required.
                                "noDifferenceArtifactsCount": 0  # The number of
                                  identical deployed items in the source and target stages, before
                                  deployment. Required.
                            },
                            "sourceStageOrder": 0,  # Optional. The numeric identifier of
                              a source pipeline deployment stage. Development (0), Test (1), Production
                              (2).
                            "targetStageOrder": 0,  # Optional. The numeric identifier of
                              a target pipeline deployment stage. Development (0), Test (1), Production
                              (2).
                            "type": "Deploy"  # Optional. Default value is "Deploy". The
                              operation type.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_pipelines_get_pipeline_operations_request(
            pipeline_id=pipeline_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_pipeline_operation(self, pipeline_id: str, operation_id: str, **kwargs: Any) -> JSON:
        """Returns the details of the specified deploy operation performed on the specified deployment
        pipeline, including the deployment execution plan.

        Use to track the status of a deploy operation.

        Required Scope
        --------------

        Pipeline.ReadWrite.All or Pipeline.Read.All
        :code:`<br>`:code:`<br>`.

        :param pipeline_id: The deployment pipeline ID. Required.
        :type pipeline_id: str
        :param operation_id: The operation ID. Required.
        :type operation_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # The operation ID. Required.
                    "lastUpdatedTime": "2020-02-20 00:00:00",  # The date and time that the
                      operation was last updated. Required.
                    "status": "str",  # The pipeline operation status. Required. Known values
                      are: "NotStarted", "Executing", "Succeeded", and "Failed".
                    "executionEndTime": "2020-02-20 00:00:00",  # Optional. The date and time
                      that the operation ended.
                    "executionPlan": {
                        "steps": [
                            {
                                "index": 0,  # The step index. Required.
                                "status": "str",  # The status of the pipeline
                                  operation. Required. Known values are: "NotStarted", "Executing",
                                  "Succeeded", and "Failed".
                                "type": "str",  # The type of deployment step.
                                  Required. Known values are: "DatasetDeployment", "ReportDeployment",
                                  "DashboardDeployment", "DataflowDeployment", and
                                  "DatamartDeployment".
                                "error": {
                                    "errorCode": "str",  # Optional. The error
                                      code.
                                    "errorDetails": "str"  # Optional. Additional
                                      error details.
                                },
                                "preDeploymentDiffState": "str",  # Optional. Is an
                                  item new, different or identical to items in the target stage before
                                  deployment. Known values are: "New", "Different", and "NoDifference".
                                "sourceAndTarget": {
                                    "source": "str",  # The ID of the Power BI
                                      item that's deployed from the source stage. Required.
                                    "sourceDisplayName": "str",  # Optional. The
                                      display name of the Power BI item that's deployed from the source
                                      stage.
                                    "target": "str",  # Optional. The ID of the
                                      Power BI item that will be overwritten in the target stage. Only
                                      applies when overwriting a Power BI item.
                                    "targetDisplayName": "str",  # Optional. The
                                      name of the Power BI item that will be overwritten in the target
                                      stage. Only applies when overwriting a Power BI item.
                                    "type": "str"  # Optional. The type of the
                                      Power BI item that will be overwritten in the target stage. Only
                                      applies when overwriting a Power BI item.
                                }
                            }
                        ]
                    },
                    "executionStartTime": "2020-02-20 00:00:00",  # Optional. The date and time
                      that the operation started.
                    "note": {
                        "content": "str",  # Text describing the deployment. Required.
                        "isTruncated": bool  # Indicates if the note is incomplete. True,
                          only part of the note is returned. False, the note is complete. Required.
                    },
                    "performedBy": {
                        "principalType": "str",  # The type of user who performed the
                          deployment. Required. Known values are: "None", "User", "Group", and "App".
                        "principalObjectID": "str",  # Optional. The ID of the service
                          principal that performed the deployment.
                        "userPrincipalName": "str"  # Optional. The UPN of the user who
                          performed the deployment.
                    },
                    "preDeploymentDiffInformation": {
                        "differentArtifactsCount": 0,  # The number of deployed items with
                          differences between source and target stages, before deployment. Required.
                        "newArtifactsCount": 0,  # The number of new items deployed to the
                          target stage. Required.
                        "noDifferenceArtifactsCount": 0  # The number of identical deployed
                          items in the source and target stages, before deployment. Required.
                    },
                    "sourceStageOrder": 0,  # Optional. The numeric identifier of a source
                      pipeline deployment stage. Development (0), Test (1), Production (2).
                    "targetStageOrder": 0,  # Optional. The numeric identifier of a target
                      pipeline deployment stage. Development (0), Test (1), Production (2).
                    "type": "Deploy"  # Optional. Default value is "Deploy". The operation type.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_pipelines_get_pipeline_operation_request(
            pipeline_id=pipeline_id,
            operation_id=operation_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def deploy_all(
        self, pipeline_id: str, deploy_request: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Deploys all supported items from the source stage of the specified deployment pipeline.

        To learn about items that aren't supported in deployment pipelines, see `Unsupported items
        </power-bi/create-reports/deployment-pipelines-process#unsupported-items>`_.

        Permissions
        -----------

        The user must at least be a member on both source and target deployment workspaces. For more
        information, see `Permissions
        </power-bi/create-reports/deployment-pipelines-process#permissions>`_.

        Required Scope
        --------------

        Pipeline.Deploy

        Limitations
        -----------

        Maximum 300 deployed items per request.
        :code:`<br>`:code:`<br>`.

        :param pipeline_id: The deployment pipeline ID. Required.
        :type pipeline_id: str
        :param deploy_request: The deploy request. Required.
        :type deploy_request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                deploy_request = {
                    "sourceStageOrder": 0,  # The numeric identifier of the pipeline deployment
                      stage that the content should be deployed from. Development (0), Test (1),
                      Production (2). Required.
                    "isBackwardDeployment": bool,  # Optional. Whether the deployment will be
                      from a later stage in the deployment pipeline, to an earlier one. The default
                      value is ``false``.
                    "newWorkspace": {
                        "capacityId": "str",  # Optional. The ID of the capacity that the new
                          workspace will be assigned to. If unspecified and the API caller has
                          permissions for the source stage workspace capacity, then that capacity will
                          be used. Otherwise, Power BI will select a capacity that the API caller has
                          permissions for.
                        "name": "str"  # Optional. The name of the new workspace.
                    },
                    "note": "str",  # Optional. A note describing the deployment.
                    "options": {
                        "allowCreateArtifact": bool,  # Optional. Whether creating a new
                          Power BI item (such as a report or a dashboard) in the target stage workspace
                          is allowed. If this option isn't set to ``true`` when it's required for
                          deployment, the deployment will fail.
                        "allowOverwriteArtifact": bool,  # Optional. Whether overwriting a
                          Power BI item (such as a report or a dashboard) in the target stage workspace
                          is allowed. If this option isn't set to ``true`` when it's required for
                          deployment, the deployment will fail.
                        "allowOverwriteTargetArtifactLabel": bool,  # Optional. Whether the
                          label of a target Power BI item (such as a report or a dashboard) can be
                          changed. The label gets changed when the source is protected but the target
                          isn't. If this option isn't set to ``true`` when it's required for
                          deployment, the deployment will fail.
                        "allowPurgeData": bool,  # Optional. Whether to delete all data from
                          the target Power BI item (such as a report or a dashboard) when there's a
                          schema mismatch. If this option isn't set to ``true`` when it's required for
                          deployment, the deployment will fail.
                        "allowSkipTilesWithMissingPrerequisites": bool,  # Optional. Whether
                          to skip tiles that don't have a model or a report in the target stage
                          workspace. If this option isn't set to ``true`` when it's required for
                          deployment, the deployment will fail.
                        "allowTakeOver": bool  # Optional. Whether to allow overriding the
                          previous paginated report owner and becoming the owner of the paginated
                          report. Applicable when deploying a paginated report to a stage that already
                          contains a copy of the paginated report that isn't owned by you. If this
                          option isn't set to ``true`` when it's required for deployment, the
                          deployment will fail.
                    },
                    "updateAppSettings": {
                        "updateAppInTargetWorkspace": bool  # Optional. Whether to update the
                          app in the target workspace. Only deployed items that already exist in the
                          app are updated. New deployed items are not added to the app.
                    }
                }

                # response body for status code(s): 202
                response == {
                    "id": "str",  # The operation ID. Required.
                    "lastUpdatedTime": "2020-02-20 00:00:00",  # The date and time that the
                      operation was last updated. Required.
                    "status": "str",  # The pipeline operation status. Required. Known values
                      are: "NotStarted", "Executing", "Succeeded", and "Failed".
                    "executionEndTime": "2020-02-20 00:00:00",  # Optional. The date and time
                      that the operation ended.
                    "executionPlan": {
                        "steps": [
                            {
                                "index": 0,  # The step index. Required.
                                "status": "str",  # The status of the pipeline
                                  operation. Required. Known values are: "NotStarted", "Executing",
                                  "Succeeded", and "Failed".
                                "type": "str",  # The type of deployment step.
                                  Required. Known values are: "DatasetDeployment", "ReportDeployment",
                                  "DashboardDeployment", "DataflowDeployment", and
                                  "DatamartDeployment".
                                "error": {
                                    "errorCode": "str",  # Optional. The error
                                      code.
                                    "errorDetails": "str"  # Optional. Additional
                                      error details.
                                },
                                "preDeploymentDiffState": "str",  # Optional. Is an
                                  item new, different or identical to items in the target stage before
                                  deployment. Known values are: "New", "Different", and "NoDifference".
                                "sourceAndTarget": {
                                    "source": "str",  # The ID of the Power BI
                                      item that's deployed from the source stage. Required.
                                    "sourceDisplayName": "str",  # Optional. The
                                      display name of the Power BI item that's deployed from the source
                                      stage.
                                    "target": "str",  # Optional. The ID of the
                                      Power BI item that will be overwritten in the target stage. Only
                                      applies when overwriting a Power BI item.
                                    "targetDisplayName": "str",  # Optional. The
                                      name of the Power BI item that will be overwritten in the target
                                      stage. Only applies when overwriting a Power BI item.
                                    "type": "str"  # Optional. The type of the
                                      Power BI item that will be overwritten in the target stage. Only
                                      applies when overwriting a Power BI item.
                                }
                            }
                        ]
                    },
                    "executionStartTime": "2020-02-20 00:00:00",  # Optional. The date and time
                      that the operation started.
                    "note": {
                        "content": "str",  # Text describing the deployment. Required.
                        "isTruncated": bool  # Indicates if the note is incomplete. True,
                          only part of the note is returned. False, the note is complete. Required.
                    },
                    "performedBy": {
                        "principalType": "str",  # The type of user who performed the
                          deployment. Required. Known values are: "None", "User", "Group", and "App".
                        "principalObjectID": "str",  # Optional. The ID of the service
                          principal that performed the deployment.
                        "userPrincipalName": "str"  # Optional. The UPN of the user who
                          performed the deployment.
                    },
                    "preDeploymentDiffInformation": {
                        "differentArtifactsCount": 0,  # The number of deployed items with
                          differences between source and target stages, before deployment. Required.
                        "newArtifactsCount": 0,  # The number of new items deployed to the
                          target stage. Required.
                        "noDifferenceArtifactsCount": 0  # The number of identical deployed
                          items in the source and target stages, before deployment. Required.
                    },
                    "sourceStageOrder": 0,  # Optional. The numeric identifier of a source
                      pipeline deployment stage. Development (0), Test (1), Production (2).
                    "targetStageOrder": 0,  # Optional. The numeric identifier of a target
                      pipeline deployment stage. Development (0), Test (1), Production (2).
                    "type": "Deploy"  # Optional. Default value is "Deploy". The operation type.
                }
        """

    @overload
    async def deploy_all(
        self, pipeline_id: str, deploy_request: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Deploys all supported items from the source stage of the specified deployment pipeline.

        To learn about items that aren't supported in deployment pipelines, see `Unsupported items
        </power-bi/create-reports/deployment-pipelines-process#unsupported-items>`_.

        Permissions
        -----------

        The user must at least be a member on both source and target deployment workspaces. For more
        information, see `Permissions
        </power-bi/create-reports/deployment-pipelines-process#permissions>`_.

        Required Scope
        --------------

        Pipeline.Deploy

        Limitations
        -----------

        Maximum 300 deployed items per request.
        :code:`<br>`:code:`<br>`.

        :param pipeline_id: The deployment pipeline ID. Required.
        :type pipeline_id: str
        :param deploy_request: The deploy request. Required.
        :type deploy_request: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 202
                response == {
                    "id": "str",  # The operation ID. Required.
                    "lastUpdatedTime": "2020-02-20 00:00:00",  # The date and time that the
                      operation was last updated. Required.
                    "status": "str",  # The pipeline operation status. Required. Known values
                      are: "NotStarted", "Executing", "Succeeded", and "Failed".
                    "executionEndTime": "2020-02-20 00:00:00",  # Optional. The date and time
                      that the operation ended.
                    "executionPlan": {
                        "steps": [
                            {
                                "index": 0,  # The step index. Required.
                                "status": "str",  # The status of the pipeline
                                  operation. Required. Known values are: "NotStarted", "Executing",
                                  "Succeeded", and "Failed".
                                "type": "str",  # The type of deployment step.
                                  Required. Known values are: "DatasetDeployment", "ReportDeployment",
                                  "DashboardDeployment", "DataflowDeployment", and
                                  "DatamartDeployment".
                                "error": {
                                    "errorCode": "str",  # Optional. The error
                                      code.
                                    "errorDetails": "str"  # Optional. Additional
                                      error details.
                                },
                                "preDeploymentDiffState": "str",  # Optional. Is an
                                  item new, different or identical to items in the target stage before
                                  deployment. Known values are: "New", "Different", and "NoDifference".
                                "sourceAndTarget": {
                                    "source": "str",  # The ID of the Power BI
                                      item that's deployed from the source stage. Required.
                                    "sourceDisplayName": "str",  # Optional. The
                                      display name of the Power BI item that's deployed from the source
                                      stage.
                                    "target": "str",  # Optional. The ID of the
                                      Power BI item that will be overwritten in the target stage. Only
                                      applies when overwriting a Power BI item.
                                    "targetDisplayName": "str",  # Optional. The
                                      name of the Power BI item that will be overwritten in the target
                                      stage. Only applies when overwriting a Power BI item.
                                    "type": "str"  # Optional. The type of the
                                      Power BI item that will be overwritten in the target stage. Only
                                      applies when overwriting a Power BI item.
                                }
                            }
                        ]
                    },
                    "executionStartTime": "2020-02-20 00:00:00",  # Optional. The date and time
                      that the operation started.
                    "note": {
                        "content": "str",  # Text describing the deployment. Required.
                        "isTruncated": bool  # Indicates if the note is incomplete. True,
                          only part of the note is returned. False, the note is complete. Required.
                    },
                    "performedBy": {
                        "principalType": "str",  # The type of user who performed the
                          deployment. Required. Known values are: "None", "User", "Group", and "App".
                        "principalObjectID": "str",  # Optional. The ID of the service
                          principal that performed the deployment.
                        "userPrincipalName": "str"  # Optional. The UPN of the user who
                          performed the deployment.
                    },
                    "preDeploymentDiffInformation": {
                        "differentArtifactsCount": 0,  # The number of deployed items with
                          differences between source and target stages, before deployment. Required.
                        "newArtifactsCount": 0,  # The number of new items deployed to the
                          target stage. Required.
                        "noDifferenceArtifactsCount": 0  # The number of identical deployed
                          items in the source and target stages, before deployment. Required.
                    },
                    "sourceStageOrder": 0,  # Optional. The numeric identifier of a source
                      pipeline deployment stage. Development (0), Test (1), Production (2).
                    "targetStageOrder": 0,  # Optional. The numeric identifier of a target
                      pipeline deployment stage. Development (0), Test (1), Production (2).
                    "type": "Deploy"  # Optional. Default value is "Deploy". The operation type.
                }
        """

    @distributed_trace_async
    async def deploy_all(self, pipeline_id: str, deploy_request: Union[JSON, IO], **kwargs: Any) -> JSON:
        """Deploys all supported items from the source stage of the specified deployment pipeline.

        To learn about items that aren't supported in deployment pipelines, see `Unsupported items
        </power-bi/create-reports/deployment-pipelines-process#unsupported-items>`_.

        Permissions
        -----------

        The user must at least be a member on both source and target deployment workspaces. For more
        information, see `Permissions
        </power-bi/create-reports/deployment-pipelines-process#permissions>`_.

        Required Scope
        --------------

        Pipeline.Deploy

        Limitations
        -----------

        Maximum 300 deployed items per request.
        :code:`<br>`:code:`<br>`.

        :param pipeline_id: The deployment pipeline ID. Required.
        :type pipeline_id: str
        :param deploy_request: The deploy request. Is either a JSON type or a IO type. Required.
        :type deploy_request: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                deploy_request = {
                    "sourceStageOrder": 0,  # The numeric identifier of the pipeline deployment
                      stage that the content should be deployed from. Development (0), Test (1),
                      Production (2). Required.
                    "isBackwardDeployment": bool,  # Optional. Whether the deployment will be
                      from a later stage in the deployment pipeline, to an earlier one. The default
                      value is ``false``.
                    "newWorkspace": {
                        "capacityId": "str",  # Optional. The ID of the capacity that the new
                          workspace will be assigned to. If unspecified and the API caller has
                          permissions for the source stage workspace capacity, then that capacity will
                          be used. Otherwise, Power BI will select a capacity that the API caller has
                          permissions for.
                        "name": "str"  # Optional. The name of the new workspace.
                    },
                    "note": "str",  # Optional. A note describing the deployment.
                    "options": {
                        "allowCreateArtifact": bool,  # Optional. Whether creating a new
                          Power BI item (such as a report or a dashboard) in the target stage workspace
                          is allowed. If this option isn't set to ``true`` when it's required for
                          deployment, the deployment will fail.
                        "allowOverwriteArtifact": bool,  # Optional. Whether overwriting a
                          Power BI item (such as a report or a dashboard) in the target stage workspace
                          is allowed. If this option isn't set to ``true`` when it's required for
                          deployment, the deployment will fail.
                        "allowOverwriteTargetArtifactLabel": bool,  # Optional. Whether the
                          label of a target Power BI item (such as a report or a dashboard) can be
                          changed. The label gets changed when the source is protected but the target
                          isn't. If this option isn't set to ``true`` when it's required for
                          deployment, the deployment will fail.
                        "allowPurgeData": bool,  # Optional. Whether to delete all data from
                          the target Power BI item (such as a report or a dashboard) when there's a
                          schema mismatch. If this option isn't set to ``true`` when it's required for
                          deployment, the deployment will fail.
                        "allowSkipTilesWithMissingPrerequisites": bool,  # Optional. Whether
                          to skip tiles that don't have a model or a report in the target stage
                          workspace. If this option isn't set to ``true`` when it's required for
                          deployment, the deployment will fail.
                        "allowTakeOver": bool  # Optional. Whether to allow overriding the
                          previous paginated report owner and becoming the owner of the paginated
                          report. Applicable when deploying a paginated report to a stage that already
                          contains a copy of the paginated report that isn't owned by you. If this
                          option isn't set to ``true`` when it's required for deployment, the
                          deployment will fail.
                    },
                    "updateAppSettings": {
                        "updateAppInTargetWorkspace": bool  # Optional. Whether to update the
                          app in the target workspace. Only deployed items that already exist in the
                          app are updated. New deployed items are not added to the app.
                    }
                }

                # response body for status code(s): 202
                response == {
                    "id": "str",  # The operation ID. Required.
                    "lastUpdatedTime": "2020-02-20 00:00:00",  # The date and time that the
                      operation was last updated. Required.
                    "status": "str",  # The pipeline operation status. Required. Known values
                      are: "NotStarted", "Executing", "Succeeded", and "Failed".
                    "executionEndTime": "2020-02-20 00:00:00",  # Optional. The date and time
                      that the operation ended.
                    "executionPlan": {
                        "steps": [
                            {
                                "index": 0,  # The step index. Required.
                                "status": "str",  # The status of the pipeline
                                  operation. Required. Known values are: "NotStarted", "Executing",
                                  "Succeeded", and "Failed".
                                "type": "str",  # The type of deployment step.
                                  Required. Known values are: "DatasetDeployment", "ReportDeployment",
                                  "DashboardDeployment", "DataflowDeployment", and
                                  "DatamartDeployment".
                                "error": {
                                    "errorCode": "str",  # Optional. The error
                                      code.
                                    "errorDetails": "str"  # Optional. Additional
                                      error details.
                                },
                                "preDeploymentDiffState": "str",  # Optional. Is an
                                  item new, different or identical to items in the target stage before
                                  deployment. Known values are: "New", "Different", and "NoDifference".
                                "sourceAndTarget": {
                                    "source": "str",  # The ID of the Power BI
                                      item that's deployed from the source stage. Required.
                                    "sourceDisplayName": "str",  # Optional. The
                                      display name of the Power BI item that's deployed from the source
                                      stage.
                                    "target": "str",  # Optional. The ID of the
                                      Power BI item that will be overwritten in the target stage. Only
                                      applies when overwriting a Power BI item.
                                    "targetDisplayName": "str",  # Optional. The
                                      name of the Power BI item that will be overwritten in the target
                                      stage. Only applies when overwriting a Power BI item.
                                    "type": "str"  # Optional. The type of the
                                      Power BI item that will be overwritten in the target stage. Only
                                      applies when overwriting a Power BI item.
                                }
                            }
                        ]
                    },
                    "executionStartTime": "2020-02-20 00:00:00",  # Optional. The date and time
                      that the operation started.
                    "note": {
                        "content": "str",  # Text describing the deployment. Required.
                        "isTruncated": bool  # Indicates if the note is incomplete. True,
                          only part of the note is returned. False, the note is complete. Required.
                    },
                    "performedBy": {
                        "principalType": "str",  # The type of user who performed the
                          deployment. Required. Known values are: "None", "User", "Group", and "App".
                        "principalObjectID": "str",  # Optional. The ID of the service
                          principal that performed the deployment.
                        "userPrincipalName": "str"  # Optional. The UPN of the user who
                          performed the deployment.
                    },
                    "preDeploymentDiffInformation": {
                        "differentArtifactsCount": 0,  # The number of deployed items with
                          differences between source and target stages, before deployment. Required.
                        "newArtifactsCount": 0,  # The number of new items deployed to the
                          target stage. Required.
                        "noDifferenceArtifactsCount": 0  # The number of identical deployed
                          items in the source and target stages, before deployment. Required.
                    },
                    "sourceStageOrder": 0,  # Optional. The numeric identifier of a source
                      pipeline deployment stage. Development (0), Test (1), Production (2).
                    "targetStageOrder": 0,  # Optional. The numeric identifier of a target
                      pipeline deployment stage. Development (0), Test (1), Production (2).
                    "type": "Deploy"  # Optional. Default value is "Deploy". The operation type.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(deploy_request, (IOBase, bytes)):
            _content = deploy_request
        else:
            _json = deploy_request

        _request = build_pipelines_deploy_all_request(
            pipeline_id=pipeline_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def selective_deploy(
        self, pipeline_id: str, deploy_request: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Deploys the specified items from the source stage of the specified deployment pipeline.

        Permissions
        -----------

        The user must at least be a member on both source and target deployment workspaces. For more
        information, see `Permissions
        </power-bi/create-reports/deployment-pipelines-process#permissions>`_.

        Required Scope
        --------------

        Pipeline.Deploy

        Limitations
        -----------

        Maximum 300 deployed items per request.
        :code:`<br>`:code:`<br>`.

        :param pipeline_id: The deployment pipeline ID. Required.
        :type pipeline_id: str
        :param deploy_request: The selective deploy request. Required.
        :type deploy_request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                deploy_request = {
                    "sourceStageOrder": 0,  # The numeric identifier of the pipeline deployment
                      stage that the content should be deployed from. Development (0), Test (1),
                      Production (2). Required.
                    "dashboards": [
                        {
                            "sourceId": "str",  # The ID of the Power BI item (such as a
                              report or a dashboard) to be deployed. Required.
                            "options": {
                                "allowCreateArtifact": bool,  # Optional. Whether
                                  creating a new Power BI item (such as a report or a dashboard) in the
                                  target stage workspace is allowed. If this option isn't set to
                                  ``true`` when it's required for deployment, the deployment will fail.
                                "allowOverwriteArtifact": bool,  # Optional. Whether
                                  overwriting a Power BI item (such as a report or a dashboard) in the
                                  target stage workspace is allowed. If this option isn't set to
                                  ``true`` when it's required for deployment, the deployment will fail.
                                "allowOverwriteTargetArtifactLabel": bool,  #
                                  Optional. Whether the label of a target Power BI item (such as a
                                  report or a dashboard) can be changed. The label gets changed when
                                  the source is protected but the target isn't. If this option isn't
                                  set to ``true`` when it's required for deployment, the deployment
                                  will fail.
                                "allowPurgeData": bool,  # Optional. Whether to
                                  delete all data from the target Power BI item (such as a report or a
                                  dashboard) when there's a schema mismatch. If this option isn't set
                                  to ``true`` when it's required for deployment, the deployment will
                                  fail.
                                "allowSkipTilesWithMissingPrerequisites": bool,  #
                                  Optional. Whether to skip tiles that don't have a model or a report
                                  in the target stage workspace. If this option isn't set to ``true``
                                  when it's required for deployment, the deployment will fail.
                                "allowTakeOver": bool  # Optional. Whether to allow
                                  overriding the previous paginated report owner and becoming the owner
                                  of the paginated report. Applicable when deploying a paginated report
                                  to a stage that already contains a copy of the paginated report that
                                  isn't owned by you. If this option isn't set to ``true`` when it's
                                  required for deployment, the deployment will fail.
                            }
                        }
                    ],
                    "dataflows": [
                        {
                            "sourceId": "str",  # The ID of the Power BI item (such as a
                              report or a dashboard) to be deployed. Required.
                            "options": {
                                "allowCreateArtifact": bool,  # Optional. Whether
                                  creating a new Power BI item (such as a report or a dashboard) in the
                                  target stage workspace is allowed. If this option isn't set to
                                  ``true`` when it's required for deployment, the deployment will fail.
                                "allowOverwriteArtifact": bool,  # Optional. Whether
                                  overwriting a Power BI item (such as a report or a dashboard) in the
                                  target stage workspace is allowed. If this option isn't set to
                                  ``true`` when it's required for deployment, the deployment will fail.
                                "allowOverwriteTargetArtifactLabel": bool,  #
                                  Optional. Whether the label of a target Power BI item (such as a
                                  report or a dashboard) can be changed. The label gets changed when
                                  the source is protected but the target isn't. If this option isn't
                                  set to ``true`` when it's required for deployment, the deployment
                                  will fail.
                                "allowPurgeData": bool,  # Optional. Whether to
                                  delete all data from the target Power BI item (such as a report or a
                                  dashboard) when there's a schema mismatch. If this option isn't set
                                  to ``true`` when it's required for deployment, the deployment will
                                  fail.
                                "allowSkipTilesWithMissingPrerequisites": bool,  #
                                  Optional. Whether to skip tiles that don't have a model or a report
                                  in the target stage workspace. If this option isn't set to ``true``
                                  when it's required for deployment, the deployment will fail.
                                "allowTakeOver": bool  # Optional. Whether to allow
                                  overriding the previous paginated report owner and becoming the owner
                                  of the paginated report. Applicable when deploying a paginated report
                                  to a stage that already contains a copy of the paginated report that
                                  isn't owned by you. If this option isn't set to ``true`` when it's
                                  required for deployment, the deployment will fail.
                            }
                        }
                    ],
                    "datamarts": [
                        {
                            "sourceId": "str",  # The ID of the Power BI item (such as a
                              report or a dashboard) to be deployed. Required.
                            "options": {
                                "allowCreateArtifact": bool,  # Optional. Whether
                                  creating a new Power BI item (such as a report or a dashboard) in the
                                  target stage workspace is allowed. If this option isn't set to
                                  ``true`` when it's required for deployment, the deployment will fail.
                                "allowOverwriteArtifact": bool,  # Optional. Whether
                                  overwriting a Power BI item (such as a report or a dashboard) in the
                                  target stage workspace is allowed. If this option isn't set to
                                  ``true`` when it's required for deployment, the deployment will fail.
                                "allowOverwriteTargetArtifactLabel": bool,  #
                                  Optional. Whether the label of a target Power BI item (such as a
                                  report or a dashboard) can be changed. The label gets changed when
                                  the source is protected but the target isn't. If this option isn't
                                  set to ``true`` when it's required for deployment, the deployment
                                  will fail.
                                "allowPurgeData": bool,  # Optional. Whether to
                                  delete all data from the target Power BI item (such as a report or a
                                  dashboard) when there's a schema mismatch. If this option isn't set
                                  to ``true`` when it's required for deployment, the deployment will
                                  fail.
                                "allowSkipTilesWithMissingPrerequisites": bool,  #
                                  Optional. Whether to skip tiles that don't have a model or a report
                                  in the target stage workspace. If this option isn't set to ``true``
                                  when it's required for deployment, the deployment will fail.
                                "allowTakeOver": bool  # Optional. Whether to allow
                                  overriding the previous paginated report owner and becoming the owner
                                  of the paginated report. Applicable when deploying a paginated report
                                  to a stage that already contains a copy of the paginated report that
                                  isn't owned by you. If this option isn't set to ``true`` when it's
                                  required for deployment, the deployment will fail.
                            }
                        }
                    ],
                    "datasets": [
                        {
                            "sourceId": "str",  # The ID of the Power BI item (such as a
                              report or a dashboard) to be deployed. Required.
                            "options": {
                                "allowCreateArtifact": bool,  # Optional. Whether
                                  creating a new Power BI item (such as a report or a dashboard) in the
                                  target stage workspace is allowed. If this option isn't set to
                                  ``true`` when it's required for deployment, the deployment will fail.
                                "allowOverwriteArtifact": bool,  # Optional. Whether
                                  overwriting a Power BI item (such as a report or a dashboard) in the
                                  target stage workspace is allowed. If this option isn't set to
                                  ``true`` when it's required for deployment, the deployment will fail.
                                "allowOverwriteTargetArtifactLabel": bool,  #
                                  Optional. Whether the label of a target Power BI item (such as a
                                  report or a dashboard) can be changed. The label gets changed when
                                  the source is protected but the target isn't. If this option isn't
                                  set to ``true`` when it's required for deployment, the deployment
                                  will fail.
                                "allowPurgeData": bool,  # Optional. Whether to
                                  delete all data from the target Power BI item (such as a report or a
                                  dashboard) when there's a schema mismatch. If this option isn't set
                                  to ``true`` when it's required for deployment, the deployment will
                                  fail.
                                "allowSkipTilesWithMissingPrerequisites": bool,  #
                                  Optional. Whether to skip tiles that don't have a model or a report
                                  in the target stage workspace. If this option isn't set to ``true``
                                  when it's required for deployment, the deployment will fail.
                                "allowTakeOver": bool  # Optional. Whether to allow
                                  overriding the previous paginated report owner and becoming the owner
                                  of the paginated report. Applicable when deploying a paginated report
                                  to a stage that already contains a copy of the paginated report that
                                  isn't owned by you. If this option isn't set to ``true`` when it's
                                  required for deployment, the deployment will fail.
                            }
                        }
                    ],
                    "isBackwardDeployment": bool,  # Optional. Whether the deployment will be
                      from a later stage in the deployment pipeline, to an earlier one. The default
                      value is ``false``.
                    "newWorkspace": {
                        "capacityId": "str",  # Optional. The ID of the capacity that the new
                          workspace will be assigned to. If unspecified and the API caller has
                          permissions for the source stage workspace capacity, then that capacity will
                          be used. Otherwise, Power BI will select a capacity that the API caller has
                          permissions for.
                        "name": "str"  # Optional. The name of the new workspace.
                    },
                    "note": "str",  # Optional. A note describing the deployment.
                    "options": {
                        "allowCreateArtifact": bool,  # Optional. Whether creating a new
                          Power BI item (such as a report or a dashboard) in the target stage workspace
                          is allowed. If this option isn't set to ``true`` when it's required for
                          deployment, the deployment will fail.
                        "allowOverwriteArtifact": bool,  # Optional. Whether overwriting a
                          Power BI item (such as a report or a dashboard) in the target stage workspace
                          is allowed. If this option isn't set to ``true`` when it's required for
                          deployment, the deployment will fail.
                        "allowOverwriteTargetArtifactLabel": bool,  # Optional. Whether the
                          label of a target Power BI item (such as a report or a dashboard) can be
                          changed. The label gets changed when the source is protected but the target
                          isn't. If this option isn't set to ``true`` when it's required for
                          deployment, the deployment will fail.
                        "allowPurgeData": bool,  # Optional. Whether to delete all data from
                          the target Power BI item (such as a report or a dashboard) when there's a
                          schema mismatch. If this option isn't set to ``true`` when it's required for
                          deployment, the deployment will fail.
                        "allowSkipTilesWithMissingPrerequisites": bool,  # Optional. Whether
                          to skip tiles that don't have a model or a report in the target stage
                          workspace. If this option isn't set to ``true`` when it's required for
                          deployment, the deployment will fail.
                        "allowTakeOver": bool  # Optional. Whether to allow overriding the
                          previous paginated report owner and becoming the owner of the paginated
                          report. Applicable when deploying a paginated report to a stage that already
                          contains a copy of the paginated report that isn't owned by you. If this
                          option isn't set to ``true`` when it's required for deployment, the
                          deployment will fail.
                    },
                    "reports": [
                        {
                            "sourceId": "str",  # The ID of the Power BI item (such as a
                              report or a dashboard) to be deployed. Required.
                            "options": {
                                "allowCreateArtifact": bool,  # Optional. Whether
                                  creating a new Power BI item (such as a report or a dashboard) in the
                                  target stage workspace is allowed. If this option isn't set to
                                  ``true`` when it's required for deployment, the deployment will fail.
                                "allowOverwriteArtifact": bool,  # Optional. Whether
                                  overwriting a Power BI item (such as a report or a dashboard) in the
                                  target stage workspace is allowed. If this option isn't set to
                                  ``true`` when it's required for deployment, the deployment will fail.
                                "allowOverwriteTargetArtifactLabel": bool,  #
                                  Optional. Whether the label of a target Power BI item (such as a
                                  report or a dashboard) can be changed. The label gets changed when
                                  the source is protected but the target isn't. If this option isn't
                                  set to ``true`` when it's required for deployment, the deployment
                                  will fail.
                                "allowPurgeData": bool,  # Optional. Whether to
                                  delete all data from the target Power BI item (such as a report or a
                                  dashboard) when there's a schema mismatch. If this option isn't set
                                  to ``true`` when it's required for deployment, the deployment will
                                  fail.
                                "allowSkipTilesWithMissingPrerequisites": bool,  #
                                  Optional. Whether to skip tiles that don't have a model or a report
                                  in the target stage workspace. If this option isn't set to ``true``
                                  when it's required for deployment, the deployment will fail.
                                "allowTakeOver": bool  # Optional. Whether to allow
                                  overriding the previous paginated report owner and becoming the owner
                                  of the paginated report. Applicable when deploying a paginated report
                                  to a stage that already contains a copy of the paginated report that
                                  isn't owned by you. If this option isn't set to ``true`` when it's
                                  required for deployment, the deployment will fail.
                            }
                        }
                    ],
                    "updateAppSettings": {
                        "updateAppInTargetWorkspace": bool  # Optional. Whether to update the
                          app in the target workspace. Only deployed items that already exist in the
                          app are updated. New deployed items are not added to the app.
                    }
                }

                # response body for status code(s): 202
                response == {
                    "id": "str",  # The operation ID. Required.
                    "lastUpdatedTime": "2020-02-20 00:00:00",  # The date and time that the
                      operation was last updated. Required.
                    "status": "str",  # The pipeline operation status. Required. Known values
                      are: "NotStarted", "Executing", "Succeeded", and "Failed".
                    "executionEndTime": "2020-02-20 00:00:00",  # Optional. The date and time
                      that the operation ended.
                    "executionPlan": {
                        "steps": [
                            {
                                "index": 0,  # The step index. Required.
                                "status": "str",  # The status of the pipeline
                                  operation. Required. Known values are: "NotStarted", "Executing",
                                  "Succeeded", and "Failed".
                                "type": "str",  # The type of deployment step.
                                  Required. Known values are: "DatasetDeployment", "ReportDeployment",
                                  "DashboardDeployment", "DataflowDeployment", and
                                  "DatamartDeployment".
                                "error": {
                                    "errorCode": "str",  # Optional. The error
                                      code.
                                    "errorDetails": "str"  # Optional. Additional
                                      error details.
                                },
                                "preDeploymentDiffState": "str",  # Optional. Is an
                                  item new, different or identical to items in the target stage before
                                  deployment. Known values are: "New", "Different", and "NoDifference".
                                "sourceAndTarget": {
                                    "source": "str",  # The ID of the Power BI
                                      item that's deployed from the source stage. Required.
                                    "sourceDisplayName": "str",  # Optional. The
                                      display name of the Power BI item that's deployed from the source
                                      stage.
                                    "target": "str",  # Optional. The ID of the
                                      Power BI item that will be overwritten in the target stage. Only
                                      applies when overwriting a Power BI item.
                                    "targetDisplayName": "str",  # Optional. The
                                      name of the Power BI item that will be overwritten in the target
                                      stage. Only applies when overwriting a Power BI item.
                                    "type": "str"  # Optional. The type of the
                                      Power BI item that will be overwritten in the target stage. Only
                                      applies when overwriting a Power BI item.
                                }
                            }
                        ]
                    },
                    "executionStartTime": "2020-02-20 00:00:00",  # Optional. The date and time
                      that the operation started.
                    "note": {
                        "content": "str",  # Text describing the deployment. Required.
                        "isTruncated": bool  # Indicates if the note is incomplete. True,
                          only part of the note is returned. False, the note is complete. Required.
                    },
                    "performedBy": {
                        "principalType": "str",  # The type of user who performed the
                          deployment. Required. Known values are: "None", "User", "Group", and "App".
                        "principalObjectID": "str",  # Optional. The ID of the service
                          principal that performed the deployment.
                        "userPrincipalName": "str"  # Optional. The UPN of the user who
                          performed the deployment.
                    },
                    "preDeploymentDiffInformation": {
                        "differentArtifactsCount": 0,  # The number of deployed items with
                          differences between source and target stages, before deployment. Required.
                        "newArtifactsCount": 0,  # The number of new items deployed to the
                          target stage. Required.
                        "noDifferenceArtifactsCount": 0  # The number of identical deployed
                          items in the source and target stages, before deployment. Required.
                    },
                    "sourceStageOrder": 0,  # Optional. The numeric identifier of a source
                      pipeline deployment stage. Development (0), Test (1), Production (2).
                    "targetStageOrder": 0,  # Optional. The numeric identifier of a target
                      pipeline deployment stage. Development (0), Test (1), Production (2).
                    "type": "Deploy"  # Optional. Default value is "Deploy". The operation type.
                }
        """

    @overload
    async def selective_deploy(
        self, pipeline_id: str, deploy_request: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Deploys the specified items from the source stage of the specified deployment pipeline.

        Permissions
        -----------

        The user must at least be a member on both source and target deployment workspaces. For more
        information, see `Permissions
        </power-bi/create-reports/deployment-pipelines-process#permissions>`_.

        Required Scope
        --------------

        Pipeline.Deploy

        Limitations
        -----------

        Maximum 300 deployed items per request.
        :code:`<br>`:code:`<br>`.

        :param pipeline_id: The deployment pipeline ID. Required.
        :type pipeline_id: str
        :param deploy_request: The selective deploy request. Required.
        :type deploy_request: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 202
                response == {
                    "id": "str",  # The operation ID. Required.
                    "lastUpdatedTime": "2020-02-20 00:00:00",  # The date and time that the
                      operation was last updated. Required.
                    "status": "str",  # The pipeline operation status. Required. Known values
                      are: "NotStarted", "Executing", "Succeeded", and "Failed".
                    "executionEndTime": "2020-02-20 00:00:00",  # Optional. The date and time
                      that the operation ended.
                    "executionPlan": {
                        "steps": [
                            {
                                "index": 0,  # The step index. Required.
                                "status": "str",  # The status of the pipeline
                                  operation. Required. Known values are: "NotStarted", "Executing",
                                  "Succeeded", and "Failed".
                                "type": "str",  # The type of deployment step.
                                  Required. Known values are: "DatasetDeployment", "ReportDeployment",
                                  "DashboardDeployment", "DataflowDeployment", and
                                  "DatamartDeployment".
                                "error": {
                                    "errorCode": "str",  # Optional. The error
                                      code.
                                    "errorDetails": "str"  # Optional. Additional
                                      error details.
                                },
                                "preDeploymentDiffState": "str",  # Optional. Is an
                                  item new, different or identical to items in the target stage before
                                  deployment. Known values are: "New", "Different", and "NoDifference".
                                "sourceAndTarget": {
                                    "source": "str",  # The ID of the Power BI
                                      item that's deployed from the source stage. Required.
                                    "sourceDisplayName": "str",  # Optional. The
                                      display name of the Power BI item that's deployed from the source
                                      stage.
                                    "target": "str",  # Optional. The ID of the
                                      Power BI item that will be overwritten in the target stage. Only
                                      applies when overwriting a Power BI item.
                                    "targetDisplayName": "str",  # Optional. The
                                      name of the Power BI item that will be overwritten in the target
                                      stage. Only applies when overwriting a Power BI item.
                                    "type": "str"  # Optional. The type of the
                                      Power BI item that will be overwritten in the target stage. Only
                                      applies when overwriting a Power BI item.
                                }
                            }
                        ]
                    },
                    "executionStartTime": "2020-02-20 00:00:00",  # Optional. The date and time
                      that the operation started.
                    "note": {
                        "content": "str",  # Text describing the deployment. Required.
                        "isTruncated": bool  # Indicates if the note is incomplete. True,
                          only part of the note is returned. False, the note is complete. Required.
                    },
                    "performedBy": {
                        "principalType": "str",  # The type of user who performed the
                          deployment. Required. Known values are: "None", "User", "Group", and "App".
                        "principalObjectID": "str",  # Optional. The ID of the service
                          principal that performed the deployment.
                        "userPrincipalName": "str"  # Optional. The UPN of the user who
                          performed the deployment.
                    },
                    "preDeploymentDiffInformation": {
                        "differentArtifactsCount": 0,  # The number of deployed items with
                          differences between source and target stages, before deployment. Required.
                        "newArtifactsCount": 0,  # The number of new items deployed to the
                          target stage. Required.
                        "noDifferenceArtifactsCount": 0  # The number of identical deployed
                          items in the source and target stages, before deployment. Required.
                    },
                    "sourceStageOrder": 0,  # Optional. The numeric identifier of a source
                      pipeline deployment stage. Development (0), Test (1), Production (2).
                    "targetStageOrder": 0,  # Optional. The numeric identifier of a target
                      pipeline deployment stage. Development (0), Test (1), Production (2).
                    "type": "Deploy"  # Optional. Default value is "Deploy". The operation type.
                }
        """

    @distributed_trace_async
    async def selective_deploy(self, pipeline_id: str, deploy_request: Union[JSON, IO], **kwargs: Any) -> JSON:
        """Deploys the specified items from the source stage of the specified deployment pipeline.

        Permissions
        -----------

        The user must at least be a member on both source and target deployment workspaces. For more
        information, see `Permissions
        </power-bi/create-reports/deployment-pipelines-process#permissions>`_.

        Required Scope
        --------------

        Pipeline.Deploy

        Limitations
        -----------

        Maximum 300 deployed items per request.
        :code:`<br>`:code:`<br>`.

        :param pipeline_id: The deployment pipeline ID. Required.
        :type pipeline_id: str
        :param deploy_request: The selective deploy request. Is either a JSON type or a IO type.
         Required.
        :type deploy_request: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                deploy_request = {
                    "sourceStageOrder": 0,  # The numeric identifier of the pipeline deployment
                      stage that the content should be deployed from. Development (0), Test (1),
                      Production (2). Required.
                    "dashboards": [
                        {
                            "sourceId": "str",  # The ID of the Power BI item (such as a
                              report or a dashboard) to be deployed. Required.
                            "options": {
                                "allowCreateArtifact": bool,  # Optional. Whether
                                  creating a new Power BI item (such as a report or a dashboard) in the
                                  target stage workspace is allowed. If this option isn't set to
                                  ``true`` when it's required for deployment, the deployment will fail.
                                "allowOverwriteArtifact": bool,  # Optional. Whether
                                  overwriting a Power BI item (such as a report or a dashboard) in the
                                  target stage workspace is allowed. If this option isn't set to
                                  ``true`` when it's required for deployment, the deployment will fail.
                                "allowOverwriteTargetArtifactLabel": bool,  #
                                  Optional. Whether the label of a target Power BI item (such as a
                                  report or a dashboard) can be changed. The label gets changed when
                                  the source is protected but the target isn't. If this option isn't
                                  set to ``true`` when it's required for deployment, the deployment
                                  will fail.
                                "allowPurgeData": bool,  # Optional. Whether to
                                  delete all data from the target Power BI item (such as a report or a
                                  dashboard) when there's a schema mismatch. If this option isn't set
                                  to ``true`` when it's required for deployment, the deployment will
                                  fail.
                                "allowSkipTilesWithMissingPrerequisites": bool,  #
                                  Optional. Whether to skip tiles that don't have a model or a report
                                  in the target stage workspace. If this option isn't set to ``true``
                                  when it's required for deployment, the deployment will fail.
                                "allowTakeOver": bool  # Optional. Whether to allow
                                  overriding the previous paginated report owner and becoming the owner
                                  of the paginated report. Applicable when deploying a paginated report
                                  to a stage that already contains a copy of the paginated report that
                                  isn't owned by you. If this option isn't set to ``true`` when it's
                                  required for deployment, the deployment will fail.
                            }
                        }
                    ],
                    "dataflows": [
                        {
                            "sourceId": "str",  # The ID of the Power BI item (such as a
                              report or a dashboard) to be deployed. Required.
                            "options": {
                                "allowCreateArtifact": bool,  # Optional. Whether
                                  creating a new Power BI item (such as a report or a dashboard) in the
                                  target stage workspace is allowed. If this option isn't set to
                                  ``true`` when it's required for deployment, the deployment will fail.
                                "allowOverwriteArtifact": bool,  # Optional. Whether
                                  overwriting a Power BI item (such as a report or a dashboard) in the
                                  target stage workspace is allowed. If this option isn't set to
                                  ``true`` when it's required for deployment, the deployment will fail.
                                "allowOverwriteTargetArtifactLabel": bool,  #
                                  Optional. Whether the label of a target Power BI item (such as a
                                  report or a dashboard) can be changed. The label gets changed when
                                  the source is protected but the target isn't. If this option isn't
                                  set to ``true`` when it's required for deployment, the deployment
                                  will fail.
                                "allowPurgeData": bool,  # Optional. Whether to
                                  delete all data from the target Power BI item (such as a report or a
                                  dashboard) when there's a schema mismatch. If this option isn't set
                                  to ``true`` when it's required for deployment, the deployment will
                                  fail.
                                "allowSkipTilesWithMissingPrerequisites": bool,  #
                                  Optional. Whether to skip tiles that don't have a model or a report
                                  in the target stage workspace. If this option isn't set to ``true``
                                  when it's required for deployment, the deployment will fail.
                                "allowTakeOver": bool  # Optional. Whether to allow
                                  overriding the previous paginated report owner and becoming the owner
                                  of the paginated report. Applicable when deploying a paginated report
                                  to a stage that already contains a copy of the paginated report that
                                  isn't owned by you. If this option isn't set to ``true`` when it's
                                  required for deployment, the deployment will fail.
                            }
                        }
                    ],
                    "datamarts": [
                        {
                            "sourceId": "str",  # The ID of the Power BI item (such as a
                              report or a dashboard) to be deployed. Required.
                            "options": {
                                "allowCreateArtifact": bool,  # Optional. Whether
                                  creating a new Power BI item (such as a report or a dashboard) in the
                                  target stage workspace is allowed. If this option isn't set to
                                  ``true`` when it's required for deployment, the deployment will fail.
                                "allowOverwriteArtifact": bool,  # Optional. Whether
                                  overwriting a Power BI item (such as a report or a dashboard) in the
                                  target stage workspace is allowed. If this option isn't set to
                                  ``true`` when it's required for deployment, the deployment will fail.
                                "allowOverwriteTargetArtifactLabel": bool,  #
                                  Optional. Whether the label of a target Power BI item (such as a
                                  report or a dashboard) can be changed. The label gets changed when
                                  the source is protected but the target isn't. If this option isn't
                                  set to ``true`` when it's required for deployment, the deployment
                                  will fail.
                                "allowPurgeData": bool,  # Optional. Whether to
                                  delete all data from the target Power BI item (such as a report or a
                                  dashboard) when there's a schema mismatch. If this option isn't set
                                  to ``true`` when it's required for deployment, the deployment will
                                  fail.
                                "allowSkipTilesWithMissingPrerequisites": bool,  #
                                  Optional. Whether to skip tiles that don't have a model or a report
                                  in the target stage workspace. If this option isn't set to ``true``
                                  when it's required for deployment, the deployment will fail.
                                "allowTakeOver": bool  # Optional. Whether to allow
                                  overriding the previous paginated report owner and becoming the owner
                                  of the paginated report. Applicable when deploying a paginated report
                                  to a stage that already contains a copy of the paginated report that
                                  isn't owned by you. If this option isn't set to ``true`` when it's
                                  required for deployment, the deployment will fail.
                            }
                        }
                    ],
                    "datasets": [
                        {
                            "sourceId": "str",  # The ID of the Power BI item (such as a
                              report or a dashboard) to be deployed. Required.
                            "options": {
                                "allowCreateArtifact": bool,  # Optional. Whether
                                  creating a new Power BI item (such as a report or a dashboard) in the
                                  target stage workspace is allowed. If this option isn't set to
                                  ``true`` when it's required for deployment, the deployment will fail.
                                "allowOverwriteArtifact": bool,  # Optional. Whether
                                  overwriting a Power BI item (such as a report or a dashboard) in the
                                  target stage workspace is allowed. If this option isn't set to
                                  ``true`` when it's required for deployment, the deployment will fail.
                                "allowOverwriteTargetArtifactLabel": bool,  #
                                  Optional. Whether the label of a target Power BI item (such as a
                                  report or a dashboard) can be changed. The label gets changed when
                                  the source is protected but the target isn't. If this option isn't
                                  set to ``true`` when it's required for deployment, the deployment
                                  will fail.
                                "allowPurgeData": bool,  # Optional. Whether to
                                  delete all data from the target Power BI item (such as a report or a
                                  dashboard) when there's a schema mismatch. If this option isn't set
                                  to ``true`` when it's required for deployment, the deployment will
                                  fail.
                                "allowSkipTilesWithMissingPrerequisites": bool,  #
                                  Optional. Whether to skip tiles that don't have a model or a report
                                  in the target stage workspace. If this option isn't set to ``true``
                                  when it's required for deployment, the deployment will fail.
                                "allowTakeOver": bool  # Optional. Whether to allow
                                  overriding the previous paginated report owner and becoming the owner
                                  of the paginated report. Applicable when deploying a paginated report
                                  to a stage that already contains a copy of the paginated report that
                                  isn't owned by you. If this option isn't set to ``true`` when it's
                                  required for deployment, the deployment will fail.
                            }
                        }
                    ],
                    "isBackwardDeployment": bool,  # Optional. Whether the deployment will be
                      from a later stage in the deployment pipeline, to an earlier one. The default
                      value is ``false``.
                    "newWorkspace": {
                        "capacityId": "str",  # Optional. The ID of the capacity that the new
                          workspace will be assigned to. If unspecified and the API caller has
                          permissions for the source stage workspace capacity, then that capacity will
                          be used. Otherwise, Power BI will select a capacity that the API caller has
                          permissions for.
                        "name": "str"  # Optional. The name of the new workspace.
                    },
                    "note": "str",  # Optional. A note describing the deployment.
                    "options": {
                        "allowCreateArtifact": bool,  # Optional. Whether creating a new
                          Power BI item (such as a report or a dashboard) in the target stage workspace
                          is allowed. If this option isn't set to ``true`` when it's required for
                          deployment, the deployment will fail.
                        "allowOverwriteArtifact": bool,  # Optional. Whether overwriting a
                          Power BI item (such as a report or a dashboard) in the target stage workspace
                          is allowed. If this option isn't set to ``true`` when it's required for
                          deployment, the deployment will fail.
                        "allowOverwriteTargetArtifactLabel": bool,  # Optional. Whether the
                          label of a target Power BI item (such as a report or a dashboard) can be
                          changed. The label gets changed when the source is protected but the target
                          isn't. If this option isn't set to ``true`` when it's required for
                          deployment, the deployment will fail.
                        "allowPurgeData": bool,  # Optional. Whether to delete all data from
                          the target Power BI item (such as a report or a dashboard) when there's a
                          schema mismatch. If this option isn't set to ``true`` when it's required for
                          deployment, the deployment will fail.
                        "allowSkipTilesWithMissingPrerequisites": bool,  # Optional. Whether
                          to skip tiles that don't have a model or a report in the target stage
                          workspace. If this option isn't set to ``true`` when it's required for
                          deployment, the deployment will fail.
                        "allowTakeOver": bool  # Optional. Whether to allow overriding the
                          previous paginated report owner and becoming the owner of the paginated
                          report. Applicable when deploying a paginated report to a stage that already
                          contains a copy of the paginated report that isn't owned by you. If this
                          option isn't set to ``true`` when it's required for deployment, the
                          deployment will fail.
                    },
                    "reports": [
                        {
                            "sourceId": "str",  # The ID of the Power BI item (such as a
                              report or a dashboard) to be deployed. Required.
                            "options": {
                                "allowCreateArtifact": bool,  # Optional. Whether
                                  creating a new Power BI item (such as a report or a dashboard) in the
                                  target stage workspace is allowed. If this option isn't set to
                                  ``true`` when it's required for deployment, the deployment will fail.
                                "allowOverwriteArtifact": bool,  # Optional. Whether
                                  overwriting a Power BI item (such as a report or a dashboard) in the
                                  target stage workspace is allowed. If this option isn't set to
                                  ``true`` when it's required for deployment, the deployment will fail.
                                "allowOverwriteTargetArtifactLabel": bool,  #
                                  Optional. Whether the label of a target Power BI item (such as a
                                  report or a dashboard) can be changed. The label gets changed when
                                  the source is protected but the target isn't. If this option isn't
                                  set to ``true`` when it's required for deployment, the deployment
                                  will fail.
                                "allowPurgeData": bool,  # Optional. Whether to
                                  delete all data from the target Power BI item (such as a report or a
                                  dashboard) when there's a schema mismatch. If this option isn't set
                                  to ``true`` when it's required for deployment, the deployment will
                                  fail.
                                "allowSkipTilesWithMissingPrerequisites": bool,  #
                                  Optional. Whether to skip tiles that don't have a model or a report
                                  in the target stage workspace. If this option isn't set to ``true``
                                  when it's required for deployment, the deployment will fail.
                                "allowTakeOver": bool  # Optional. Whether to allow
                                  overriding the previous paginated report owner and becoming the owner
                                  of the paginated report. Applicable when deploying a paginated report
                                  to a stage that already contains a copy of the paginated report that
                                  isn't owned by you. If this option isn't set to ``true`` when it's
                                  required for deployment, the deployment will fail.
                            }
                        }
                    ],
                    "updateAppSettings": {
                        "updateAppInTargetWorkspace": bool  # Optional. Whether to update the
                          app in the target workspace. Only deployed items that already exist in the
                          app are updated. New deployed items are not added to the app.
                    }
                }

                # response body for status code(s): 202
                response == {
                    "id": "str",  # The operation ID. Required.
                    "lastUpdatedTime": "2020-02-20 00:00:00",  # The date and time that the
                      operation was last updated. Required.
                    "status": "str",  # The pipeline operation status. Required. Known values
                      are: "NotStarted", "Executing", "Succeeded", and "Failed".
                    "executionEndTime": "2020-02-20 00:00:00",  # Optional. The date and time
                      that the operation ended.
                    "executionPlan": {
                        "steps": [
                            {
                                "index": 0,  # The step index. Required.
                                "status": "str",  # The status of the pipeline
                                  operation. Required. Known values are: "NotStarted", "Executing",
                                  "Succeeded", and "Failed".
                                "type": "str",  # The type of deployment step.
                                  Required. Known values are: "DatasetDeployment", "ReportDeployment",
                                  "DashboardDeployment", "DataflowDeployment", and
                                  "DatamartDeployment".
                                "error": {
                                    "errorCode": "str",  # Optional. The error
                                      code.
                                    "errorDetails": "str"  # Optional. Additional
                                      error details.
                                },
                                "preDeploymentDiffState": "str",  # Optional. Is an
                                  item new, different or identical to items in the target stage before
                                  deployment. Known values are: "New", "Different", and "NoDifference".
                                "sourceAndTarget": {
                                    "source": "str",  # The ID of the Power BI
                                      item that's deployed from the source stage. Required.
                                    "sourceDisplayName": "str",  # Optional. The
                                      display name of the Power BI item that's deployed from the source
                                      stage.
                                    "target": "str",  # Optional. The ID of the
                                      Power BI item that will be overwritten in the target stage. Only
                                      applies when overwriting a Power BI item.
                                    "targetDisplayName": "str",  # Optional. The
                                      name of the Power BI item that will be overwritten in the target
                                      stage. Only applies when overwriting a Power BI item.
                                    "type": "str"  # Optional. The type of the
                                      Power BI item that will be overwritten in the target stage. Only
                                      applies when overwriting a Power BI item.
                                }
                            }
                        ]
                    },
                    "executionStartTime": "2020-02-20 00:00:00",  # Optional. The date and time
                      that the operation started.
                    "note": {
                        "content": "str",  # Text describing the deployment. Required.
                        "isTruncated": bool  # Indicates if the note is incomplete. True,
                          only part of the note is returned. False, the note is complete. Required.
                    },
                    "performedBy": {
                        "principalType": "str",  # The type of user who performed the
                          deployment. Required. Known values are: "None", "User", "Group", and "App".
                        "principalObjectID": "str",  # Optional. The ID of the service
                          principal that performed the deployment.
                        "userPrincipalName": "str"  # Optional. The UPN of the user who
                          performed the deployment.
                    },
                    "preDeploymentDiffInformation": {
                        "differentArtifactsCount": 0,  # The number of deployed items with
                          differences between source and target stages, before deployment. Required.
                        "newArtifactsCount": 0,  # The number of new items deployed to the
                          target stage. Required.
                        "noDifferenceArtifactsCount": 0  # The number of identical deployed
                          items in the source and target stages, before deployment. Required.
                    },
                    "sourceStageOrder": 0,  # Optional. The numeric identifier of a source
                      pipeline deployment stage. Development (0), Test (1), Production (2).
                    "targetStageOrder": 0,  # Optional. The numeric identifier of a target
                      pipeline deployment stage. Development (0), Test (1), Production (2).
                    "type": "Deploy"  # Optional. Default value is "Deploy". The operation type.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(deploy_request, (IOBase, bytes)):
            _content = deploy_request
        else:
            _json = deploy_request

        _request = build_pipelines_selective_deploy_request(
            pipeline_id=pipeline_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_pipelines_as_admin(
        self,
        *,
        expand: Optional[str] = None,
        filter: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        **kwargs: Any
    ) -> JSON:
        """Returns a list of deployment pipelines for the organization.

        Permissions
        -----------

        The user must have administrator rights or authenticate using a service principal.

        Required Scope
        --------------

        Tenant.Read.All or Tenant.ReadWrite.All

        Limitations
        -----------

        Maximum 200 requests per hour.
        :code:`<br>`:code:`<br>`.

        :keyword expand: Accepts a comma-separated list of data types, which will be expanded inline in
         the response. Supports ``users`` and ``stages``. Default value is None.
        :paramtype expand: str
        :keyword filter: Filters the results based on a boolean condition. This API only supports
         filtering for `orphaned deployment pipelines <#get-orphaned-deployment-pipelines-example>`_.
         Unsupported filters will return unfiltered results. Default value is None.
        :paramtype filter: str
        :keyword top: Returns only the first n results. This parameter must be in the range of 1-5000.
         Default value is None.
        :paramtype top: int
        :keyword skip: Skips the first n results. Use with top to fetch results beyond the first 5000.
         Default value is None.
        :paramtype skip: int
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional. OData context.
                    "value": [
                        {
                            "id": "str",  # The deployment pipeline ID. Required.
                            "description": "str",  # Optional. The deployment pipeline
                              description.
                            "displayName": "str",  # Optional. The deployment pipeline
                              display name.
                            "stages": [
                                {
                                    "order": 0,  # The stage order, starting from
                                      zero. Required.
                                    "workspaceId": "str",  # Optional. The
                                      assigned workspace ID. Only applicable when there's an assigned
                                      workspace.
                                    "workspaceName": "str"  # Optional. The
                                      assigned workspace name. Only applicable when there's an assigned
                                      workspace and the user has access to the workspace.
                                }
                            ],
                            "users": [
                                {
                                    "identifier": "str",  # For principal type
                                      ``User``"" , provide the *UPN*. Otherwise provide the `object ID
                                      </power-bi/developer/embedded/embedded-troubleshoot#what-is-the-difference-between-application-object-id-and-principal-object-id>`_
                                      of the principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "accessRight": "Admin"  # Optional. Default
                                      value is "Admin". Required. The access right a user has for the
                                      deployment pipeline.
                                }
                            ]
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_pipelines_get_pipelines_as_admin_request(
            expand=expand,
            filter=filter,
            top=top,
            skip=skip,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_pipeline_users_as_admin(self, pipeline_id: str, **kwargs: Any) -> JSON:
        """Returns a list of users that have access to a specified deployment pipeline.

        Permissions
        -----------

        The user must have administrator rights or authenticate using a service principal.

        Required Scope
        --------------

        Tenant.Read.All or Tenant.ReadWrite.All

        Limitations
        -----------

        Maximum 200 requests per hour.
        :code:`<br>`:code:`<br>`.

        :param pipeline_id: The deployment pipeline ID. Required.
        :type pipeline_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional. OData context.
                    "value": [
                        {
                            "identifier": "str",  # For principal type ``User``"" ,
                              provide the *UPN*. Otherwise provide the `object ID
                              </power-bi/developer/embedded/embedded-troubleshoot#what-is-the-difference-between-application-object-id-and-principal-object-id>`_
                              of the principal. Required.
                            "principalType": "str",  # The principal type. Required.
                              Known values are: "None", "User", "Group", and "App".
                            "accessRight": "Admin"  # Optional. Default value is "Admin".
                              Required. The access right a user has for the deployment pipeline.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_pipelines_get_pipeline_users_as_admin_request(
            pipeline_id=pipeline_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def update_user_as_admin(  # pylint: disable=inconsistent-return-statements
        self, pipeline_id: str, user_details: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Grants user permissions to a specified deployment pipeline.

        Permissions
        -----------

        The user must have administrator rights.

        Required Scope
        --------------

        Tenant.ReadWrite.All

        Limitations
        -----------

        Maximum 200 requests per hour.
        :code:`<br>`:code:`<br>`.

        :param pipeline_id: The deployment pipeline ID. Required.
        :type pipeline_id: str
        :param user_details: Details of user access right. Required.
        :type user_details: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                user_details = {
                    "identifier": "str",  # For principal type ``User``"" , provide the *UPN*.
                      Otherwise provide the `object ID
                      </power-bi/developer/embedded/embedded-troubleshoot#what-is-the-difference-between-application-object-id-and-principal-object-id>`_
                      of the principal. Required.
                    "principalType": "str",  # The principal type. Required. Known values are:
                      "None", "User", "Group", and "App".
                    "accessRight": "Admin"  # Optional. Default value is "Admin". Required. The
                      access right a user has for the deployment pipeline.
                }
        """

    @overload
    async def update_user_as_admin(  # pylint: disable=inconsistent-return-statements
        self, pipeline_id: str, user_details: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Grants user permissions to a specified deployment pipeline.

        Permissions
        -----------

        The user must have administrator rights.

        Required Scope
        --------------

        Tenant.ReadWrite.All

        Limitations
        -----------

        Maximum 200 requests per hour.
        :code:`<br>`:code:`<br>`.

        :param pipeline_id: The deployment pipeline ID. Required.
        :type pipeline_id: str
        :param user_details: Details of user access right. Required.
        :type user_details: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_user_as_admin(  # pylint: disable=inconsistent-return-statements
        self, pipeline_id: str, user_details: Union[JSON, IO], **kwargs: Any
    ) -> None:
        """Grants user permissions to a specified deployment pipeline.

        Permissions
        -----------

        The user must have administrator rights.

        Required Scope
        --------------

        Tenant.ReadWrite.All

        Limitations
        -----------

        Maximum 200 requests per hour.
        :code:`<br>`:code:`<br>`.

        :param pipeline_id: The deployment pipeline ID. Required.
        :type pipeline_id: str
        :param user_details: Details of user access right. Is either a JSON type or a IO type.
         Required.
        :type user_details: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                user_details = {
                    "identifier": "str",  # For principal type ``User``"" , provide the *UPN*.
                      Otherwise provide the `object ID
                      </power-bi/developer/embedded/embedded-troubleshoot#what-is-the-difference-between-application-object-id-and-principal-object-id>`_
                      of the principal. Required.
                    "principalType": "str",  # The principal type. Required. Known values are:
                      "None", "User", "Group", and "App".
                    "accessRight": "Admin"  # Optional. Default value is "Admin". Required. The
                      access right a user has for the deployment pipeline.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(user_details, (IOBase, bytes)):
            _content = user_details
        else:
            _json = user_details

        _request = build_pipelines_update_user_as_admin_request(
            pipeline_id=pipeline_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def delete_user_as_admin(  # pylint: disable=inconsistent-return-statements
        self, pipeline_id: str, identifier: str, **kwargs: Any
    ) -> None:
        """Removes user permissions from a specified deployment pipeline.

        Permissions
        -----------

        The user must have administrator rights.

        Required Scope
        --------------

        Tenant.ReadWrite.All

        Limitations
        -----------

        Maximum 200 requests per hour.
        :code:`<br>`:code:`<br>`.

        :param pipeline_id: The deployment pipeline ID. Required.
        :type pipeline_id: str
        :param identifier: For the principal type ``User``\ , provide the user principal name (UPN).
         Otherwise, provide the `Object ID
         </power-bi/developer/embedded/embedded-troubleshoot#what-is-the-difference-between-application-object-id-and-principal-object-id>`_
         of the principal. Required.
        :type identifier: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_pipelines_delete_user_as_admin_request(
            pipeline_id=pipeline_id,
            identifier=identifier,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class DataflowStorageAccountsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~power_bi_client.aio.PowerBIClient`'s
        :attr:`dataflow_storage_accounts` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get_dataflow_storage_accounts(self, **kwargs: Any) -> JSON:
        """Returns a list of dataflow storage accounts that the user has access to.

        Required Scope
        --------------

        StorageAccount.Read.All or StorageAccount.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional.
                    "value": [
                        {
                            "id": "str",  # The Power BI dataflow storage account ID.
                              Required.
                            "isEnabled": bool,  # Whether workspaces can be assigned to
                              this storage account. Required.
                            "name": "str"  # Optional. The Power BI dataflow storage
                              account name.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_dataflow_storage_accounts_get_dataflow_storage_accounts_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore


class WorkspaceInfoOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~power_bi_client.aio.PowerBIClient`'s
        :attr:`workspace_info` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    async def post_workspace_info(
        self,
        required_workspaces: JSON,
        *,
        lineage: Optional[bool] = None,
        datasource_details: Optional[bool] = None,
        dataset_schema: Optional[bool] = None,
        dataset_expressions: Optional[bool] = None,
        get_artifact_users: Optional[bool] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Initiates a call to receive metadata for the requested list of workspaces.

        ..

           [!IMPORTANT]
           If you set the ``datasetSchema`` or ``datasetExpressions`` parameters to ``true``\ , you
        must fully enable metadata scanning in order for data to be returned. For more information, see
        `Enable tenant settings for metadata scanning
        </power-bi/admin/service-admin-metadata-scanning-setup#enable-tenant-settings-for-metadata-scanning>`_.


        Permissions
        -----------

        The user must have administrator rights (such as Microsoft 365 Global Administrator or Power BI
        Service Administrator) or authenticate using a service principal.

        When running under service principal authentication, an app **must not** have any admin-consent
        required permissions for Power BI set on it in the Azure portal.

        Required Scope
        --------------

        Tenant.Read.All or Tenant.ReadWrite.All

        Relevant only when authenticating via a standard delegated admin access token. Must not be
        present when authentication via a service principal is used.

        Limitations
        -----------


        * Maximum 500 requests per hour.
        * Maximum 16 simultaneous requests.
          :code:`<br>`:code:`<br>`.

        :param required_workspaces: Required workspace IDs to get info for. Required.
        :type required_workspaces: JSON
        :keyword lineage: Whether to return lineage info (upstream dataflows, tiles, data source IDs).
         Default value is None.
        :paramtype lineage: bool
        :keyword datasource_details: Whether to return data source details. Default value is None.
        :paramtype datasource_details: bool
        :keyword dataset_schema: Whether to return dataset schema (tables, columns and measures). If
         you set this parameter to ``true``\ , you must fully enable metadata scanning in order for data
         to be returned. For more information, see `Enable tenant settings for metadata scanning
         </power-bi/admin/service-admin-metadata-scanning-setup#enable-tenant-settings-for-metadata-scanning>`_.
         Default value is None.
        :paramtype dataset_schema: bool
        :keyword dataset_expressions: Whether to return dataset expressions (DAX and Mashup queries).
         If you set this parameter to ``true``\ , you must fully enable metadata scanning in order for
         data to be returned. For more information, see `Enable tenant settings for metadata scanning
         </power-bi/admin/service-admin-metadata-scanning-setup#enable-tenant-settings-for-metadata-scanning>`_.
         Default value is None.
        :paramtype dataset_expressions: bool
        :keyword get_artifact_users: Whether to return user details for a Power BI item (such as a
         report or a dashboard). Default value is None.
        :paramtype get_artifact_users: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                required_workspaces = {
                    "workspaces": [
                        "str"  # Optional. The required workspace IDs to be scanned (supports
                          1 to 100 workspace IDs).
                    ]
                }

                # response body for status code(s): 202
                response == {
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. The scan creation date
                      and time.
                    "error": {
                        "code": "str",  # Optional. The error code.
                        "message": "str",  # Optional. The error message.
                        "target": "str"  # Optional. The error target.
                    },
                    "id": "str",  # Optional. The scan ID.
                    "status": "str"  # Optional. The scan state.
                }
        """

    @overload
    async def post_workspace_info(
        self,
        required_workspaces: IO,
        *,
        lineage: Optional[bool] = None,
        datasource_details: Optional[bool] = None,
        dataset_schema: Optional[bool] = None,
        dataset_expressions: Optional[bool] = None,
        get_artifact_users: Optional[bool] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Initiates a call to receive metadata for the requested list of workspaces.

        ..

           [!IMPORTANT]
           If you set the ``datasetSchema`` or ``datasetExpressions`` parameters to ``true``\ , you
        must fully enable metadata scanning in order for data to be returned. For more information, see
        `Enable tenant settings for metadata scanning
        </power-bi/admin/service-admin-metadata-scanning-setup#enable-tenant-settings-for-metadata-scanning>`_.


        Permissions
        -----------

        The user must have administrator rights (such as Microsoft 365 Global Administrator or Power BI
        Service Administrator) or authenticate using a service principal.

        When running under service principal authentication, an app **must not** have any admin-consent
        required permissions for Power BI set on it in the Azure portal.

        Required Scope
        --------------

        Tenant.Read.All or Tenant.ReadWrite.All

        Relevant only when authenticating via a standard delegated admin access token. Must not be
        present when authentication via a service principal is used.

        Limitations
        -----------


        * Maximum 500 requests per hour.
        * Maximum 16 simultaneous requests.
          :code:`<br>`:code:`<br>`.

        :param required_workspaces: Required workspace IDs to get info for. Required.
        :type required_workspaces: IO
        :keyword lineage: Whether to return lineage info (upstream dataflows, tiles, data source IDs).
         Default value is None.
        :paramtype lineage: bool
        :keyword datasource_details: Whether to return data source details. Default value is None.
        :paramtype datasource_details: bool
        :keyword dataset_schema: Whether to return dataset schema (tables, columns and measures). If
         you set this parameter to ``true``\ , you must fully enable metadata scanning in order for data
         to be returned. For more information, see `Enable tenant settings for metadata scanning
         </power-bi/admin/service-admin-metadata-scanning-setup#enable-tenant-settings-for-metadata-scanning>`_.
         Default value is None.
        :paramtype dataset_schema: bool
        :keyword dataset_expressions: Whether to return dataset expressions (DAX and Mashup queries).
         If you set this parameter to ``true``\ , you must fully enable metadata scanning in order for
         data to be returned. For more information, see `Enable tenant settings for metadata scanning
         </power-bi/admin/service-admin-metadata-scanning-setup#enable-tenant-settings-for-metadata-scanning>`_.
         Default value is None.
        :paramtype dataset_expressions: bool
        :keyword get_artifact_users: Whether to return user details for a Power BI item (such as a
         report or a dashboard). Default value is None.
        :paramtype get_artifact_users: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 202
                response == {
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. The scan creation date
                      and time.
                    "error": {
                        "code": "str",  # Optional. The error code.
                        "message": "str",  # Optional. The error message.
                        "target": "str"  # Optional. The error target.
                    },
                    "id": "str",  # Optional. The scan ID.
                    "status": "str"  # Optional. The scan state.
                }
        """

    @distributed_trace_async
    async def post_workspace_info(
        self,
        required_workspaces: Union[JSON, IO],
        *,
        lineage: Optional[bool] = None,
        datasource_details: Optional[bool] = None,
        dataset_schema: Optional[bool] = None,
        dataset_expressions: Optional[bool] = None,
        get_artifact_users: Optional[bool] = None,
        **kwargs: Any
    ) -> JSON:
        """Initiates a call to receive metadata for the requested list of workspaces.

        ..

           [!IMPORTANT]
           If you set the ``datasetSchema`` or ``datasetExpressions`` parameters to ``true``\ , you
        must fully enable metadata scanning in order for data to be returned. For more information, see
        `Enable tenant settings for metadata scanning
        </power-bi/admin/service-admin-metadata-scanning-setup#enable-tenant-settings-for-metadata-scanning>`_.


        Permissions
        -----------

        The user must have administrator rights (such as Microsoft 365 Global Administrator or Power BI
        Service Administrator) or authenticate using a service principal.

        When running under service principal authentication, an app **must not** have any admin-consent
        required permissions for Power BI set on it in the Azure portal.

        Required Scope
        --------------

        Tenant.Read.All or Tenant.ReadWrite.All

        Relevant only when authenticating via a standard delegated admin access token. Must not be
        present when authentication via a service principal is used.

        Limitations
        -----------


        * Maximum 500 requests per hour.
        * Maximum 16 simultaneous requests.
          :code:`<br>`:code:`<br>`.

        :param required_workspaces: Required workspace IDs to get info for. Is either a JSON type or a
         IO type. Required.
        :type required_workspaces: JSON or IO
        :keyword lineage: Whether to return lineage info (upstream dataflows, tiles, data source IDs).
         Default value is None.
        :paramtype lineage: bool
        :keyword datasource_details: Whether to return data source details. Default value is None.
        :paramtype datasource_details: bool
        :keyword dataset_schema: Whether to return dataset schema (tables, columns and measures). If
         you set this parameter to ``true``\ , you must fully enable metadata scanning in order for data
         to be returned. For more information, see `Enable tenant settings for metadata scanning
         </power-bi/admin/service-admin-metadata-scanning-setup#enable-tenant-settings-for-metadata-scanning>`_.
         Default value is None.
        :paramtype dataset_schema: bool
        :keyword dataset_expressions: Whether to return dataset expressions (DAX and Mashup queries).
         If you set this parameter to ``true``\ , you must fully enable metadata scanning in order for
         data to be returned. For more information, see `Enable tenant settings for metadata scanning
         </power-bi/admin/service-admin-metadata-scanning-setup#enable-tenant-settings-for-metadata-scanning>`_.
         Default value is None.
        :paramtype dataset_expressions: bool
        :keyword get_artifact_users: Whether to return user details for a Power BI item (such as a
         report or a dashboard). Default value is None.
        :paramtype get_artifact_users: bool
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                required_workspaces = {
                    "workspaces": [
                        "str"  # Optional. The required workspace IDs to be scanned (supports
                          1 to 100 workspace IDs).
                    ]
                }

                # response body for status code(s): 202
                response == {
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. The scan creation date
                      and time.
                    "error": {
                        "code": "str",  # Optional. The error code.
                        "message": "str",  # Optional. The error message.
                        "target": "str"  # Optional. The error target.
                    },
                    "id": "str",  # Optional. The scan ID.
                    "status": "str"  # Optional. The scan state.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(required_workspaces, (IOBase, bytes)):
            _content = required_workspaces
        else:
            _json = required_workspaces

        _request = build_workspace_info_post_workspace_info_request(
            lineage=lineage,
            datasource_details=datasource_details,
            dataset_schema=dataset_schema,
            dataset_expressions=dataset_expressions,
            get_artifact_users=get_artifact_users,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_scan_status(self, scan_id: str, **kwargs: Any) -> JSON:
        """Gets the scan status for the specified scan.

        Permissions
        -----------

        The user must have administrator rights (such as Microsoft 365 Global Administrator or Power BI
        Service Administrator) or authenticate using a service principal.

        When running under service principal authentication, an app **must not** have any admin-consent
        required permissions for Power BI set on it in the Azure portal.

        Required Scope
        --------------

        Tenant.Read.All or Tenant.ReadWrite.All

        Relevant only when authenticating via a standard delegated admin access token. Must not be
        present when authentication via a service principal is used.

        Limitations
        -----------

        Maximum 10,000 requests per hour.
        :code:`<br>`:code:`<br>`.

        :param scan_id: The scan ID, which is included in the response from the workspaces or the
         `Admin - WorkspaceInfo PostWorkspaceInfo
         </rest/api/power-bi/admin/workspace-info-post-workspace-info>`_ API call that triggered the
         scan. Required.
        :type scan_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. The scan creation date
                      and time.
                    "error": {
                        "code": "str",  # Optional. The error code.
                        "message": "str",  # Optional. The error message.
                        "target": "str"  # Optional. The error target.
                    },
                    "id": "str",  # Optional. The scan ID.
                    "status": "str"  # Optional. The scan state.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_workspace_info_get_scan_status_request(
            scan_id=scan_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_scan_result(self, scan_id: str, **kwargs: Any) -> JSON:
        """Gets the scan result for the specified scan.

        Only make this API call after a successful `GetScanStatus
        </rest/api/power-bi/admin/workspace-info-get-scan-status>`_ API call. The scan result will
        remain available for 24 hours.

        Permissions
        -----------

        The user must have administrator rights (such as Microsoft 365 Global Administrator or Power BI
        Service Administrator) or authenticate using a service principal.

        When running under service principal authentication, an app **must not** have any admin-consent
        required permissions for Power BI set on it in the Azure portal.

        Required Scope
        --------------

        Tenant.Read.All or Tenant.ReadWrite.All

        Relevant only when authenticating via a standard delegated admin access token. Must not be
        present when authentication via a service principal is used.

        Limitations
        -----------

        Maximum 500 requests per hour.
        :code:`<br>`:code:`<br>`.

        :param scan_id: The scan ID, which is included in the response from the workspaces or the
         `Admin - WorkspaceInfo PostWorkspaceInfo
         </rest/api/power-bi/admin/workspace-info-post-workspace-info>`_ API call that triggered the
         scan. Required.
        :type scan_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "datasourceInstances": [
                        {
                            "connectionDetails": {
                                "account": "str",  # Optional. The connection
                                  account.
                                "classInfo": "str",  # Optional. The connection class
                                  information.
                                "database": "str",  # Optional. The connection
                                  database.
                                "domain": "str",  # Optional. The connection domain.
                                "emailAddress": "str",  # Optional. The connection
                                  email address.
                                "kind": "str",  # Optional. The connection kind.
                                "loginServer": "str",  # Optional. The connection
                                  login server.
                                "path": "str",  # Optional. The connection path.
                                "server": "str",  # Optional. The connection server.
                                "url": "str"  # Optional. The connection URL.
                            },
                            "connectionString": "str",  # Optional. (Deprecated) The data
                              source connection string. Available only for DirectQuery.
                            "datasourceId": "str",  # Optional. The bound data source ID,
                              which is empty when not bound to a gateway.
                            "datasourceType": "str",  # Optional. The data source type.
                            "gatewayId": "str",  # Optional. The bound gateway ID, which
                              is empty when not bound to a gateway. When using a gateway cluster, the
                              gateway ID refers to the primary (first) gateway in the cluster and is
                              similar to the gateway cluster ID.
                            "name": "str"  # Optional. (Deprecated) The data source name.
                              Available only for DirectQuery.
                        }
                    ],
                    "misconfiguredDatasourceInstances": [
                        {
                            "connectionDetails": {
                                "account": "str",  # Optional. The connection
                                  account.
                                "classInfo": "str",  # Optional. The connection class
                                  information.
                                "database": "str",  # Optional. The connection
                                  database.
                                "domain": "str",  # Optional. The connection domain.
                                "emailAddress": "str",  # Optional. The connection
                                  email address.
                                "kind": "str",  # Optional. The connection kind.
                                "loginServer": "str",  # Optional. The connection
                                  login server.
                                "path": "str",  # Optional. The connection path.
                                "server": "str",  # Optional. The connection server.
                                "url": "str"  # Optional. The connection URL.
                            },
                            "connectionString": "str",  # Optional. (Deprecated) The data
                              source connection string. Available only for DirectQuery.
                            "datasourceId": "str",  # Optional. The bound data source ID,
                              which is empty when not bound to a gateway.
                            "datasourceType": "str",  # Optional. The data source type.
                            "gatewayId": "str",  # Optional. The bound gateway ID, which
                              is empty when not bound to a gateway. When using a gateway cluster, the
                              gateway ID refers to the primary (first) gateway in the cluster and is
                              similar to the gateway cluster ID.
                            "name": "str"  # Optional. (Deprecated) The data source name.
                              Available only for DirectQuery.
                        }
                    ],
                    "workspaces": [
                        {
                            "id": "str",  # The workspace object ID. Required.
                            "capacityId": "str",  # Optional. The workspace capacity ID.
                            "dashboards": [
                                {
                                    "id": "str",  # The dashboard ID. Required.
                                    "appId": "str",  # Optional. The app ID,
                                      returned only if the dashboard belongs to an app.
                                    "dataClassification": "str",  # Optional. The
                                      data classification tag of a Power BI item (such as a report or a
                                      dashboard).
                                    "displayName": "str",  # Optional. The
                                      display name of the dashboard.
                                    "isReadOnly": bool,  # Optional. Whether the
                                      dashboard is read-only.
                                    "sensitivityLabel": {
                                        "labelId": "str"  # The sensitivity
                                          label ID. Required.
                                    },
                                    "tiles": [
                                        {
                                            "id": "str",  # The tile ID.
                                              Required.
                                            "datasetId": "str",  #
                                              Optional. The dataset ID. Available only for tiles
                                              created from a report or by using a dataset, such as Q&A
                                              tiles.
                                            "datasetWorkspaceId": "str",
                                              # Optional. The workspace ID of the related dataset,
                                              returned only if the related dataset belongs to a
                                              different workspace.
                                            "reportId": "str",  #
                                              Optional. The report ID. Available only for tiles created
                                              from a report.
                                            "title": "str"  # Optional.
                                              The display name of the tile.
                                        }
                                    ],
                                    "users": [
                                        {
                                            "dashboardUserAccessRight":
                                              "str",  # The access right that the user has for the
                                              dashboard (permission level). Required. Known values are:
                                              "None", "Read", "ReadWrite", "ReadReshare", "ReadCopy",
                                              and "Owner".
                                            "identifier": "str",  #
                                              Identifier of the principal. Required.
                                            "principalType": "str",  #
                                              The principal type. Required. Known values are: "None",
                                              "User", "Group", and "App".
                                            "displayName": "str",  #
                                              Optional. Display name of the principal.
                                            "emailAddress": "str",  #
                                              Optional. Email address of the user.
                                            "graphId": "str",  #
                                              Optional. Identifier of the principal in Microsoft Graph.
                                              Only available for admin APIs.
                                            "profile": {
                                                "id": "str",  # The
                                                  service principal profile ID. Required.
                                                "displayName": "str"
                                                  # Optional. The service principal profile name.
                                            },
                                            "userType": "str"  #
                                              Optional. Type of the user.
                                        }
                                    ]
                                }
                            ],
                            "dataRetrievalState": "str",  # Optional. The workspace data
                              retrieval state.
                            "dataflows": [
                                {
                                    "objectId": "str",  # The dataflow ID.
                                      Required.
                                    "configuredBy": "str",  # Optional. The
                                      dataflow owner.
                                    "datasourceUsages": [
                                        {
                                            "datasourceInstanceId": "str"
                                              # The data source instance ID. Required.
                                        }
                                    ],
                                    "description": "str",  # Optional. The
                                      dataflow description.
                                    "endorsementDetails": {
                                        "certifiedBy": "str",  # Optional.
                                          The user that certified the Power BI item (such as a report
                                          or a dashboard).
                                        "endorsement": "str"  # Optional. The
                                          endorsement status.
                                    },
                                    "misconfiguredDatasourceUsages": [
                                        {
                                            "datasourceInstanceId": "str"
                                              # The data source instance ID. Required.
                                        }
                                    ],
                                    "modelUrl": "str",  # Optional. A URL to the
                                      dataflow definition file (model.json).
                                    "modifiedBy": "str",  # Optional. The user
                                      that modified the dataflow.
                                    "modifiedDateTime": "2020-02-20 00:00:00",  #
                                      Optional. The date and time that the dataflow was last modified.
                                    "name": "str",  # Optional. The dataflow
                                      name.
                                    "sensitivityLabel": {
                                        "labelId": "str"  # The sensitivity
                                          label ID. Required.
                                    },
                                    "upstreamDataflows": [
                                        {
                                            "groupId": "str",  #
                                              Optional. The target group ID.
                                            "targetDataflowId": "str"  #
                                              Optional. The target dataflow ID.
                                        }
                                    ],
                                    "upstreamDatamarts": [
                                        {
                                            "groupId": "str",  #
                                              Optional. The target group ID.
                                            "targetDatamartId": "str"  #
                                              Optional. The target datamart ID.
                                        }
                                    ],
                                    "users": [
                                        {
                                            "identifier": "str",  #
                                              Identifier of the principal. Required.
                                            "principalType": "str",  #
                                              The principal type. Required. Known values are: "None",
                                              "User", "Group", and "App".
                                            "DataflowUserAccessRight":
                                              "str",  # Optional. The access right that a user has for
                                              the dataflow (permission level). Known values are:
                                              "None", "Read", "ReadWrite", "ReadReshare", and "Owner".
                                            "displayName": "str",  #
                                              Optional. Display name of the principal.
                                            "emailAddress": "str",  #
                                              Optional. Email address of the user.
                                            "graphId": "str",  #
                                              Optional. Identifier of the principal in Microsoft Graph.
                                              Only available for admin APIs.
                                            "profile": {
                                                "id": "str",  # The
                                                  service principal profile ID. Required.
                                                "displayName": "str"
                                                  # Optional. The service principal profile name.
                                            },
                                            "userType": "str"  #
                                              Optional. Type of the user.
                                        }
                                    ]
                                }
                            ],
                            "datamarts": [
                                {
                                    "id": "str",  # The datamart ID. Required.
                                    "configuredBy": "str",  # Optional. The name
                                      of the datamart owner.
                                    "configuredById": "str",  # Optional. The ID
                                      of the datamart owner.
                                    "datasourceUsages": [
                                        {
                                            "datasourceInstanceId": "str"
                                              # The data source instance ID. Required.
                                        }
                                    ],
                                    "description": "str",  # Optional. The
                                      datamart description.
                                    "endorsementDetails": {
                                        "certifiedBy": "str",  # Optional.
                                          The user that certified the Power BI item (such as a report
                                          or a dashboard).
                                        "endorsement": "str"  # Optional. The
                                          endorsement status.
                                    },
                                    "modifiedBy": "str",  # Optional. The last
                                      user that modified the datamart.
                                    "modifiedById": "str",  # Optional. The ID of
                                      the last user that modified the datamart.
                                    "modifiedDateTime": "2020-02-20 00:00:00",  #
                                      Optional. The date and time that the datamart was last modified.
                                    "name": "str",  # Optional. The datamart
                                      name.
                                    "sensitivityLabel": {
                                        "labelId": "str"  # The sensitivity
                                          label ID. Required.
                                    },
                                    "state": "str",  # Optional. The datamart
                                      current state. Known values are: "Invalid", "Initialized",
                                      "Active", "Migrating", "Evicted", and "Deleted".
                                    "status": "str",  # Optional. The datamart
                                      status. Known values are: "Invalid", "Available",
                                      "SuspendedInCriticalPhase", "InProgress", "Error", "OutOfRegion",
                                      and "NoCapacity".
                                    "suspendedBatchId": "str",  # Optional.
                                      datamart suspended batch id.
                                    "type": "str",  # Optional. The datamart
                                      type. Known values are: "Unset", "Ignore", "Sql", "Lakehouse",
                                      "Dataverse", and "Datawarehouse".
                                    "upstreamDataflows": [
                                        {
                                            "groupId": "str",  #
                                              Optional. The target group ID.
                                            "targetDataflowId": "str"  #
                                              Optional. The target dataflow ID.
                                        }
                                    ],
                                    "upstreamDatamarts": [
                                        {
                                            "groupId": "str",  #
                                              Optional. The target group ID.
                                            "targetDatamartId": "str"  #
                                              Optional. The target datamart ID.
                                        }
                                    ],
                                    "users": [
                                        {
                                            "datamartUserAccessRight":
                                              "str",  # The access right that the user has for the
                                              datamart (permission level). Required. Known values are:
                                              "None", "Read", "Write", "Reshare", "Explore",
                                              "ReadWrite", "ReadReshare", "ReadWriteReshare",
                                              "ReadExplore", "ReadReshareExplore", "ReadWriteExplore",
                                              and "ReadWriteReshareExplore".
                                            "identifier": "str",  #
                                              Identifier of the principal. Required.
                                            "principalType": "str",  #
                                              The principal type. Required. Known values are: "None",
                                              "User", "Group", and "App".
                                            "displayName": "str",  #
                                              Optional. Display name of the principal.
                                            "emailAddress": "str",  #
                                              Optional. Email address of the user.
                                            "graphId": "str",  #
                                              Optional. Identifier of the principal in Microsoft Graph.
                                              Only available for admin APIs.
                                            "profile": {
                                                "id": "str",  # The
                                                  service principal profile ID. Required.
                                                "displayName": "str"
                                                  # Optional. The service principal profile name.
                                            },
                                            "userType": "str"  #
                                              Optional. Type of the user.
                                        }
                                    ]
                                }
                            ],
                            "datasets": [
                                {
                                    "id": "str",  # The dataset ID. Required.
                                    "ContentProviderType": "str",  # Optional.
                                      The content provider type for the dataset.
                                    "CreatedDate": "2020-02-20 00:00:00",  #
                                      Optional. The dataset creation date and time.
                                    "configuredBy": "str",  # Optional. The
                                      dataset owner.
                                    "datasourceUsages": [
                                        {
                                            "datasourceInstanceId": "str"
                                              # The data source instance ID. Required.
                                        }
                                    ],
                                    "description": "str",  # Optional. The
                                      dataset description.
                                    "endorsementDetails": {
                                        "certifiedBy": "str",  # Optional.
                                          The user that certified the Power BI item (such as a report
                                          or a dashboard).
                                        "endorsement": "str"  # Optional. The
                                          endorsement status.
                                    },
                                    "expressions": [
                                        {
                                            "expression": {
                                                "expression": "str"
                                                  # The source expression. Required.
                                            },
                                            "description": "str",  #
                                              Optional. The expression description.
                                            "name": "str"  # Optional.
                                              The expression name.
                                        }
                                    ],
                                    "misconfiguredDatasourceUsages": [
                                        {
                                            "datasourceInstanceId": "str"
                                              # The data source instance ID. Required.
                                        }
                                    ],
                                    "name": "str",  # Optional. The dataset name.
                                    "roles": [
                                        {
                                            "name": "str",  # The name of
                                              the role. Required.
                                            "members": {
                                                "memberName": "str",
                                                  # The name of the role member. Required.
                                                "identityProvider":
                                                  "str",  # Optional. The role member identity
                                                  provider.
                                                "memberId": "str",  #
                                                  Optional. The role member GUID as assigned by the
                                                  identity provider.
                                                "memberType": "str"
                                                  # Optional. The role member type (user or group).
                                            },
                                            "modelPermission": "str",  #
                                              Optional. The permissions that the role has on the
                                              dataset. For example, Read.
                                            "tablePermissions": {
                                                "name": "str",  # The
                                                  name of the table specified in the filter. Required.
                                                "filterExpression":
                                                  "str"  # Optional. The expression that filters the
                                                  table specified in the filter.
                                            }
                                        }
                                    ],
                                    "schemaMayNotBeUpToDate": bool,  # Optional.
                                      Whether the dataset schema might not be up to date.
                                    "schemaRetrievalError": "str",  # Optional.
                                      The dataset schema retrieval error.
                                    "sensitivityLabel": {
                                        "labelId": "str"  # The sensitivity
                                          label ID. Required.
                                    },
                                    "tables": [
                                        {
                                            "columns": [
                                                {
                                                    "dataType":
                                                      "str",  # The column data type. Required.
                                                    "name":
                                                      "str",  # The column name. Required.
                "dataCategory": "str",  # Optional. Optional. The
                                                      string value to be used for the data category
                                                      which describes the data within this column.
                "formatString": "str",  # Optional. Optional. The
                                                      format of the column as specified in
                                                      `FORMAT_STRING
                                                      <https://docs.microsoft.com/analysis-services/multidimensional-models/mdx/mdx-cell-properties-format-string-contents>`_.
                                                    "isHidden":
                                                      bool,  # Optional. Optional. Whether the column
                                                      is hidden. The default is ``false``.
                "sortByColumn": "str",  # Optional. Optional.
                                                      String name of a column in the same table to be
                                                      used to order the current column.
                "summarizeBy": "str"  # Optional. Optional. The
                                                      aggregate function to use for summarizing this
                                                      column.
                                                }
                                            ],
                                            "name": "str",  # The table
                                              name. Required.
                                            "description": "str",  #
                                              Optional. The table description.
                                            "isHidden": bool,  #
                                              Optional. Optional. Whether this dataset table is hidden.
                                            "measures": [
                                                {
                                                    "expression":
                                                      "str",  # A valid DAX expression. Required.
                                                    "name":
                                                      "str",  # The measure name. Required.
                "description": "str",  # Optional. Optional. The
                                                      measure description.
                "formatString": "str",  # Optional. Optional. A
                                                      string describing how the value should be
                                                      formatted when it's displayed as specified in
                                                      `FORMAT_STRING
                                                      <https://docs.microsoft.com/analysis-services/multidimensional-models/mdx/mdx-cell-properties-format-string-contents>`_.
                                                    "isHidden":
                                                      bool  # Optional. Optional. Whether the measure
                                                      is hidden.
                                                }
                                            ],
                                            "rows": [
                                                {
                                                    "id": "str"
                                                      # Optional. The unique row ID.
                                                }
                                            ],
                                            "source": [
                                                {
                                                    "expression":
                                                      "str"  # The source expression. Required.
                                                }
                                            ]
                                        }
                                    ],
                                    "targetStorageMode": "str",  # Optional. The
                                      dataset storage mode.
                                    "upstreamDataflows": [
                                        {
                                            "groupId": "str",  #
                                              Optional. The target group ID.
                                            "targetDataflowId": "str"  #
                                              Optional. The target dataflow ID.
                                        }
                                    ],
                                    "upstreamDatamarts": [
                                        {
                                            "groupId": "str",  #
                                              Optional. The target group ID.
                                            "targetDatamartId": "str"  #
                                              Optional. The target datamart ID.
                                        }
                                    ],
                                    "upstreamDatasets": [
                                        {
                                            "groupId": "str",  #
                                              Optional. The target group ID.
                                            "targetDatasetId": "str"  #
                                              Optional. The target dataset ID.
                                        }
                                    ],
                                    "users": [
                                        {
                                            "datasetUserAccessRight":
                                              "str",  # The access right that the user has for the
                                              dataset (permission level). Required. Known values are:
                                              "None", "Read", "ReadWrite", "ReadReshare",
                                              "ReadWriteReshare", "ReadExplore", "ReadReshareExplore",
                                              "ReadWriteExplore", and "ReadWriteReshareExplore".
                                            "identifier": "str",  #
                                              Identifier of the principal. Required.
                                            "principalType": "str",  #
                                              The principal type. Required. Known values are: "None",
                                              "User", "Group", and "App".
                                            "displayName": "str",  #
                                              Optional. Display name of the principal.
                                            "emailAddress": "str",  #
                                              Optional. Email address of the user.
                                            "graphId": "str",  #
                                              Optional. Identifier of the principal in Microsoft Graph.
                                              Only available for admin APIs.
                                            "profile": {
                                                "id": "str",  # The
                                                  service principal profile ID. Required.
                                                "displayName": "str"
                                                  # Optional. The service principal profile name.
                                            },
                                            "userType": "str"  #
                                              Optional. Type of the user.
                                        }
                                    ]
                                }
                            ],
                            "description": "str",  # Optional. The workspace description.
                            "isOnDedicatedCapacity": bool,  # Optional. Whether the
                              workspace is assigned to a dedicated capacity.
                            "name": "str",  # Optional. The workspace name.
                            "reports": [
                                {
                                    "id": "str",  # The report ID. Required.
                                    "appId": "str",  # Optional. The app ID,
                                      returned only if the report belongs to an app.
                                    "createdBy": "str",  # Optional. The report
                                      owner. Available only for reports created after June 2019.
                                    "createdById": "str",  # Optional. The ID of
                                      the report owner. Available only for reports created after June
                                      2019.
                                    "createdDateTime": "2020-02-20 00:00:00",  #
                                      Optional. The report creation date and time.
                                    "datasetId": "str",  # Optional. The dataset
                                      ID of the report.
                                    "datasetWorkspaceId": "str",  # Optional. The
                                      workspace ID of the related dataset, returned only if the related
                                      dataset belongs to a different workspace.
                                    "description": "str",  # Optional. The report
                                      description.
                                    "endorsementDetails": {
                                        "certifiedBy": "str",  # Optional.
                                          The user that certified the Power BI item (such as a report
                                          or a dashboard).
                                        "endorsement": "str"  # Optional. The
                                          endorsement status.
                                    },
                                    "modifiedBy": "str",  # Optional. The last
                                      user that modified the report.
                                    "modifiedById": "str",  # Optional. The ID of
                                      the last user that modified the report.
                                    "modifiedDateTime": "2020-02-20 00:00:00",  #
                                      Optional. The date and time that the report was last modified.
                                    "name": "str",  # Optional. The name of the
                                      report.
                                    "reportType": "str",  # Optional. The report
                                      type. "PaginatedReport"
                                    "sensitivityLabel": {
                                        "labelId": "str"  # The sensitivity
                                          label ID. Required.
                                    },
                                    "users": [
                                        {
                                            "identifier": "str",  #
                                              Identifier of the principal. Required.
                                            "principalType": "str",  #
                                              The principal type. Required. Known values are: "None",
                                              "User", "Group", and "App".
                                            "reportUserAccessRight":
                                              "str",  # The access right that the user has for the
                                              report (permission level). Required. Known values are:
                                              "None", "Read", "ReadWrite", "ReadReshare", "ReadCopy",
                                              and "Owner".
                                            "displayName": "str",  #
                                              Optional. Display name of the principal.
                                            "emailAddress": "str",  #
                                              Optional. Email address of the user.
                                            "graphId": "str",  #
                                              Optional. Identifier of the principal in Microsoft Graph.
                                              Only available for admin APIs.
                                            "profile": {
                                                "id": "str",  # The
                                                  service principal profile ID. Required.
                                                "displayName": "str"
                                                  # Optional. The service principal profile name.
                                            },
                                            "userType": "str"  #
                                              Optional. Type of the user.
                                        }
                                    ]
                                }
                            ],
                            "state": "str",  # Optional. The workspace state.
                            "type": "str",  # Optional. The workspace type.
                            "users": [
                                {
                                    "groupUserAccessRight": "str",  # The access
                                      right (permission level) that a user has on the workspace.
                                      Required. Known values are: "None", "Member", "Admin",
                                      "Contributor", and "Viewer".
                                    "identifier": "str",  # Identifier of the
                                      principal. Required.
                                    "principalType": "str",  # The principal
                                      type. Required. Known values are: "None", "User", "Group", and
                                      "App".
                                    "displayName": "str",  # Optional. Display
                                      name of the principal.
                                    "emailAddress": "str",  # Optional. Email
                                      address of the user.
                                    "graphId": "str",  # Optional. Identifier of
                                      the principal in Microsoft Graph. Only available for admin APIs.
                                    "profile": {
                                        "id": "str",  # The service principal
                                          profile ID. Required.
                                        "displayName": "str"  # Optional. The
                                          service principal profile name.
                                    },
                                    "userType": "str"  # Optional. Type of the
                                      user.
                                }
                            ]
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_workspace_info_get_scan_result_request(
            scan_id=scan_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_modified_workspaces(
        self,
        *,
        modified_since: Optional[datetime.datetime] = None,
        exclude_personal_workspaces: Optional[bool] = None,
        exclude_in_active_workspaces: Optional[bool] = None,
        **kwargs: Any
    ) -> List[JSON]:
        """Gets a list of workspace IDs in the organization.

        If the optional ``modifiedSince`` parameter is set to a date-time, only the IDs of workspaces
        that changed after that date-time are returned. If the ``modifiedSince`` parameter isn't used,
        the IDs of all workspaces in the organization are returned. The date-time specified by the
        ``modifiedSince`` parameter must be in the range of 30 minutes (to allow workspace changes to
        take effect) to 30 days prior to the current time.

        Permissions
        -----------

        The user must have administrator rights (such as Microsoft 365 Global Administrator or Power BI
        Service Administrator) or authenticate using a service principal.

        When running under service principal authentication, an app **must not** have any admin-consent
        required permissions for Power BI set on it in the Azure portal.

        Required Scope
        --------------

        Tenant.Read.All or Tenant.ReadWrite.All

        Relevant only when authenticating via a standard delegated admin access token. Must not be
        present when authentication via a service principal is used.

        Limitations
        -----------

        Maximum 30 requests per hour.
        :code:`<br>`:code:`<br>`.

        :keyword modified_since: Last modified date (must be in ISO 8601 compliant UTC format). Default
         value is None.
        :paramtype modified_since: ~datetime.datetime
        :keyword exclude_personal_workspaces: Whether to exclude personal workspaces. Default value is
         None.
        :paramtype exclude_personal_workspaces: bool
        :keyword exclude_in_active_workspaces: Whether to exclude inactive workspaces. Default value is
         None.
        :paramtype exclude_in_active_workspaces: bool
        :return: list of JSON object
        :rtype: list[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "Id": "str"  # The workspace object ID. Required.
                    }
                ]
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[JSON]] = kwargs.pop("cls", None)

        _request = build_workspace_info_get_modified_workspaces_request(
            modified_since=modified_since,
            exclude_personal_workspaces=exclude_personal_workspaces,
            exclude_in_active_workspaces=exclude_in_active_workspaces,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[JSON], deserialized), {})  # type: ignore

        return cast(List[JSON], deserialized)  # type: ignore


class WidelySharedArtifactsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~power_bi_client.aio.PowerBIClient`'s
        :attr:`widely_shared_artifacts` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def links_shared_to_whole_organization(
        self, *, continuation_token_parameter: Optional[str] = None, **kwargs: Any
    ) -> JSON:
        """Returns a list of Power BI reports that are shared with the whole organization through links.

        Permissions
        -----------


        * The user must have administrator rights (such as Office 365 Global Administrator or Power BI
        Service Administrator) or authenticate using a service principal.
        * Delegated permissions are supported.

        Required Scope
        --------------

        Tenant.Read.All or Tenant.ReadWrite.All

        Limitations
        -----------

        Maximum 200 requests per hour.
        :code:`<br>`:code:`<br>`.

        :keyword continuation_token_parameter: Token required to get the next chunk of the result set.
         Default value is None.
        :paramtype continuation_token_parameter: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "artifactAccessEntities": [
                        {
                            "accessRight": "str",  # The access right that the user has
                              for the Power BI item. Required.
                            "artifactId": "str",  # The Power BI item ID. Required.
                            "artifactType": "str",  # The type of Power BI item.
                              Required. Known values are: "Report", "PaginatedReport", "Dashboard",
                              "Dataset", "Dataflow", "PersonalGroup", "Group", "Workspace", "Capacity",
                              and "App".
                            "displayName": "str",  # The display name of the Power BI
                              item. Required.
                            "shareType": "str",  # Optional. The type of how the access
                              is given to the Power BI item. Only available for widely shared artifacts
                              APIs.
                            "sharer": {
                                "identifier": "str",  # Identifier of the principal.
                                  Required.
                                "principalType": "str",  # The principal type.
                                  Required. Known values are: "None", "User", "Group", and "App".
                                "displayName": "str",  # Optional. Display name of
                                  the principal.
                                "emailAddress": "str",  # Optional. Email address of
                                  the user.
                                "graphId": "str",  # Optional. Identifier of the
                                  principal in Microsoft Graph. Only available for admin APIs.
                                "profile": {
                                    "id": "str",  # The service principal profile
                                      ID. Required.
                                    "displayName": "str"  # Optional. The service
                                      principal profile name.
                                },
                                "userType": "str"  # Optional. Type of the user.
                            }
                        }
                    ],
                    "continuationToken": "str",  # Optional. The token for the next chunk in the
                      result set.
                    "continuationUri": "str",  # Optional. The URI of the next chunk in the
                      result set.
                    "odata.context": "str"  # Optional.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_widely_shared_artifacts_links_shared_to_whole_organization_request(
            continuation_token_parameter=continuation_token_parameter,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def published_to_web(self, *, continuation_token_parameter: Optional[str] = None, **kwargs: Any) -> JSON:
        """Returns a list of Power BI items (such as reports or dashboards) that are published to the web.

        Permissions
        -----------


        * The user must have administrator rights (such as Office 365 Global Administrator or Power BI
        Service Administrator) or authenticate using a service principal.
        * Delegated permissions are supported.

        Required Scope
        --------------

        Tenant.Read.All or Tenant.ReadWrite.All

        Limitations
        -----------

        Maximum 200 requests per hour.
        :code:`<br>`:code:`<br>`.

        :keyword continuation_token_parameter: Token required to get the next chunk of the result set.
         Default value is None.
        :paramtype continuation_token_parameter: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "artifactAccessEntities": [
                        {
                            "accessRight": "str",  # The access right that the user has
                              for the Power BI item. Required.
                            "artifactId": "str",  # The Power BI item ID. Required.
                            "artifactType": "str",  # The type of Power BI item.
                              Required. Known values are: "Report", "PaginatedReport", "Dashboard",
                              "Dataset", "Dataflow", "PersonalGroup", "Group", "Workspace", "Capacity",
                              and "App".
                            "displayName": "str",  # The display name of the Power BI
                              item. Required.
                            "shareType": "str",  # Optional. The type of how the access
                              is given to the Power BI item. Only available for widely shared artifacts
                              APIs.
                            "sharer": {
                                "identifier": "str",  # Identifier of the principal.
                                  Required.
                                "principalType": "str",  # The principal type.
                                  Required. Known values are: "None", "User", "Group", and "App".
                                "displayName": "str",  # Optional. Display name of
                                  the principal.
                                "emailAddress": "str",  # Optional. Email address of
                                  the user.
                                "graphId": "str",  # Optional. Identifier of the
                                  principal in Microsoft Graph. Only available for admin APIs.
                                "profile": {
                                    "id": "str",  # The service principal profile
                                      ID. Required.
                                    "displayName": "str"  # Optional. The service
                                      principal profile name.
                                },
                                "userType": "str"  # Optional. Type of the user.
                            }
                        }
                    ],
                    "continuationToken": "str",  # Optional. The token for the next chunk in the
                      result set.
                    "continuationUri": "str",  # Optional. The URI of the next chunk in the
                      result set.
                    "odata.context": "str"  # Optional.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_widely_shared_artifacts_published_to_web_request(
            continuation_token_parameter=continuation_token_parameter,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore


class AdminOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~power_bi_client.aio.PowerBIClient`'s
        :attr:`admin` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    async def add_power_bi_encryption_key(
        self, tenant_key_creation_request: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Adds an encryption key for Power BI workspaces assigned to a capacity.

        Permissions
        -----------

        The user must have administrator rights (such as Office 365 Global Administrator or Power BI
        Service Administrator).

        Required Scope
        --------------

        Tenant.Read.All or Tenant.ReadWrite.All

        Limitations
        -----------

        Maximum 600 requests per hour.
        :code:`<br>`:code:`<br>`.

        :param tenant_key_creation_request: Tenant key information. Required.
        :type tenant_key_creation_request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                tenant_key_creation_request = {
                    "activate": bool,  # Optional. Whether to activate any inactivated capacities
                      and to use this key for its encryption.
                    "isDefault": bool,  # Optional. Whether an encryption key is the default key
                      for the entire tenant. Any newly created capacity inherits the default key.
                    "keyVaultKeyIdentifier": "str",  # Optional. The URI that uniquely specifies
                      an encryption key in Azure Key Vault.
                    "name": "str"  # Optional. The name of the encryption key.
                }

                # response body for status code(s): 200
                response == {
                    "createdAt": "2020-02-20 00:00:00",  # Optional. The creation date and time
                      of the encryption key.
                    "id": "str",  # Optional. The ID of the encryption key.
                    "isDefault": bool,  # Optional. Whether the encryption key is the default key
                      for the entire tenant. Any newly created capacity inherits the default key.
                    "keyVaultKeyIdentifier": "str",  # Optional. The URI that uniquely specifies
                      the encryption key in Azure Key Vault.
                    "name": "str",  # Optional. The name of the encryption key.
                    "updatedAt": "2020-02-20 00:00:00"  # Optional. The last update date and time
                      of the encryption key.
                }
        """

    @overload
    async def add_power_bi_encryption_key(
        self, tenant_key_creation_request: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Adds an encryption key for Power BI workspaces assigned to a capacity.

        Permissions
        -----------

        The user must have administrator rights (such as Office 365 Global Administrator or Power BI
        Service Administrator).

        Required Scope
        --------------

        Tenant.Read.All or Tenant.ReadWrite.All

        Limitations
        -----------

        Maximum 600 requests per hour.
        :code:`<br>`:code:`<br>`.

        :param tenant_key_creation_request: Tenant key information. Required.
        :type tenant_key_creation_request: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "createdAt": "2020-02-20 00:00:00",  # Optional. The creation date and time
                      of the encryption key.
                    "id": "str",  # Optional. The ID of the encryption key.
                    "isDefault": bool,  # Optional. Whether the encryption key is the default key
                      for the entire tenant. Any newly created capacity inherits the default key.
                    "keyVaultKeyIdentifier": "str",  # Optional. The URI that uniquely specifies
                      the encryption key in Azure Key Vault.
                    "name": "str",  # Optional. The name of the encryption key.
                    "updatedAt": "2020-02-20 00:00:00"  # Optional. The last update date and time
                      of the encryption key.
                }
        """

    @distributed_trace_async
    async def add_power_bi_encryption_key(self, tenant_key_creation_request: Union[JSON, IO], **kwargs: Any) -> JSON:
        """Adds an encryption key for Power BI workspaces assigned to a capacity.

        Permissions
        -----------

        The user must have administrator rights (such as Office 365 Global Administrator or Power BI
        Service Administrator).

        Required Scope
        --------------

        Tenant.Read.All or Tenant.ReadWrite.All

        Limitations
        -----------

        Maximum 600 requests per hour.
        :code:`<br>`:code:`<br>`.

        :param tenant_key_creation_request: Tenant key information. Is either a JSON type or a IO type.
         Required.
        :type tenant_key_creation_request: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                tenant_key_creation_request = {
                    "activate": bool,  # Optional. Whether to activate any inactivated capacities
                      and to use this key for its encryption.
                    "isDefault": bool,  # Optional. Whether an encryption key is the default key
                      for the entire tenant. Any newly created capacity inherits the default key.
                    "keyVaultKeyIdentifier": "str",  # Optional. The URI that uniquely specifies
                      an encryption key in Azure Key Vault.
                    "name": "str"  # Optional. The name of the encryption key.
                }

                # response body for status code(s): 200
                response == {
                    "createdAt": "2020-02-20 00:00:00",  # Optional. The creation date and time
                      of the encryption key.
                    "id": "str",  # Optional. The ID of the encryption key.
                    "isDefault": bool,  # Optional. Whether the encryption key is the default key
                      for the entire tenant. Any newly created capacity inherits the default key.
                    "keyVaultKeyIdentifier": "str",  # Optional. The URI that uniquely specifies
                      the encryption key in Azure Key Vault.
                    "name": "str",  # Optional. The name of the encryption key.
                    "updatedAt": "2020-02-20 00:00:00"  # Optional. The last update date and time
                      of the encryption key.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(tenant_key_creation_request, (IOBase, bytes)):
            _content = tenant_key_creation_request
        else:
            _json = tenant_key_creation_request

        _request = build_admin_add_power_bi_encryption_key_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_power_bi_encryption_keys(self, **kwargs: Any) -> JSON:
        """Returns the encryption keys for the tenant.

        Permissions
        -----------


        * The user must have administrator rights (such as Office 365 Global Administrator or Power BI
        Service Administrator) or authenticate using a service principal.
        * Delegated permissions are supported.

        When running under service prinicipal authentication, an app **must not** have any
        admin-consent required premissions for Power BI set on it in the Azure portal.

        Required Scope
        --------------

        Tenant.Read.All or Tenant.ReadWrite.All

        Relevant only when authenticating via a standard delegated admin access token. Must not be
        present when authentication via a service principal is used.
        :code:`<br>`:code:`<br>`.

        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional.
                    "value": [
                        {
                            "createdAt": "2020-02-20 00:00:00",  # Optional. The creation
                              date and time of the encryption key.
                            "id": "str",  # Optional. The ID of the encryption key.
                            "isDefault": bool,  # Optional. Whether the encryption key is
                              the default key for the entire tenant. Any newly created capacity
                              inherits the default key.
                            "keyVaultKeyIdentifier": "str",  # Optional. The URI that
                              uniquely specifies the encryption key in Azure Key Vault.
                            "name": "str",  # Optional. The name of the encryption key.
                            "updatedAt": "2020-02-20 00:00:00"  # Optional. The last
                              update date and time of the encryption key.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_admin_get_power_bi_encryption_keys_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def rotate_power_bi_encryption_key(
        self,
        tenant_key_id: str,
        tenant_key_rotation_request: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Rotate the encryption key for Power BI workspaces assigned to a capacity.

        Permissions
        -----------

        The user must have administrator rights (such as Office 365 Global Administrator or Power BI
        Service Administrator).

        Required Scope
        --------------

        Tenant.Read.All or Tenant.ReadWrite.All

        Limitations
        -----------

        Maximum 600 requests per hour.
        :code:`<br>`:code:`<br>`.

        :param tenant_key_id: The tenant key ID. Required.
        :type tenant_key_id: str
        :param tenant_key_rotation_request: Tenant key information. Required.
        :type tenant_key_rotation_request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                tenant_key_rotation_request = {
                    "keyVaultKeyIdentifier": "str"  # Optional. The URI that uniquely specifies
                      the encryption key in Azure Key Vault.
                }

                # response body for status code(s): 200
                response == {
                    "createdAt": "2020-02-20 00:00:00",  # Optional. The creation date and time
                      of the encryption key.
                    "id": "str",  # Optional. The ID of the encryption key.
                    "isDefault": bool,  # Optional. Whether the encryption key is the default key
                      for the entire tenant. Any newly created capacity inherits the default key.
                    "keyVaultKeyIdentifier": "str",  # Optional. The URI that uniquely specifies
                      the encryption key in Azure Key Vault.
                    "name": "str",  # Optional. The name of the encryption key.
                    "updatedAt": "2020-02-20 00:00:00"  # Optional. The last update date and time
                      of the encryption key.
                }
        """

    @overload
    async def rotate_power_bi_encryption_key(
        self,
        tenant_key_id: str,
        tenant_key_rotation_request: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Rotate the encryption key for Power BI workspaces assigned to a capacity.

        Permissions
        -----------

        The user must have administrator rights (such as Office 365 Global Administrator or Power BI
        Service Administrator).

        Required Scope
        --------------

        Tenant.Read.All or Tenant.ReadWrite.All

        Limitations
        -----------

        Maximum 600 requests per hour.
        :code:`<br>`:code:`<br>`.

        :param tenant_key_id: The tenant key ID. Required.
        :type tenant_key_id: str
        :param tenant_key_rotation_request: Tenant key information. Required.
        :type tenant_key_rotation_request: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "createdAt": "2020-02-20 00:00:00",  # Optional. The creation date and time
                      of the encryption key.
                    "id": "str",  # Optional. The ID of the encryption key.
                    "isDefault": bool,  # Optional. Whether the encryption key is the default key
                      for the entire tenant. Any newly created capacity inherits the default key.
                    "keyVaultKeyIdentifier": "str",  # Optional. The URI that uniquely specifies
                      the encryption key in Azure Key Vault.
                    "name": "str",  # Optional. The name of the encryption key.
                    "updatedAt": "2020-02-20 00:00:00"  # Optional. The last update date and time
                      of the encryption key.
                }
        """

    @distributed_trace_async
    async def rotate_power_bi_encryption_key(
        self, tenant_key_id: str, tenant_key_rotation_request: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Rotate the encryption key for Power BI workspaces assigned to a capacity.

        Permissions
        -----------

        The user must have administrator rights (such as Office 365 Global Administrator or Power BI
        Service Administrator).

        Required Scope
        --------------

        Tenant.Read.All or Tenant.ReadWrite.All

        Limitations
        -----------

        Maximum 600 requests per hour.
        :code:`<br>`:code:`<br>`.

        :param tenant_key_id: The tenant key ID. Required.
        :type tenant_key_id: str
        :param tenant_key_rotation_request: Tenant key information. Is either a JSON type or a IO type.
         Required.
        :type tenant_key_rotation_request: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                tenant_key_rotation_request = {
                    "keyVaultKeyIdentifier": "str"  # Optional. The URI that uniquely specifies
                      the encryption key in Azure Key Vault.
                }

                # response body for status code(s): 200
                response == {
                    "createdAt": "2020-02-20 00:00:00",  # Optional. The creation date and time
                      of the encryption key.
                    "id": "str",  # Optional. The ID of the encryption key.
                    "isDefault": bool,  # Optional. Whether the encryption key is the default key
                      for the entire tenant. Any newly created capacity inherits the default key.
                    "keyVaultKeyIdentifier": "str",  # Optional. The URI that uniquely specifies
                      the encryption key in Azure Key Vault.
                    "name": "str",  # Optional. The name of the encryption key.
                    "updatedAt": "2020-02-20 00:00:00"  # Optional. The last update date and time
                      of the encryption key.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(tenant_key_rotation_request, (IOBase, bytes)):
            _content = tenant_key_rotation_request
        else:
            _json = tenant_key_rotation_request

        _request = build_admin_rotate_power_bi_encryption_key_request(
            tenant_key_id=tenant_key_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_capacities_as_admin(self, *, expand: Optional[str] = None, **kwargs: Any) -> JSON:
        """Returns a list of capacities for the organization.

        Permissions
        -----------


        * The user must have administrator rights (such as Office 365 Global Administrator or Power BI
        Service Administrator) or authenticate using a service principal.
        * Delegated permissions are supported.

        When running under service prinicipal authentication, an app **must not** have any
        admin-consent required premissions for Power BI set on it in the Azure portal.

        Required Scope
        --------------

        Tenant.Read.All or Tenant.ReadWrite.All

        Relevant only when authenticating via a standard delegated admin access token. Must not be
        present when authentication via a service principal is used.
        :code:`<br>`:code:`<br>`.

        :keyword expand: Expands related entities inline. Default value is None.
        :paramtype expand: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional.
                    "value": [
                        {
                            "capacityUserAccessRight": "str",  # The access right a user
                              has on the capacity. Required. Known values are: "None", "Assign", and
                              "Admin".
                            "id": "str",  # The capacity ID. Required.
                            "state": "str",  # The capacity state. Required. Known values
                              are: "NotActivated", "Active", "Provisioning", "ProvisionFailed",
                              "Suspended", "PreSuspended", "Deleting", "Deleted", "Invalid", and
                              "UpdatingSku".
                            "admins": [
                                "str"  # Optional. An array of capacity admins.
                            ],
                            "displayName": "str",  # Optional. The display name of the
                              capacity.
                            "region": "str",  # Optional. The Azure region where the
                              capacity was provisioned.
                            "sku": "str",  # Optional. The capacity SKU.
                            "tenantKey": {
                                "createdAt": "2020-02-20 00:00:00",  # Optional. The
                                  creation date and time of the encryption key.
                                "id": "str",  # Optional. The ID of the encryption
                                  key.
                                "isDefault": bool,  # Optional. Whether the
                                  encryption key is the default key for the entire tenant. Any newly
                                  created capacity inherits the default key.
                                "keyVaultKeyIdentifier": "str",  # Optional. The URI
                                  that uniquely specifies the encryption key in Azure Key Vault.
                                "name": "str",  # Optional. The name of the
                                  encryption key.
                                "updatedAt": "2020-02-20 00:00:00"  # Optional. The
                                  last update date and time of the encryption key.
                            },
                            "tenantKeyId": "str"  # Optional. The ID of an encryption key
                              (only applicable to the admin route).
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_admin_get_capacities_as_admin_request(
            expand=expand,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def patch_capacity_as_admin(  # pylint: disable=inconsistent-return-statements
        self, capacity_id: str, capacity_patch_request: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Changes specific capacity information. Currently, this API call only supports changing the
        capacity's encryption key.

        Permissions
        -----------

        The user must have administrator rights (such as Office 365 Global Administrator or Power BI
        Service Administrator).

        Required Scope
        --------------

        Tenant.Read.All or Tenant.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param capacity_id: The capacity ID. Required.
        :type capacity_id: str
        :param capacity_patch_request: Patch capacity information. Required.
        :type capacity_patch_request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                capacity_patch_request = {
                    "tenantKeyId": "str"  # Optional. The ID of the encryption key.
                }
        """

    @overload
    async def patch_capacity_as_admin(  # pylint: disable=inconsistent-return-statements
        self, capacity_id: str, capacity_patch_request: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Changes specific capacity information. Currently, this API call only supports changing the
        capacity's encryption key.

        Permissions
        -----------

        The user must have administrator rights (such as Office 365 Global Administrator or Power BI
        Service Administrator).

        Required Scope
        --------------

        Tenant.Read.All or Tenant.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param capacity_id: The capacity ID. Required.
        :type capacity_id: str
        :param capacity_patch_request: Patch capacity information. Required.
        :type capacity_patch_request: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def patch_capacity_as_admin(  # pylint: disable=inconsistent-return-statements
        self, capacity_id: str, capacity_patch_request: Union[JSON, IO], **kwargs: Any
    ) -> None:
        """Changes specific capacity information. Currently, this API call only supports changing the
        capacity's encryption key.

        Permissions
        -----------

        The user must have administrator rights (such as Office 365 Global Administrator or Power BI
        Service Administrator).

        Required Scope
        --------------

        Tenant.Read.All or Tenant.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param capacity_id: The capacity ID. Required.
        :type capacity_id: str
        :param capacity_patch_request: Patch capacity information. Is either a JSON type or a IO type.
         Required.
        :type capacity_patch_request: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                capacity_patch_request = {
                    "tenantKeyId": "str"  # Optional. The ID of the encryption key.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(capacity_patch_request, (IOBase, bytes)):
            _content = capacity_patch_request
        else:
            _json = capacity_patch_request

        _request = build_admin_patch_capacity_as_admin_request(
            capacity_id=capacity_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get_refreshables(
        self,
        *,
        top: int,
        expand: Optional[str] = None,
        filter: Optional[str] = None,
        skip: Optional[int] = None,
        **kwargs: Any
    ) -> JSON:
        """Returns a list of refreshables for the organization within a capacity.

        Power BI retains a seven-day refresh history for each dataset, up to a maximum of sixty
        refreshes.

        Permissions
        -----------


        * The user must have administrator rights (such as Office 365 Global Administrator or Power BI
        Service Administrator) or authenticate using a service principal.
        * Delegated permissions are supported.

        When running under service prinicipal authentication, an app **must not** have any
        admin-consent required premissions for Power BI set on it in the Azure portal.

        Required Scope
        --------------

        Tenant.Read.All or Tenant.ReadWrite.All

        Relevant only when authenticating via a standard delegated admin access token. Must not be
        present when authentication via a service principal is used.
        :code:`<br>`:code:`<br>`.

        :keyword top: Returns only the first n results. Required.
        :paramtype top: int
        :keyword expand: Accepts a comma-separated list of data types, which will be expanded inline in
         the response. Supports ``capacities`` and ``groups``. Default value is None.
        :paramtype expand: str
        :keyword filter: Filters the results based on a boolean condition. Default value is None.
        :paramtype filter: str
        :keyword skip: Skips the first n results. Use with top to fetch results beyond the first 1000.
         Default value is None.
        :paramtype skip: int
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional. OData context.
                    "value": [
                        {
                            "averageDuration": 0.0,  # Optional. The average duration in
                              seconds of a refresh during the time window for which refresh data
                              exists.
                            "capacity": {
                                "capacityUserAccessRight": "str",  # The access right
                                  a user has on the capacity. Required. Known values are: "None",
                                  "Assign", and "Admin".
                                "id": "str",  # The capacity ID. Required.
                                "state": "str",  # The capacity state. Required.
                                  Known values are: "NotActivated", "Active", "Provisioning",
                                  "ProvisionFailed", "Suspended", "PreSuspended", "Deleting",
                                  "Deleted", "Invalid", and "UpdatingSku".
                                "admins": [
                                    "str"  # Optional. An array of capacity
                                      admins.
                                ],
                                "displayName": "str",  # Optional. The display name
                                  of the capacity.
                                "region": "str",  # Optional. The Azure region where
                                  the capacity was provisioned.
                                "sku": "str",  # Optional. The capacity SKU.
                                "tenantKey": {
                                    "createdAt": "2020-02-20 00:00:00",  #
                                      Optional. The creation date and time of the encryption key.
                                    "id": "str",  # Optional. The ID of the
                                      encryption key.
                                    "isDefault": bool,  # Optional. Whether the
                                      encryption key is the default key for the entire tenant. Any
                                      newly created capacity inherits the default key.
                                    "keyVaultKeyIdentifier": "str",  # Optional.
                                      The URI that uniquely specifies the encryption key in Azure Key
                                      Vault.
                                    "name": "str",  # Optional. The name of the
                                      encryption key.
                                    "updatedAt": "2020-02-20 00:00:00"  #
                                      Optional. The last update date and time of the encryption key.
                                },
                                "tenantKeyId": "str"  # Optional. The ID of an
                                  encryption key (only applicable to the admin route).
                            },
                            "configuredBy": [
                                "str"  # Optional. The refreshable owners.
                            ],
                            "endTime": "2020-02-20 00:00:00",  # Optional. The end time
                              of the window for which refresh data exists.
                            "group": {
                                "id": "str",  # The workspace ID. Required.
                                "name": "str"  # Optional. The group name.
                            },
                            "id": "str",  # Optional. The object ID of the refreshable.
                            "kind": "Dataset",  # Optional. Default value is "Dataset".
                              The refreshable kind.
                            "lastRefresh": {
                                "endTime": "2020-02-20 00:00:00",  # Optional. The
                                  end date and time of the refresh (may be empty if a refresh is in
                                  progress).
                                "refreshType": "str",  # Optional. The type of
                                  refresh request. Known values are: "Scheduled", "OnDemand", "ViaApi",
                                  "ViaXmlaEndpoint", "ViaEnhancedApi", and "OnDemandTraining".
                                "requestId": "str",  # Optional. The identifier of
                                  the refresh request. Provide this identifier in all service requests.
                                "serviceExceptionJson": "str",  # Optional. Failure
                                  error code in JSON format (empty if no error).
                                "startTime": "2020-02-20 00:00:00",  # Optional. The
                                  start date and time of the refresh.
                                "status": "str"  # Optional. * ``Unknown`` if the
                                  completion state is unknown or a refresh is in progress. *
                                  ``Completed`` for a successfully completed refresh. * ``Failed`` for
                                  an unsuccessful refresh ("" ``serviceExceptionJson`` will contain the
                                  error code). * ``Disabled`` if the refresh is disabled by a selective
                                  refresh.
                            },
                            "medianDuration": 0.0,  # Optional. The median duration in
                              seconds of a refresh within the time window for which refresh data
                              exists.
                            "name": "str",  # Optional. The display name of the
                              refreshable.
                            "refreshCount": 0,  # Optional. The number of refreshes
                              within the time window for which refresh data exists.
                            "refreshFailures": 0,  # Optional. The number of refresh
                              failures within the time window for which refresh data exists.
                            "refreshSchedule": {
                                "NotifyOption": "str",  # Optional. The notification
                                  option on termination of a scheduled refresh. Service principals only
                                  support the ``NoNotification`` value. Known values are:
                                  "NoNotification" and "MailOnFailure".
                                "days": [
                                    "str"  # Optional. The days on which to
                                      execute the refresh.
                                ],
                                "enabled": bool,  # Optional. Whether the refresh is
                                  enabled.
                                "localTimeZoneId": "str",  # Optional. The ID of the
                                  time zone to use. For more information, see `Time zone info
                                  </dotnet/api/system.timezoneinfo.id>`_.
                                "times": [
                                    "str"  # Optional. The times of day to
                                      execute the refresh.
                                ]
                            },
                            "refreshesPerDay": 0,  # Optional. The number of refreshes
                              per day (scheduled and on-demand) within the time window for which
                              refresh data exists.
                            "startTime": "2020-02-20 00:00:00"  # Optional. The start
                              time of the window for which refresh data exists.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_admin_get_refreshables_request(
            top=top,
            expand=expand,
            filter=filter,
            skip=skip,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_refreshables_for_capacity(
        self,
        capacity_id: str,
        *,
        top: int,
        expand: Optional[str] = None,
        filter: Optional[str] = None,
        skip: Optional[int] = None,
        **kwargs: Any
    ) -> JSON:
        """Returns a list of refreshables for the specified capacity that the user has access to.

        Power BI retains a seven-day refresh history for each dataset, up to a maximum of sixty
        refreshes.

        Permissions
        -----------


        * The user must have administrator rights (such as Office 365 Global Administrator or Power BI
        Service Administrator) or authenticate using a service principal.
        * Delegated permissions are supported.

        When running under service prinicipal authentication, an app **must not** have any
        admin-consent required premissions for Power BI set on it in the Azure portal.

        Required Scope
        --------------

        Tenant.Read.All or Tenant.ReadWrite.All

        Relevant only when authenticating via a standard delegated admin access token. Must not be
        present when authentication via a service principal is used.
        :code:`<br>`:code:`<br>`.

        :param capacity_id: The capacity ID. Required.
        :type capacity_id: str
        :keyword top: Returns only the first n results. Required.
        :paramtype top: int
        :keyword expand: Accepts a comma-separated list of data types, which will be expanded inline in
         the response. Supports ``capacities`` and ``groups``. Default value is None.
        :paramtype expand: str
        :keyword filter: Filters the results based on a boolean condition. Default value is None.
        :paramtype filter: str
        :keyword skip: Skips the first n results. Use with top to fetch results beyond the first 1000.
         Default value is None.
        :paramtype skip: int
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional. OData context.
                    "value": [
                        {
                            "averageDuration": 0.0,  # Optional. The average duration in
                              seconds of a refresh during the time window for which refresh data
                              exists.
                            "capacity": {
                                "capacityUserAccessRight": "str",  # The access right
                                  a user has on the capacity. Required. Known values are: "None",
                                  "Assign", and "Admin".
                                "id": "str",  # The capacity ID. Required.
                                "state": "str",  # The capacity state. Required.
                                  Known values are: "NotActivated", "Active", "Provisioning",
                                  "ProvisionFailed", "Suspended", "PreSuspended", "Deleting",
                                  "Deleted", "Invalid", and "UpdatingSku".
                                "admins": [
                                    "str"  # Optional. An array of capacity
                                      admins.
                                ],
                                "displayName": "str",  # Optional. The display name
                                  of the capacity.
                                "region": "str",  # Optional. The Azure region where
                                  the capacity was provisioned.
                                "sku": "str",  # Optional. The capacity SKU.
                                "tenantKey": {
                                    "createdAt": "2020-02-20 00:00:00",  #
                                      Optional. The creation date and time of the encryption key.
                                    "id": "str",  # Optional. The ID of the
                                      encryption key.
                                    "isDefault": bool,  # Optional. Whether the
                                      encryption key is the default key for the entire tenant. Any
                                      newly created capacity inherits the default key.
                                    "keyVaultKeyIdentifier": "str",  # Optional.
                                      The URI that uniquely specifies the encryption key in Azure Key
                                      Vault.
                                    "name": "str",  # Optional. The name of the
                                      encryption key.
                                    "updatedAt": "2020-02-20 00:00:00"  #
                                      Optional. The last update date and time of the encryption key.
                                },
                                "tenantKeyId": "str"  # Optional. The ID of an
                                  encryption key (only applicable to the admin route).
                            },
                            "configuredBy": [
                                "str"  # Optional. The refreshable owners.
                            ],
                            "endTime": "2020-02-20 00:00:00",  # Optional. The end time
                              of the window for which refresh data exists.
                            "group": {
                                "id": "str",  # The workspace ID. Required.
                                "name": "str"  # Optional. The group name.
                            },
                            "id": "str",  # Optional. The object ID of the refreshable.
                            "kind": "Dataset",  # Optional. Default value is "Dataset".
                              The refreshable kind.
                            "lastRefresh": {
                                "endTime": "2020-02-20 00:00:00",  # Optional. The
                                  end date and time of the refresh (may be empty if a refresh is in
                                  progress).
                                "refreshType": "str",  # Optional. The type of
                                  refresh request. Known values are: "Scheduled", "OnDemand", "ViaApi",
                                  "ViaXmlaEndpoint", "ViaEnhancedApi", and "OnDemandTraining".
                                "requestId": "str",  # Optional. The identifier of
                                  the refresh request. Provide this identifier in all service requests.
                                "serviceExceptionJson": "str",  # Optional. Failure
                                  error code in JSON format (empty if no error).
                                "startTime": "2020-02-20 00:00:00",  # Optional. The
                                  start date and time of the refresh.
                                "status": "str"  # Optional. * ``Unknown`` if the
                                  completion state is unknown or a refresh is in progress. *
                                  ``Completed`` for a successfully completed refresh. * ``Failed`` for
                                  an unsuccessful refresh ("" ``serviceExceptionJson`` will contain the
                                  error code). * ``Disabled`` if the refresh is disabled by a selective
                                  refresh.
                            },
                            "medianDuration": 0.0,  # Optional. The median duration in
                              seconds of a refresh within the time window for which refresh data
                              exists.
                            "name": "str",  # Optional. The display name of the
                              refreshable.
                            "refreshCount": 0,  # Optional. The number of refreshes
                              within the time window for which refresh data exists.
                            "refreshFailures": 0,  # Optional. The number of refresh
                              failures within the time window for which refresh data exists.
                            "refreshSchedule": {
                                "NotifyOption": "str",  # Optional. The notification
                                  option on termination of a scheduled refresh. Service principals only
                                  support the ``NoNotification`` value. Known values are:
                                  "NoNotification" and "MailOnFailure".
                                "days": [
                                    "str"  # Optional. The days on which to
                                      execute the refresh.
                                ],
                                "enabled": bool,  # Optional. Whether the refresh is
                                  enabled.
                                "localTimeZoneId": "str",  # Optional. The ID of the
                                  time zone to use. For more information, see `Time zone info
                                  </dotnet/api/system.timezoneinfo.id>`_.
                                "times": [
                                    "str"  # Optional. The times of day to
                                      execute the refresh.
                                ]
                            },
                            "refreshesPerDay": 0,  # Optional. The number of refreshes
                              per day (scheduled and on-demand) within the time window for which
                              refresh data exists.
                            "startTime": "2020-02-20 00:00:00"  # Optional. The start
                              time of the window for which refresh data exists.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_admin_get_refreshables_for_capacity_request(
            capacity_id=capacity_id,
            top=top,
            expand=expand,
            filter=filter,
            skip=skip,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_refreshable_for_capacity(
        self, capacity_id: str, refreshable_id: str, *, expand: Optional[str] = None, **kwargs: Any
    ) -> JSON:
        """Returns the specified refreshable for the specified capacity that the user has access to.

        Power BI retains a seven-day refresh history for each dataset, up to a maximum of sixty
        refreshes.

        Permissions
        -----------


        * The user must have administrator rights (such as Office 365 Global Administrator or Power BI
        Service Administrator) or authenticate using a service principal.
        * Delegated permissions are supported.

        When running under service prinicipal authentication, an app **must not** have any
        admin-consent required premissions for Power BI set on it in the Azure portal.

        Required Scope
        --------------

        Tenant.Read.All or Tenant.ReadWrite.All

        Relevant only when authenticating via a standard delegated admin access token. Must not be
        present when authentication via a service principal is used.
        :code:`<br>`:code:`<br>`.

        :param capacity_id: The capacity ID. Required.
        :type capacity_id: str
        :param refreshable_id: The refreshable ID. Required.
        :type refreshable_id: str
        :keyword expand: Accepts a comma-separated list of data types, which will be expanded inline in
         the response. Supports ``capacities`` and ``groups``. Default value is None.
        :paramtype expand: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional. OData context.
                    "value": [
                        {
                            "averageDuration": 0.0,  # Optional. The average duration in
                              seconds of a refresh during the time window for which refresh data
                              exists.
                            "capacity": {
                                "capacityUserAccessRight": "str",  # The access right
                                  a user has on the capacity. Required. Known values are: "None",
                                  "Assign", and "Admin".
                                "id": "str",  # The capacity ID. Required.
                                "state": "str",  # The capacity state. Required.
                                  Known values are: "NotActivated", "Active", "Provisioning",
                                  "ProvisionFailed", "Suspended", "PreSuspended", "Deleting",
                                  "Deleted", "Invalid", and "UpdatingSku".
                                "admins": [
                                    "str"  # Optional. An array of capacity
                                      admins.
                                ],
                                "displayName": "str",  # Optional. The display name
                                  of the capacity.
                                "region": "str",  # Optional. The Azure region where
                                  the capacity was provisioned.
                                "sku": "str",  # Optional. The capacity SKU.
                                "tenantKey": {
                                    "createdAt": "2020-02-20 00:00:00",  #
                                      Optional. The creation date and time of the encryption key.
                                    "id": "str",  # Optional. The ID of the
                                      encryption key.
                                    "isDefault": bool,  # Optional. Whether the
                                      encryption key is the default key for the entire tenant. Any
                                      newly created capacity inherits the default key.
                                    "keyVaultKeyIdentifier": "str",  # Optional.
                                      The URI that uniquely specifies the encryption key in Azure Key
                                      Vault.
                                    "name": "str",  # Optional. The name of the
                                      encryption key.
                                    "updatedAt": "2020-02-20 00:00:00"  #
                                      Optional. The last update date and time of the encryption key.
                                },
                                "tenantKeyId": "str"  # Optional. The ID of an
                                  encryption key (only applicable to the admin route).
                            },
                            "configuredBy": [
                                "str"  # Optional. The refreshable owners.
                            ],
                            "endTime": "2020-02-20 00:00:00",  # Optional. The end time
                              of the window for which refresh data exists.
                            "group": {
                                "id": "str",  # The workspace ID. Required.
                                "name": "str"  # Optional. The group name.
                            },
                            "id": "str",  # Optional. The object ID of the refreshable.
                            "kind": "Dataset",  # Optional. Default value is "Dataset".
                              The refreshable kind.
                            "lastRefresh": {
                                "endTime": "2020-02-20 00:00:00",  # Optional. The
                                  end date and time of the refresh (may be empty if a refresh is in
                                  progress).
                                "refreshType": "str",  # Optional. The type of
                                  refresh request. Known values are: "Scheduled", "OnDemand", "ViaApi",
                                  "ViaXmlaEndpoint", "ViaEnhancedApi", and "OnDemandTraining".
                                "requestId": "str",  # Optional. The identifier of
                                  the refresh request. Provide this identifier in all service requests.
                                "serviceExceptionJson": "str",  # Optional. Failure
                                  error code in JSON format (empty if no error).
                                "startTime": "2020-02-20 00:00:00",  # Optional. The
                                  start date and time of the refresh.
                                "status": "str"  # Optional. * ``Unknown`` if the
                                  completion state is unknown or a refresh is in progress. *
                                  ``Completed`` for a successfully completed refresh. * ``Failed`` for
                                  an unsuccessful refresh ("" ``serviceExceptionJson`` will contain the
                                  error code). * ``Disabled`` if the refresh is disabled by a selective
                                  refresh.
                            },
                            "medianDuration": 0.0,  # Optional. The median duration in
                              seconds of a refresh within the time window for which refresh data
                              exists.
                            "name": "str",  # Optional. The display name of the
                              refreshable.
                            "refreshCount": 0,  # Optional. The number of refreshes
                              within the time window for which refresh data exists.
                            "refreshFailures": 0,  # Optional. The number of refresh
                              failures within the time window for which refresh data exists.
                            "refreshSchedule": {
                                "NotifyOption": "str",  # Optional. The notification
                                  option on termination of a scheduled refresh. Service principals only
                                  support the ``NoNotification`` value. Known values are:
                                  "NoNotification" and "MailOnFailure".
                                "days": [
                                    "str"  # Optional. The days on which to
                                      execute the refresh.
                                ],
                                "enabled": bool,  # Optional. Whether the refresh is
                                  enabled.
                                "localTimeZoneId": "str",  # Optional. The ID of the
                                  time zone to use. For more information, see `Time zone info
                                  </dotnet/api/system.timezoneinfo.id>`_.
                                "times": [
                                    "str"  # Optional. The times of day to
                                      execute the refresh.
                                ]
                            },
                            "refreshesPerDay": 0,  # Optional. The number of refreshes
                              per day (scheduled and on-demand) within the time window for which
                              refresh data exists.
                            "startTime": "2020-02-20 00:00:00"  # Optional. The start
                              time of the window for which refresh data exists.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_admin_get_refreshable_for_capacity_request(
            capacity_id=capacity_id,
            refreshable_id=refreshable_id,
            expand=expand,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_activity_events(
        self,
        *,
        start_date_time: Optional[str] = None,
        end_date_time: Optional[str] = None,
        continuation_token_parameter: Optional[str] = None,
        filter: Optional[str] = None,
        **kwargs: Any
    ) -> JSON:
        """Returns a list of audit activity events for a tenant.

        Provide either a continuation token or both a start and end date time. ``StartDateTime`` and
        ``EndDateTime`` must be in the same UTC day and should be wrapped in single quotes.

        Permissions
        -----------


        * The user must have administrator rights (such as Office 365 Global Administrator or Power BI
        Service Administrator) or authenticate using a service principal.
        * Delegated permissions are supported.

        When running under service prinicipal authentication, an app **must not** have any
        admin-consent required premissions for Power BI set on it in the Azure portal.

        Required Scope
        --------------

        Tenant.Read.All or Tenant.ReadWrite.All

        Relevant only when authenticating via a standard delegated admin access token. Must not be
        present when authentication via a service principal is used.

        Limitations
        -----------


        * Maximum 200 requests per hour.
        * Activity logging isn't supported for Microsoft Cloud Deutschland.
          :code:`<br>`:code:`<br>`.

        :keyword start_date_time: Start date and time of the window for audit event results. Must be in
         ISO 8601 compliant UTC format. Default value is None.
        :paramtype start_date_time: str
        :keyword end_date_time: End date and time of the window for audit event results. Must be in ISO
         8601 compliant UTC format. Default value is None.
        :paramtype end_date_time: str
        :keyword continuation_token_parameter: Token required to get the next chunk of the result set.
         Default value is None.
        :paramtype continuation_token_parameter: str
        :keyword filter: Filters the results based on a boolean condition, using 'Activity', 'UserId',
         or both properties. Supports only 'eq' and 'and' operators. Default value is None.
        :paramtype filter: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "activityEventEntities": [
                        {}  # Optional. An array of activity event objects. To learn more
                          about an activity event (which is a collection of event properties) refer to
                          `Microsoft 365 Management Activity schema
                          <https://learn.microsoft.com/en-us/office/office-365-management-api/office-365-management-activity-api-schema#power-bi-schema>`_.
                    ],
                    "continuationToken": "str",  # Optional. Token to get the next chunk of the
                      result set.
                    "continuationUri": "str"  # Optional. The URI for the next chunk in the
                      result set.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_admin_get_activity_events_request(
            start_date_time=start_date_time,
            end_date_time=end_date_time,
            continuation_token_parameter=continuation_token_parameter,
            filter=filter,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore


class EmbedTokenOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~power_bi_client.aio.PowerBIClient`'s
        :attr:`embed_token` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    async def generate_token(
        self, request_parameters: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Generates an embed token for multiple reports, datasets, and target workspaces.

        * Reports and datasets don't have to be related.
        * You can bind a report to a dataset during embedding.
        * You can only create a report in workspaces specified by the ``targetWorkspaces`` parameter.

        ..

           [!IMPORTANT]
           This API call is only relevant to the `embed for your customers
        </power-bi/developer/embed-sample-for-customers>`_ scenario. To learn more about using this
        API, see `Considerations when generating an embed token
        </power-bi/developer/embedded/generate-embed-token>`_.


        Permissions
        -----------


        * When using a service principal for authentication, refer to `Embed Power BI content with
        service principal </power-bi/developer/embed-service-principal>`_ and `Considerations and
        limitations
        </power-bi/developer/embedded/embed-service-principal#considerations-and-limitations>`_.
        * For Power BI reports with a paginated visual, include the paginated report ID in the API
        call. For more information, see `example
        </rest/api/power-bi/embed-token/generate-token#examples>`_.
        * This API call can be called by a service principal profile. For more information see:
        `Service principal profiles in Power BI Embedded
        </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        All of the following, unless a requirement doesn't apply:


        * Content.Create, required if a target workspace is specified in `GenerateTokenRequestV2
        </rest/api/power-bi/embed-token/generate-token#generatetokenrequestv2>`_.
        * Report.ReadWrite.All or Report.Read.All, required if a report is specified in
        `GenerateTokenRequestV2
        </rest/api/power-bi/embed-token/generate-token#generatetokenrequestv2>`_.
        * Report.ReadWrite.All, required if the ``allowEdit`` flag is specified for at least one report
        in `GenerateTokenRequestV2
        </rest/api/power-bi/embed-token/generate-token#generatetokenrequestv2>`_.
        * Dataset.ReadWrite.All or Dataset.Read.All

        Limitations
        -----------


        * You can only create a report in workspaces specified by the ``targetWorkspaces`` parameter.
        * All reports and datasets must reside in a **V2** workspace.
        * All target workspaces must be **V2** workspaces.
        * Maximum 50 reports.
        * Maximum 50 datasets.
        * Maximum 50 target workspaces.
        * For Azure Analysis Services or Analysis Services on-premises live connection reports,
        generating an embed token with row-level security (RLS) might not work for several minutes
        after a `rebind </rest/api/power-bi/reports/rebind-report>`_.
          :code:`<br>`:code:`<br>`.

        :param request_parameters: Generate token parameters. Required.
        :type request_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                request_parameters = {
                    "datasets": [
                        {
                            "id": "str",  # The dataset ID. Required.
                            "xmlaPermissions": "str"  # Optional. XMLA Permissions. Known
                              values are: "Off" and "ReadOnly".
                        }
                    ],
                    "datasourceIdentities": [
                        {
                            "datasources": [
                                {
                                    "connectionDetails": {
                                        "account": "str",  # Optional. The
                                          connection account.
                                        "classInfo": "str",  # Optional. The
                                          connection class information.
                                        "database": "str",  # Optional. The
                                          connection database.
                                        "domain": "str",  # Optional. The
                                          connection domain.
                                        "emailAddress": "str",  # Optional.
                                          The connection email address.
                                        "kind": "str",  # Optional. The
                                          connection kind.
                                        "loginServer": "str",  # Optional.
                                          The connection login server.
                                        "path": "str",  # Optional. The
                                          connection path.
                                        "server": "str",  # Optional. The
                                          connection server.
                                        "url": "str"  # Optional. The
                                          connection URL.
                                    },
                                    "datasourceType": "str"  # The type of the
                                      `data source </power-bi/connect-data/power-bi-data-sources>`_.
                                      .. list-table::    :header-rows: 1     * - API name for the data
                                      source      -       -     * - ActiveDirectory      -
                                      AdobeAnalytics      - AdoDotNet    * - AnalysisServices      -
                                      AzureBlobs      - AzureDataLakeStorage    * - AzureMarketplace
                                      - AzureTables      - BizTalk    * - CDPA      - CustomConnector
                                      - CustomHttpApi    * - DB2      - Essbase      - EventHub    * -
                                      Excel      - Exchange      - Extension    * - Facebook      -
                                      File      - Folder    * - GoogleAnalytics      - Hdfs      -
                                      HDInsight    * - Informix      - MQ      - MySql    * - OData
                                      - ODBC      - OleDb    * - Oracle      - PostgreSql      -
                                      PowerQueryMashup     * - PubNub      - Salesforce      - SAPBW
                                      * - SAPBWMessageServer      - SapErp      - SAPHana    * -
                                      SharePoint      - SharePointDocLib      - SharePointList    * -
                                      Sql      - Sybase      - Teradata    * - UIFlow      - Web.
                                      Required.
                                }
                            ],
                            "identityBlob": "str"  # A blob for specifying the identity.
                              Required.
                        }
                    ],
                    "identities": [
                        {
                            "username": "str",  # The effective username within a token
                              that applies row-level security rules. For an on-premises model, the
                              username can contain alphanumeric or any of the following characters '.',
                              '-', '_', '!', '#', '^', '~', '""', '@'. For cloud models, the username
                              can contain any ASCII character. For either model, the username length
                              must not exceed 256 characters, and the username shouldn't contain
                              spaces. Required.
                            "customData": "str",  # Optional. `Custom data
                              </power-bi/developer/embedded/embedded-row-level-security#using-the-customdata-feature>`_
                              that's used to apply row-level security rules. Supported for live
                              connection to Azure Analysis Services models and cloud models only.
                            "datasets": [
                                "str"  # Optional. An array of datasets for which
                                  this identity applies.
                            ],
                            "identityBlob": {
                                "value": "str"  # An OAuth 2.0 access token for Azure
                                  SQL. Required.
                            },
                            "reports": [
                                "str"  # Optional. An array of reports for which this
                                  identity applies. Only supported for paginated reports.
                            ],
                            "roles": [
                                "str"  # Optional. An array of row-level security
                                  (RLS) roles within a token that applies RLS rules. An identity can
                                  contain up to 50 roles. A role can contain any character except
                                  ``,``"" , and its length must not exceed 50 characters.
                            ]
                        }
                    ],
                    "lifetimeInMinutes": 0,  # Optional. The maximum lifetime of the token in
                      minutes, starting from the time it was generated. Can be used to shorten the
                      token's expiration time, but not to extend it. The value must be a positive
                      integer. Zero ("" ``0``"" ) is equivalent to ``null``"" , and will set the
                      default expiration time.
                    "reports": [
                        {
                            "id": "str",  # The report ID. Required.
                            "allowEdit": bool  # Optional. Whether the generated embed
                              token supports report editing.
                        }
                    ],
                    "targetWorkspaces": [
                        {
                            "id": "str"  # The workspace ID. Required.
                        }
                    ]
                }

                # response body for status code(s): 200
                response == {
                    "expiration": "2020-02-20 00:00:00",  # The date and time (UTC) of token
                      expiration. Required.
                    "token": "str",  # The embed token. Required.
                    "tokenId": "str"  # The unique token ID. Through audit logs, the token ID can
                      be used to correlate operations that use the token with the generate operation.
                      Required.
                }
        """

    @overload
    async def generate_token(
        self, request_parameters: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Generates an embed token for multiple reports, datasets, and target workspaces.

        * Reports and datasets don't have to be related.
        * You can bind a report to a dataset during embedding.
        * You can only create a report in workspaces specified by the ``targetWorkspaces`` parameter.

        ..

           [!IMPORTANT]
           This API call is only relevant to the `embed for your customers
        </power-bi/developer/embed-sample-for-customers>`_ scenario. To learn more about using this
        API, see `Considerations when generating an embed token
        </power-bi/developer/embedded/generate-embed-token>`_.


        Permissions
        -----------


        * When using a service principal for authentication, refer to `Embed Power BI content with
        service principal </power-bi/developer/embed-service-principal>`_ and `Considerations and
        limitations
        </power-bi/developer/embedded/embed-service-principal#considerations-and-limitations>`_.
        * For Power BI reports with a paginated visual, include the paginated report ID in the API
        call. For more information, see `example
        </rest/api/power-bi/embed-token/generate-token#examples>`_.
        * This API call can be called by a service principal profile. For more information see:
        `Service principal profiles in Power BI Embedded
        </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        All of the following, unless a requirement doesn't apply:


        * Content.Create, required if a target workspace is specified in `GenerateTokenRequestV2
        </rest/api/power-bi/embed-token/generate-token#generatetokenrequestv2>`_.
        * Report.ReadWrite.All or Report.Read.All, required if a report is specified in
        `GenerateTokenRequestV2
        </rest/api/power-bi/embed-token/generate-token#generatetokenrequestv2>`_.
        * Report.ReadWrite.All, required if the ``allowEdit`` flag is specified for at least one report
        in `GenerateTokenRequestV2
        </rest/api/power-bi/embed-token/generate-token#generatetokenrequestv2>`_.
        * Dataset.ReadWrite.All or Dataset.Read.All

        Limitations
        -----------


        * You can only create a report in workspaces specified by the ``targetWorkspaces`` parameter.
        * All reports and datasets must reside in a **V2** workspace.
        * All target workspaces must be **V2** workspaces.
        * Maximum 50 reports.
        * Maximum 50 datasets.
        * Maximum 50 target workspaces.
        * For Azure Analysis Services or Analysis Services on-premises live connection reports,
        generating an embed token with row-level security (RLS) might not work for several minutes
        after a `rebind </rest/api/power-bi/reports/rebind-report>`_.
          :code:`<br>`:code:`<br>`.

        :param request_parameters: Generate token parameters. Required.
        :type request_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "expiration": "2020-02-20 00:00:00",  # The date and time (UTC) of token
                      expiration. Required.
                    "token": "str",  # The embed token. Required.
                    "tokenId": "str"  # The unique token ID. Through audit logs, the token ID can
                      be used to correlate operations that use the token with the generate operation.
                      Required.
                }
        """

    @distributed_trace_async
    async def generate_token(self, request_parameters: Union[JSON, IO], **kwargs: Any) -> JSON:
        """Generates an embed token for multiple reports, datasets, and target workspaces.

        * Reports and datasets don't have to be related.
        * You can bind a report to a dataset during embedding.
        * You can only create a report in workspaces specified by the ``targetWorkspaces`` parameter.

        ..

           [!IMPORTANT]
           This API call is only relevant to the `embed for your customers
        </power-bi/developer/embed-sample-for-customers>`_ scenario. To learn more about using this
        API, see `Considerations when generating an embed token
        </power-bi/developer/embedded/generate-embed-token>`_.


        Permissions
        -----------


        * When using a service principal for authentication, refer to `Embed Power BI content with
        service principal </power-bi/developer/embed-service-principal>`_ and `Considerations and
        limitations
        </power-bi/developer/embedded/embed-service-principal#considerations-and-limitations>`_.
        * For Power BI reports with a paginated visual, include the paginated report ID in the API
        call. For more information, see `example
        </rest/api/power-bi/embed-token/generate-token#examples>`_.
        * This API call can be called by a service principal profile. For more information see:
        `Service principal profiles in Power BI Embedded
        </power-bi/developer/embedded/embed-multi-tenancy>`_.

        Required Scope
        --------------

        All of the following, unless a requirement doesn't apply:


        * Content.Create, required if a target workspace is specified in `GenerateTokenRequestV2
        </rest/api/power-bi/embed-token/generate-token#generatetokenrequestv2>`_.
        * Report.ReadWrite.All or Report.Read.All, required if a report is specified in
        `GenerateTokenRequestV2
        </rest/api/power-bi/embed-token/generate-token#generatetokenrequestv2>`_.
        * Report.ReadWrite.All, required if the ``allowEdit`` flag is specified for at least one report
        in `GenerateTokenRequestV2
        </rest/api/power-bi/embed-token/generate-token#generatetokenrequestv2>`_.
        * Dataset.ReadWrite.All or Dataset.Read.All

        Limitations
        -----------


        * You can only create a report in workspaces specified by the ``targetWorkspaces`` parameter.
        * All reports and datasets must reside in a **V2** workspace.
        * All target workspaces must be **V2** workspaces.
        * Maximum 50 reports.
        * Maximum 50 datasets.
        * Maximum 50 target workspaces.
        * For Azure Analysis Services or Analysis Services on-premises live connection reports,
        generating an embed token with row-level security (RLS) might not work for several minutes
        after a `rebind </rest/api/power-bi/reports/rebind-report>`_.
          :code:`<br>`:code:`<br>`.

        :param request_parameters: Generate token parameters. Is either a JSON type or a IO type.
         Required.
        :type request_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                request_parameters = {
                    "datasets": [
                        {
                            "id": "str",  # The dataset ID. Required.
                            "xmlaPermissions": "str"  # Optional. XMLA Permissions. Known
                              values are: "Off" and "ReadOnly".
                        }
                    ],
                    "datasourceIdentities": [
                        {
                            "datasources": [
                                {
                                    "connectionDetails": {
                                        "account": "str",  # Optional. The
                                          connection account.
                                        "classInfo": "str",  # Optional. The
                                          connection class information.
                                        "database": "str",  # Optional. The
                                          connection database.
                                        "domain": "str",  # Optional. The
                                          connection domain.
                                        "emailAddress": "str",  # Optional.
                                          The connection email address.
                                        "kind": "str",  # Optional. The
                                          connection kind.
                                        "loginServer": "str",  # Optional.
                                          The connection login server.
                                        "path": "str",  # Optional. The
                                          connection path.
                                        "server": "str",  # Optional. The
                                          connection server.
                                        "url": "str"  # Optional. The
                                          connection URL.
                                    },
                                    "datasourceType": "str"  # The type of the
                                      `data source </power-bi/connect-data/power-bi-data-sources>`_.
                                      .. list-table::    :header-rows: 1     * - API name for the data
                                      source      -       -     * - ActiveDirectory      -
                                      AdobeAnalytics      - AdoDotNet    * - AnalysisServices      -
                                      AzureBlobs      - AzureDataLakeStorage    * - AzureMarketplace
                                      - AzureTables      - BizTalk    * - CDPA      - CustomConnector
                                      - CustomHttpApi    * - DB2      - Essbase      - EventHub    * -
                                      Excel      - Exchange      - Extension    * - Facebook      -
                                      File      - Folder    * - GoogleAnalytics      - Hdfs      -
                                      HDInsight    * - Informix      - MQ      - MySql    * - OData
                                      - ODBC      - OleDb    * - Oracle      - PostgreSql      -
                                      PowerQueryMashup     * - PubNub      - Salesforce      - SAPBW
                                      * - SAPBWMessageServer      - SapErp      - SAPHana    * -
                                      SharePoint      - SharePointDocLib      - SharePointList    * -
                                      Sql      - Sybase      - Teradata    * - UIFlow      - Web.
                                      Required.
                                }
                            ],
                            "identityBlob": "str"  # A blob for specifying the identity.
                              Required.
                        }
                    ],
                    "identities": [
                        {
                            "username": "str",  # The effective username within a token
                              that applies row-level security rules. For an on-premises model, the
                              username can contain alphanumeric or any of the following characters '.',
                              '-', '_', '!', '#', '^', '~', '""', '@'. For cloud models, the username
                              can contain any ASCII character. For either model, the username length
                              must not exceed 256 characters, and the username shouldn't contain
                              spaces. Required.
                            "customData": "str",  # Optional. `Custom data
                              </power-bi/developer/embedded/embedded-row-level-security#using-the-customdata-feature>`_
                              that's used to apply row-level security rules. Supported for live
                              connection to Azure Analysis Services models and cloud models only.
                            "datasets": [
                                "str"  # Optional. An array of datasets for which
                                  this identity applies.
                            ],
                            "identityBlob": {
                                "value": "str"  # An OAuth 2.0 access token for Azure
                                  SQL. Required.
                            },
                            "reports": [
                                "str"  # Optional. An array of reports for which this
                                  identity applies. Only supported for paginated reports.
                            ],
                            "roles": [
                                "str"  # Optional. An array of row-level security
                                  (RLS) roles within a token that applies RLS rules. An identity can
                                  contain up to 50 roles. A role can contain any character except
                                  ``,``"" , and its length must not exceed 50 characters.
                            ]
                        }
                    ],
                    "lifetimeInMinutes": 0,  # Optional. The maximum lifetime of the token in
                      minutes, starting from the time it was generated. Can be used to shorten the
                      token's expiration time, but not to extend it. The value must be a positive
                      integer. Zero ("" ``0``"" ) is equivalent to ``null``"" , and will set the
                      default expiration time.
                    "reports": [
                        {
                            "id": "str",  # The report ID. Required.
                            "allowEdit": bool  # Optional. Whether the generated embed
                              token supports report editing.
                        }
                    ],
                    "targetWorkspaces": [
                        {
                            "id": "str"  # The workspace ID. Required.
                        }
                    ]
                }

                # response body for status code(s): 200
                response == {
                    "expiration": "2020-02-20 00:00:00",  # The date and time (UTC) of token
                      expiration. Required.
                    "token": "str",  # The embed token. Required.
                    "tokenId": "str"  # The unique token ID. Through audit logs, the token ID can
                      be used to correlate operations that use the token with the generate operation.
                      Required.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(request_parameters, (IOBase, bytes)):
            _content = request_parameters
        else:
            _json = request_parameters

        _request = build_embed_token_generate_token_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore


class InformationProtectionOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~power_bi_client.aio.PowerBIClient`'s
        :attr:`information_protection` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    async def remove_labels_as_admin(
        self, artifacts: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Remove sensitivity labels from Power BI items (such as reports or dashboards) by item ID.

        For a usage example, see `Set or remove sensitivity labels
        </power-bi/admin/service-security-sensitivity-label-inheritance-set-remove-api>`_.

        Permissions
        -----------


        * The user must have administrator rights (such as Office 365 Global Administrator or Power BI
        Service Administrator).
        * The admin user must have sufficient `usage rights
        </azure/information-protection/configure-usage-rights>`_ to delete labels.

        Required Scope
        --------------

        Tenant.ReadWrite.All

        Limitations
        -----------


        * Maximum 25 requests per hour.
        * Each request can update up to 2,000 Power BI items.
          :code:`<br>`:code:`<br>`.

        :param artifacts: A composite of artifact ID lists for each type. Required.
        :type artifacts: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                artifacts = {
                    "dashboards": [
                        {
                            "id": "str"  # An ID in UUID format. Required.
                        }
                    ],
                    "dataflows": [
                        {
                            "id": "str"  # An ID in UUID format. Required.
                        }
                    ],
                    "datasets": [
                        {
                            "id": "str"  # An ID in string or UUID format. Required.
                        }
                    ],
                    "reports": [
                        {
                            "id": "str"  # An ID in UUID format. Required.
                        }
                    ]
                }

                # response body for status code(s): 200
                response == {
                    "dashboards": [
                        {
                            "id": "str",  # The unique ID of a Power BI item. The ID is
                              in UUID format for dashboards, reports, and dataflows; and in UUID or
                              string format for datasets. Required.
                            "status": "str"  # The status of an information protection
                              label change operation. Required. Known values are: "Failed",
                              "FailedToGetUsageRights", "InsufficientUsageRights", "NotFound", and
                              "Succeeded".
                        }
                    ],
                    "dataflows": [
                        {
                            "id": "str",  # The unique ID of a Power BI item. The ID is
                              in UUID format for dashboards, reports, and dataflows; and in UUID or
                              string format for datasets. Required.
                            "status": "str"  # The status of an information protection
                              label change operation. Required. Known values are: "Failed",
                              "FailedToGetUsageRights", "InsufficientUsageRights", "NotFound", and
                              "Succeeded".
                        }
                    ],
                    "datasets": [
                        {
                            "id": "str",  # The unique ID of a Power BI item. The ID is
                              in UUID format for dashboards, reports, and dataflows; and in UUID or
                              string format for datasets. Required.
                            "status": "str"  # The status of an information protection
                              label change operation. Required. Known values are: "Failed",
                              "FailedToGetUsageRights", "InsufficientUsageRights", "NotFound", and
                              "Succeeded".
                        }
                    ],
                    "reports": [
                        {
                            "id": "str",  # The unique ID of a Power BI item. The ID is
                              in UUID format for dashboards, reports, and dataflows; and in UUID or
                              string format for datasets. Required.
                            "status": "str"  # The status of an information protection
                              label change operation. Required. Known values are: "Failed",
                              "FailedToGetUsageRights", "InsufficientUsageRights", "NotFound", and
                              "Succeeded".
                        }
                    ]
                }
        """

    @overload
    async def remove_labels_as_admin(
        self, artifacts: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Remove sensitivity labels from Power BI items (such as reports or dashboards) by item ID.

        For a usage example, see `Set or remove sensitivity labels
        </power-bi/admin/service-security-sensitivity-label-inheritance-set-remove-api>`_.

        Permissions
        -----------


        * The user must have administrator rights (such as Office 365 Global Administrator or Power BI
        Service Administrator).
        * The admin user must have sufficient `usage rights
        </azure/information-protection/configure-usage-rights>`_ to delete labels.

        Required Scope
        --------------

        Tenant.ReadWrite.All

        Limitations
        -----------


        * Maximum 25 requests per hour.
        * Each request can update up to 2,000 Power BI items.
          :code:`<br>`:code:`<br>`.

        :param artifacts: A composite of artifact ID lists for each type. Required.
        :type artifacts: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "dashboards": [
                        {
                            "id": "str",  # The unique ID of a Power BI item. The ID is
                              in UUID format for dashboards, reports, and dataflows; and in UUID or
                              string format for datasets. Required.
                            "status": "str"  # The status of an information protection
                              label change operation. Required. Known values are: "Failed",
                              "FailedToGetUsageRights", "InsufficientUsageRights", "NotFound", and
                              "Succeeded".
                        }
                    ],
                    "dataflows": [
                        {
                            "id": "str",  # The unique ID of a Power BI item. The ID is
                              in UUID format for dashboards, reports, and dataflows; and in UUID or
                              string format for datasets. Required.
                            "status": "str"  # The status of an information protection
                              label change operation. Required. Known values are: "Failed",
                              "FailedToGetUsageRights", "InsufficientUsageRights", "NotFound", and
                              "Succeeded".
                        }
                    ],
                    "datasets": [
                        {
                            "id": "str",  # The unique ID of a Power BI item. The ID is
                              in UUID format for dashboards, reports, and dataflows; and in UUID or
                              string format for datasets. Required.
                            "status": "str"  # The status of an information protection
                              label change operation. Required. Known values are: "Failed",
                              "FailedToGetUsageRights", "InsufficientUsageRights", "NotFound", and
                              "Succeeded".
                        }
                    ],
                    "reports": [
                        {
                            "id": "str",  # The unique ID of a Power BI item. The ID is
                              in UUID format for dashboards, reports, and dataflows; and in UUID or
                              string format for datasets. Required.
                            "status": "str"  # The status of an information protection
                              label change operation. Required. Known values are: "Failed",
                              "FailedToGetUsageRights", "InsufficientUsageRights", "NotFound", and
                              "Succeeded".
                        }
                    ]
                }
        """

    @distributed_trace_async
    async def remove_labels_as_admin(self, artifacts: Union[JSON, IO], **kwargs: Any) -> JSON:
        """Remove sensitivity labels from Power BI items (such as reports or dashboards) by item ID.

        For a usage example, see `Set or remove sensitivity labels
        </power-bi/admin/service-security-sensitivity-label-inheritance-set-remove-api>`_.

        Permissions
        -----------


        * The user must have administrator rights (such as Office 365 Global Administrator or Power BI
        Service Administrator).
        * The admin user must have sufficient `usage rights
        </azure/information-protection/configure-usage-rights>`_ to delete labels.

        Required Scope
        --------------

        Tenant.ReadWrite.All

        Limitations
        -----------


        * Maximum 25 requests per hour.
        * Each request can update up to 2,000 Power BI items.
          :code:`<br>`:code:`<br>`.

        :param artifacts: A composite of artifact ID lists for each type. Is either a JSON type or a IO
         type. Required.
        :type artifacts: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                artifacts = {
                    "dashboards": [
                        {
                            "id": "str"  # An ID in UUID format. Required.
                        }
                    ],
                    "dataflows": [
                        {
                            "id": "str"  # An ID in UUID format. Required.
                        }
                    ],
                    "datasets": [
                        {
                            "id": "str"  # An ID in string or UUID format. Required.
                        }
                    ],
                    "reports": [
                        {
                            "id": "str"  # An ID in UUID format. Required.
                        }
                    ]
                }

                # response body for status code(s): 200
                response == {
                    "dashboards": [
                        {
                            "id": "str",  # The unique ID of a Power BI item. The ID is
                              in UUID format for dashboards, reports, and dataflows; and in UUID or
                              string format for datasets. Required.
                            "status": "str"  # The status of an information protection
                              label change operation. Required. Known values are: "Failed",
                              "FailedToGetUsageRights", "InsufficientUsageRights", "NotFound", and
                              "Succeeded".
                        }
                    ],
                    "dataflows": [
                        {
                            "id": "str",  # The unique ID of a Power BI item. The ID is
                              in UUID format for dashboards, reports, and dataflows; and in UUID or
                              string format for datasets. Required.
                            "status": "str"  # The status of an information protection
                              label change operation. Required. Known values are: "Failed",
                              "FailedToGetUsageRights", "InsufficientUsageRights", "NotFound", and
                              "Succeeded".
                        }
                    ],
                    "datasets": [
                        {
                            "id": "str",  # The unique ID of a Power BI item. The ID is
                              in UUID format for dashboards, reports, and dataflows; and in UUID or
                              string format for datasets. Required.
                            "status": "str"  # The status of an information protection
                              label change operation. Required. Known values are: "Failed",
                              "FailedToGetUsageRights", "InsufficientUsageRights", "NotFound", and
                              "Succeeded".
                        }
                    ],
                    "reports": [
                        {
                            "id": "str",  # The unique ID of a Power BI item. The ID is
                              in UUID format for dashboards, reports, and dataflows; and in UUID or
                              string format for datasets. Required.
                            "status": "str"  # The status of an information protection
                              label change operation. Required. Known values are: "Failed",
                              "FailedToGetUsageRights", "InsufficientUsageRights", "NotFound", and
                              "Succeeded".
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(artifacts, (IOBase, bytes)):
            _content = artifacts
        else:
            _json = artifacts

        _request = build_information_protection_remove_labels_as_admin_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def set_labels_as_admin(
        self,
        information_protection_change_label_details: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Set sensitivity labels on Power BI items (such as reports or dashboards) by item ID.

        To set a sensitivity label using this API, the admin user or the delegated user (if provided)
        must have the label included in their `label policy
        </microsoft-365/compliance/create-sensitivity-labels?view=o365-worldwide>`_. For a usage
        example, see `Set or remove sensitivity labels
        </power-bi/admin/service-security-sensitivity-label-inheritance-set-remove-api>`_.

        Permissions
        -----------


        * The user must have administrator rights (such as Office 365 Global Administrator or Power BI
        Service Administrator).
        * The admin user and the delegated user (if provided) must have sufficient `usage rights
        </azure/information-protection/configure-usage-rights>`_ to set labels.

        Required Scope
        --------------

        Tenant.ReadWrite.All

        Limitations
        -----------


        * Maximum 25 requests per hour.
        * Each request can update up to 2,000 Power BI items.
          :code:`<br>`:code:`<br>`.

        :param information_protection_change_label_details: Set label details. Required.
        :type information_protection_change_label_details: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                information_protection_change_label_details = {
                    "artifacts": {
                        "dashboards": [
                            {
                                "id": "str"  # An ID in UUID format. Required.
                            }
                        ],
                        "dataflows": [
                            {
                                "id": "str"  # An ID in UUID format. Required.
                            }
                        ],
                        "datasets": [
                            {
                                "id": "str"  # An ID in string or UUID format.
                                  Required.
                            }
                        ],
                        "reports": [
                            {
                                "id": "str"  # An ID in UUID format. Required.
                            }
                        ]
                    },
                    "labelId": "str",  # The label ID, which must be in the user's label policy.
                      Required.
                    "assignmentMethod": "str",  # Optional. Specifies whether the assigned label
                      was set by an automated process or manually. Known values are: "Standard" and
                      "Priviledged".
                    "delegatedUser": {
                        "emailAddress": "str"  # The email address of the delegated user.
                          Required.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "dashboards": [
                        {
                            "id": "str",  # The unique ID of a Power BI item. The ID is
                              in UUID format for dashboards, reports, and dataflows; and in UUID or
                              string format for datasets. Required.
                            "status": "str"  # The status of an information protection
                              label change operation. Required. Known values are: "Failed",
                              "FailedToGetUsageRights", "InsufficientUsageRights", "NotFound", and
                              "Succeeded".
                        }
                    ],
                    "dataflows": [
                        {
                            "id": "str",  # The unique ID of a Power BI item. The ID is
                              in UUID format for dashboards, reports, and dataflows; and in UUID or
                              string format for datasets. Required.
                            "status": "str"  # The status of an information protection
                              label change operation. Required. Known values are: "Failed",
                              "FailedToGetUsageRights", "InsufficientUsageRights", "NotFound", and
                              "Succeeded".
                        }
                    ],
                    "datasets": [
                        {
                            "id": "str",  # The unique ID of a Power BI item. The ID is
                              in UUID format for dashboards, reports, and dataflows; and in UUID or
                              string format for datasets. Required.
                            "status": "str"  # The status of an information protection
                              label change operation. Required. Known values are: "Failed",
                              "FailedToGetUsageRights", "InsufficientUsageRights", "NotFound", and
                              "Succeeded".
                        }
                    ],
                    "reports": [
                        {
                            "id": "str",  # The unique ID of a Power BI item. The ID is
                              in UUID format for dashboards, reports, and dataflows; and in UUID or
                              string format for datasets. Required.
                            "status": "str"  # The status of an information protection
                              label change operation. Required. Known values are: "Failed",
                              "FailedToGetUsageRights", "InsufficientUsageRights", "NotFound", and
                              "Succeeded".
                        }
                    ]
                }
        """

    @overload
    async def set_labels_as_admin(
        self, information_protection_change_label_details: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Set sensitivity labels on Power BI items (such as reports or dashboards) by item ID.

        To set a sensitivity label using this API, the admin user or the delegated user (if provided)
        must have the label included in their `label policy
        </microsoft-365/compliance/create-sensitivity-labels?view=o365-worldwide>`_. For a usage
        example, see `Set or remove sensitivity labels
        </power-bi/admin/service-security-sensitivity-label-inheritance-set-remove-api>`_.

        Permissions
        -----------


        * The user must have administrator rights (such as Office 365 Global Administrator or Power BI
        Service Administrator).
        * The admin user and the delegated user (if provided) must have sufficient `usage rights
        </azure/information-protection/configure-usage-rights>`_ to set labels.

        Required Scope
        --------------

        Tenant.ReadWrite.All

        Limitations
        -----------


        * Maximum 25 requests per hour.
        * Each request can update up to 2,000 Power BI items.
          :code:`<br>`:code:`<br>`.

        :param information_protection_change_label_details: Set label details. Required.
        :type information_protection_change_label_details: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "dashboards": [
                        {
                            "id": "str",  # The unique ID of a Power BI item. The ID is
                              in UUID format for dashboards, reports, and dataflows; and in UUID or
                              string format for datasets. Required.
                            "status": "str"  # The status of an information protection
                              label change operation. Required. Known values are: "Failed",
                              "FailedToGetUsageRights", "InsufficientUsageRights", "NotFound", and
                              "Succeeded".
                        }
                    ],
                    "dataflows": [
                        {
                            "id": "str",  # The unique ID of a Power BI item. The ID is
                              in UUID format for dashboards, reports, and dataflows; and in UUID or
                              string format for datasets. Required.
                            "status": "str"  # The status of an information protection
                              label change operation. Required. Known values are: "Failed",
                              "FailedToGetUsageRights", "InsufficientUsageRights", "NotFound", and
                              "Succeeded".
                        }
                    ],
                    "datasets": [
                        {
                            "id": "str",  # The unique ID of a Power BI item. The ID is
                              in UUID format for dashboards, reports, and dataflows; and in UUID or
                              string format for datasets. Required.
                            "status": "str"  # The status of an information protection
                              label change operation. Required. Known values are: "Failed",
                              "FailedToGetUsageRights", "InsufficientUsageRights", "NotFound", and
                              "Succeeded".
                        }
                    ],
                    "reports": [
                        {
                            "id": "str",  # The unique ID of a Power BI item. The ID is
                              in UUID format for dashboards, reports, and dataflows; and in UUID or
                              string format for datasets. Required.
                            "status": "str"  # The status of an information protection
                              label change operation. Required. Known values are: "Failed",
                              "FailedToGetUsageRights", "InsufficientUsageRights", "NotFound", and
                              "Succeeded".
                        }
                    ]
                }
        """

    @distributed_trace_async
    async def set_labels_as_admin(
        self, information_protection_change_label_details: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Set sensitivity labels on Power BI items (such as reports or dashboards) by item ID.

        To set a sensitivity label using this API, the admin user or the delegated user (if provided)
        must have the label included in their `label policy
        </microsoft-365/compliance/create-sensitivity-labels?view=o365-worldwide>`_. For a usage
        example, see `Set or remove sensitivity labels
        </power-bi/admin/service-security-sensitivity-label-inheritance-set-remove-api>`_.

        Permissions
        -----------


        * The user must have administrator rights (such as Office 365 Global Administrator or Power BI
        Service Administrator).
        * The admin user and the delegated user (if provided) must have sufficient `usage rights
        </azure/information-protection/configure-usage-rights>`_ to set labels.

        Required Scope
        --------------

        Tenant.ReadWrite.All

        Limitations
        -----------


        * Maximum 25 requests per hour.
        * Each request can update up to 2,000 Power BI items.
          :code:`<br>`:code:`<br>`.

        :param information_protection_change_label_details: Set label details. Is either a JSON type or
         a IO type. Required.
        :type information_protection_change_label_details: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                information_protection_change_label_details = {
                    "artifacts": {
                        "dashboards": [
                            {
                                "id": "str"  # An ID in UUID format. Required.
                            }
                        ],
                        "dataflows": [
                            {
                                "id": "str"  # An ID in UUID format. Required.
                            }
                        ],
                        "datasets": [
                            {
                                "id": "str"  # An ID in string or UUID format.
                                  Required.
                            }
                        ],
                        "reports": [
                            {
                                "id": "str"  # An ID in UUID format. Required.
                            }
                        ]
                    },
                    "labelId": "str",  # The label ID, which must be in the user's label policy.
                      Required.
                    "assignmentMethod": "str",  # Optional. Specifies whether the assigned label
                      was set by an automated process or manually. Known values are: "Standard" and
                      "Priviledged".
                    "delegatedUser": {
                        "emailAddress": "str"  # The email address of the delegated user.
                          Required.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "dashboards": [
                        {
                            "id": "str",  # The unique ID of a Power BI item. The ID is
                              in UUID format for dashboards, reports, and dataflows; and in UUID or
                              string format for datasets. Required.
                            "status": "str"  # The status of an information protection
                              label change operation. Required. Known values are: "Failed",
                              "FailedToGetUsageRights", "InsufficientUsageRights", "NotFound", and
                              "Succeeded".
                        }
                    ],
                    "dataflows": [
                        {
                            "id": "str",  # The unique ID of a Power BI item. The ID is
                              in UUID format for dashboards, reports, and dataflows; and in UUID or
                              string format for datasets. Required.
                            "status": "str"  # The status of an information protection
                              label change operation. Required. Known values are: "Failed",
                              "FailedToGetUsageRights", "InsufficientUsageRights", "NotFound", and
                              "Succeeded".
                        }
                    ],
                    "datasets": [
                        {
                            "id": "str",  # The unique ID of a Power BI item. The ID is
                              in UUID format for dashboards, reports, and dataflows; and in UUID or
                              string format for datasets. Required.
                            "status": "str"  # The status of an information protection
                              label change operation. Required. Known values are: "Failed",
                              "FailedToGetUsageRights", "InsufficientUsageRights", "NotFound", and
                              "Succeeded".
                        }
                    ],
                    "reports": [
                        {
                            "id": "str",  # The unique ID of a Power BI item. The ID is
                              in UUID format for dashboards, reports, and dataflows; and in UUID or
                              string format for datasets. Required.
                            "status": "str"  # The status of an information protection
                              label change operation. Required. Known values are: "Failed",
                              "FailedToGetUsageRights", "InsufficientUsageRights", "NotFound", and
                              "Succeeded".
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(information_protection_change_label_details, (IOBase, bytes)):
            _content = information_protection_change_label_details
        else:
            _json = information_protection_change_label_details

        _request = build_information_protection_set_labels_as_admin_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore


class ProfilesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~power_bi_client.aio.PowerBIClient`'s
        :attr:`profiles` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get_profiles_as_admin(
        self, *, filter: Optional[str] = None, top: Optional[int] = None, skip: Optional[int] = None, **kwargs: Any
    ) -> JSON:
        """Returns a list of service principal profiles for the organization.

        Permissions
        -----------

        The user must have administrator rights or authenticate using a service principal.

        Required Scope
        --------------

        Tenant.Read.All or Tenant.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :keyword filter: Filters the results based on a boolean condition, using 'id', 'displayName',
         or 'servicePrincipalId'. Supports only 'eq' operator. Default value is None.
        :paramtype filter: str
        :keyword top: Returns only the first n results. This parameter must be in the range of 1-5000.
         Default value is None.
        :paramtype top: int
        :keyword skip: Skips the first n results. Use with top to fetch results beyond the first 5000.
         Default value is None.
        :paramtype skip: int
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional. OData context.
                    "value": [
                        {
                            "id": "str",  # The service principal profile ID. Required.
                            "displayName": "str",  # Optional. The service principal
                              profile name.
                            "servicePrincipalId": "str"  # Optional. The service
                              principal ID.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_profiles_get_profiles_as_admin_request(
            filter=filter,
            top=top,
            skip=skip,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def delete_profile_as_admin(  # pylint: disable=inconsistent-return-statements
        self, profile_id: str, **kwargs: Any
    ) -> None:
        """Deletes the specified service principal profile.

        Permissions
        -----------

        The user must have administrator rights.

        Required Scope
        --------------

        Tenant.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param profile_id: The service principal profile ID. Required.
        :type profile_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_profiles_delete_profile_as_admin_request(
            profile_id=profile_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get_profiles(
        self, *, top: Optional[int] = None, skip: Optional[int] = None, filter: Optional[str] = None, **kwargs: Any
    ) -> JSON:
        """Returns a list of service principal profiles.

        :code:`<br/>`Returns a list of profiles that belongs to service principal caller.

        Limitations
        -----------

        Can only be called by a service principal.

        :keyword top: Returns only the first n results. Default value is None.
        :paramtype top: int
        :keyword skip: Skips the first n results. Default value is None.
        :paramtype skip: int
        :keyword filter: Get a profile by DisplayName. Default value is None.
        :paramtype filter: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "odata.context": "str",  # Optional. OData context.
                    "value": [
                        {
                            "id": "str",  # The service principal profile ID. Required.
                            "displayName": "str"  # Optional. The service principal
                              profile name.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_profiles_get_profiles_request(
            top=top,
            skip=skip,
            filter=filter,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def create_profile(
        self, create_or_update_profile_request: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Creates a new service principal profile.

        :code:`<br/>`Creates a new profile that belongs to service principal caller.

        Limitations
        -----------

        Can only be called by a service principal.

        :param create_or_update_profile_request: The create profile request. Required.
        :type create_or_update_profile_request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                create_or_update_profile_request = {
                    "displayName": "str"  # Optional. The service principal profile name.
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # The service principal profile ID. Required.
                    "displayName": "str"  # Optional. The service principal profile name.
                }
        """

    @overload
    async def create_profile(
        self, create_or_update_profile_request: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Creates a new service principal profile.

        :code:`<br/>`Creates a new profile that belongs to service principal caller.

        Limitations
        -----------

        Can only be called by a service principal.

        :param create_or_update_profile_request: The create profile request. Required.
        :type create_or_update_profile_request: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # The service principal profile ID. Required.
                    "displayName": "str"  # Optional. The service principal profile name.
                }
        """

    @distributed_trace_async
    async def create_profile(self, create_or_update_profile_request: Union[JSON, IO], **kwargs: Any) -> JSON:
        """Creates a new service principal profile.

        :code:`<br/>`Creates a new profile that belongs to service principal caller.

        Limitations
        -----------

        Can only be called by a service principal.

        :param create_or_update_profile_request: The create profile request. Is either a JSON type or a
         IO type. Required.
        :type create_or_update_profile_request: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                create_or_update_profile_request = {
                    "displayName": "str"  # Optional. The service principal profile name.
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # The service principal profile ID. Required.
                    "displayName": "str"  # Optional. The service principal profile name.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(create_or_update_profile_request, (IOBase, bytes)):
            _content = create_or_update_profile_request
        else:
            _json = create_or_update_profile_request

        _request = build_profiles_create_profile_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def get_profile(self, profile_id: str, **kwargs: Any) -> JSON:
        """Returns the specified service principal profile.

        :code:`<br/>`Returns the specified profile if it exists and belongs to service principal
        caller.

        Limitations
        -----------

        Can only be called by a service principal.

        :param profile_id: The service principal profile ID. Required.
        :type profile_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # The service principal profile ID. Required.
                    "displayName": "str"  # Optional. The service principal profile name.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_profiles_get_profile_request(
            profile_id=profile_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def update_profile(
        self,
        profile_id: str,
        create_or_update_profile_request: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Updates the specified service principal profile name.

        :code:`<br/>`Updates the specified profile name if it exists and belongs to service principal
        caller.

        Limitations
        -----------

        Can only be called by a service principal.

        :param profile_id: The service principal profile ID. Required.
        :type profile_id: str
        :param create_or_update_profile_request: The update profile request. Required.
        :type create_or_update_profile_request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                create_or_update_profile_request = {
                    "displayName": "str"  # Optional. The service principal profile name.
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # The service principal profile ID. Required.
                    "displayName": "str"  # Optional. The service principal profile name.
                }
        """

    @overload
    async def update_profile(
        self,
        profile_id: str,
        create_or_update_profile_request: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Updates the specified service principal profile name.

        :code:`<br/>`Updates the specified profile name if it exists and belongs to service principal
        caller.

        Limitations
        -----------

        Can only be called by a service principal.

        :param profile_id: The service principal profile ID. Required.
        :type profile_id: str
        :param create_or_update_profile_request: The update profile request. Required.
        :type create_or_update_profile_request: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # The service principal profile ID. Required.
                    "displayName": "str"  # Optional. The service principal profile name.
                }
        """

    @distributed_trace_async
    async def update_profile(
        self, profile_id: str, create_or_update_profile_request: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Updates the specified service principal profile name.

        :code:`<br/>`Updates the specified profile name if it exists and belongs to service principal
        caller.

        Limitations
        -----------

        Can only be called by a service principal.

        :param profile_id: The service principal profile ID. Required.
        :type profile_id: str
        :param create_or_update_profile_request: The update profile request. Is either a JSON type or a
         IO type. Required.
        :type create_or_update_profile_request: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                create_or_update_profile_request = {
                    "displayName": "str"  # Optional. The service principal profile name.
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # The service principal profile ID. Required.
                    "displayName": "str"  # Optional. The service principal profile name.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(create_or_update_profile_request, (IOBase, bytes)):
            _content = create_or_update_profile_request
        else:
            _json = create_or_update_profile_request

        _request = build_profiles_update_profile_request(
            profile_id=profile_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def delete_profile(  # pylint: disable=inconsistent-return-statements
        self, profile_id: str, **kwargs: Any
    ) -> None:
        """Deletes the specified service principal profile.

        :code:`<br/>`Deletes the specified profile if it exists and belongs to service principal
        caller.

        Limitations
        -----------

        Can only be called by a service principal.

        :param profile_id: The service principal profile ID. Required.
        :type profile_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_profiles_delete_profile_request(
            profile_id=profile_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class TemplateAppsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~power_bi_client.aio.PowerBIClient`'s
        :attr:`template_apps` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    async def create_install_ticket(
        self, request_parameters: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Generates an installation ticket for the `automated install flow
        </power-bi/connect-data/template-apps-auto-install>`_ of the specified template app.

        Permissions
        -----------

        The caller must use service principal for authentication. For more information, see `Embed
        Power BI content with service principal </power-bi/developer/embed-service-principal>`_ and
        `Considerations and limitations
        </power-bi/developer/embedded/embed-service-principal#considerations-and-limitations>`_.

        Limitations
        -----------


        * The tenant making this API call *must* own the specified template app.
        * The template app must either be published to Microsoft AppSource, or, both the ticket creator
        and the end-user installing with the ticket must have explicit access to the app.
        * All query parameters in the install ticket *must* be configured.
          :code:`<br>`:code:`<br>`.

        :param request_parameters: Create Install Ticket parameters. Required.
        :type request_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                request_parameters = {
                    "installDetails": [
                        {
                            "appId": "str",  # The unique ID of the Power BI template
                              app. Required.
                            "ownerTenantId": "str",  # The tenant ID of the Power BI
                              template app owner. Required.
                            "packageKey": "str",  # The secure key for the Power BI
                              template app version. Required.
                            "config": {
                                "configuration": {
                                    "str": "str"  # Optional. Dictionary of
                                      :code:`<string>`.
                                }
                            }
                        }
                    ]
                }

                # response body for status code(s): 200
                response == {
                    "expiration": "2020-02-20 00:00:00",  # The expiration date and time (UTC) of
                      the ticket. Required.
                    "ticket": "str",  # Install ticket. Required.
                    "ticketId": "str"  # The unique ID of an install ticket. Audit logs can be
                      used to correlate operations that use this ticket with the generate ticket
                      operation. Required.
                }
        """

    @overload
    async def create_install_ticket(
        self, request_parameters: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Generates an installation ticket for the `automated install flow
        </power-bi/connect-data/template-apps-auto-install>`_ of the specified template app.

        Permissions
        -----------

        The caller must use service principal for authentication. For more information, see `Embed
        Power BI content with service principal </power-bi/developer/embed-service-principal>`_ and
        `Considerations and limitations
        </power-bi/developer/embedded/embed-service-principal#considerations-and-limitations>`_.

        Limitations
        -----------


        * The tenant making this API call *must* own the specified template app.
        * The template app must either be published to Microsoft AppSource, or, both the ticket creator
        and the end-user installing with the ticket must have explicit access to the app.
        * All query parameters in the install ticket *must* be configured.
          :code:`<br>`:code:`<br>`.

        :param request_parameters: Create Install Ticket parameters. Required.
        :type request_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "expiration": "2020-02-20 00:00:00",  # The expiration date and time (UTC) of
                      the ticket. Required.
                    "ticket": "str",  # Install ticket. Required.
                    "ticketId": "str"  # The unique ID of an install ticket. Audit logs can be
                      used to correlate operations that use this ticket with the generate ticket
                      operation. Required.
                }
        """

    @distributed_trace_async
    async def create_install_ticket(self, request_parameters: Union[JSON, IO], **kwargs: Any) -> JSON:
        """Generates an installation ticket for the `automated install flow
        </power-bi/connect-data/template-apps-auto-install>`_ of the specified template app.

        Permissions
        -----------

        The caller must use service principal for authentication. For more information, see `Embed
        Power BI content with service principal </power-bi/developer/embed-service-principal>`_ and
        `Considerations and limitations
        </power-bi/developer/embedded/embed-service-principal#considerations-and-limitations>`_.

        Limitations
        -----------


        * The tenant making this API call *must* own the specified template app.
        * The template app must either be published to Microsoft AppSource, or, both the ticket creator
        and the end-user installing with the ticket must have explicit access to the app.
        * All query parameters in the install ticket *must* be configured.
          :code:`<br>`:code:`<br>`.

        :param request_parameters: Create Install Ticket parameters. Is either a JSON type or a IO
         type. Required.
        :type request_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                request_parameters = {
                    "installDetails": [
                        {
                            "appId": "str",  # The unique ID of the Power BI template
                              app. Required.
                            "ownerTenantId": "str",  # The tenant ID of the Power BI
                              template app owner. Required.
                            "packageKey": "str",  # The secure key for the Power BI
                              template app version. Required.
                            "config": {
                                "configuration": {
                                    "str": "str"  # Optional. Dictionary of
                                      :code:`<string>`.
                                }
                            }
                        }
                    ]
                }

                # response body for status code(s): 200
                response == {
                    "expiration": "2020-02-20 00:00:00",  # The expiration date and time (UTC) of
                      the ticket. Required.
                    "ticket": "str",  # Install ticket. Required.
                    "ticketId": "str"  # The unique ID of an install ticket. Audit logs can be
                      used to correlate operations that use this ticket with the generate ticket
                      operation. Required.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(request_parameters, (IOBase, bytes)):
            _content = request_parameters
        else:
            _json = request_parameters

        _request = build_template_apps_create_install_ticket_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore


class ScorecardsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~power_bi_client.aio.PowerBIClient`'s
        :attr:`scorecards` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def preview_get(self, group_id: str, *, top: Optional[int] = None, **kwargs: Any) -> JSON:
        """Returns a list of scorecards from a workspace.

        Required Scope
        --------------

        Dataset.Read.All or Dataset.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The unique identifier of the workspace. Required.
        :type group_id: str
        :keyword top: Returns only the first n results. Default value is None.
        :paramtype top: int
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "@odata.context": "str",  # Optional. OData context.
                    "@odata.count": 0,  # Optional.
                    "@odata.nextLink": "str",  # Optional. Link to the next page results.
                    "value": [
                        {
                            "columnSettings": [
                                {
                                    "columnId": "str",  # The ID for one of the
                                      columns on the scorecard control or scorecard Web UI page.
                                      Required. Known values are: "0", "1", "2", "3", "4", "5", and
                                      "6".
                                    "show": bool  # Whether the column should be
                                      visible on the scorecard. Required.
                                }
                            ],
                            "createdTime": "2020-02-20 00:00:00",  # Optional. The UTC
                              time at creation.
                            "datasetId": "str",  # Optional. The ID of the dataset
                              associated with the scorecard.
                            "description": "str",  # Optional. The scorecard description.
                            "goals": [
                                {
                                    "aggregations": [
                                        {
                                            "calculationTime":
                                              "2020-02-20 00:00:00",  # The UTC timestamp of the
                                              aggregation calculation. Required.
                                            "goalId": "str",  # The goal
                                              ID. Required.
                                            "id": "str",  # The
                                              aggregation ID. Required.
                                            "maxLastModifiedTime":
                                              "2020-02-20 00:00:00",  # The UTC timestamp of the latest
                                              modification to the aggregated property. Required.
                                            "scorecardId": "str",  # The
                                              scorecard ID. Required.
                                            "timestamp": "2020-02-20
                                              00:00:00",  # The UTC timestamp associated with the
                                              aggregated property. The time portion of the timestamp is
                                              zero. Required.
                                            "type": "str",  # The type of
                                              the aggregated property. Required. Known values are:
                                              "Value", "Target", "Status", "Sparkline", and "Change".
                                            "value": 0.0,  # The numeric
                                              value of the aggregated property. Required.
                                            "valueDisplayString": "str"
                                              # Optional. Optional. The alternative text representation
                                              of the aggregated property value.
                                        }
                                    ],
                                    "completionDate": "2020-02-20 00:00:00",  #
                                      Optional. The UTC timestamp for the completion date of the goal.
                                      The time portion of the timestamp is zero.
                                    "createdTime": "2020-02-20 00:00:00",  #
                                      Optional. The UTC time at creation.
                                    "datesFormatString": "str",  # Optional.
                                      datesFormatString.
                                    "description": "str",  # Optional. The goal
                                      description.
                                    "goalValues": [
                                        {
                                            "createdTime": "2020-02-20
                                              00:00:00",  # Optional. The UTC time at creation.
                                            "forecast": 0.0,  # Optional.
                                              The goal value trend forecast.
                                            "goalId": "str",  # Optional.
                                              The goal ID.
                                            "lastModifiedTime":
                                              "2020-02-20 00:00:00",  # Optional. The UTC time at last
                                              modification.
                                            "notes": [
                                                {
                                                    "body":
                                                      "str",  # Optional. The note text.
                                                    "content":
                                                      "str",  # Optional. The content of this note in
                                                      special format.
                "createdTime": "2020-02-20 00:00:00",  #
                                                      Optional. The UTC time at creation.
                                                    "goalId":
                                                      "str",  # Optional. The goal ID.
                                                    "id": "str",
                                                      # Optional. The goal value check-in note ID.
                "lastModifiedTime": "2020-02-20 00:00:00",  #
                                                      Optional. The UTC time at last modification.
                "scorecardId": "str",  # Optional. The scorecard
                                                      ID.
                "valueTimestamp": "2020-02-20 00:00:00"  #
                                                      Optional. The UTC timestamp of the goal value
                                                      check-in that this note belongs to. The time
                                                      portion of the timestamp is zero.
                                                }
                                            ],
                                            "scorecardId": "str",  #
                                              Optional. The scorecard ID.
                                            "status": 0,  # Optional. The
                                              ID of the goal status  .. list-table::    :header-rows: 1
                                              * - ID      - Description    * - 0      - Not started
                                              * - 1      - On track    * - 2      - At risk    * - 3
                                              - Behind    * - 4      - Overdue    * - 5      -
                                              Completed.
                                            "target": 0.0,  # Optional.
                                              The goal target value.
                                            "targetDisplayString": "str",
                                              # Optional. The textual representation of the goal
                                              target.
                                            "timestamp": "2020-02-20
                                              00:00:00",  # Optional. The UTC timestamp of the goal
                                              value check-in. The time portion of the timestamp is
                                              zero.
                                            "trend": 0,  # Optional. The
                                              goal value trend.
                                            "value": 0.0,  # Optional.
                                              The goal current value.
                                            "valueDisplayString": "str"
                                              # Optional. The textual representation of the current
                                              goal value.
                                        }
                                    ],
                                    "hasStatusRules": bool,  # Optional. Whether
                                      the goal has status rules defined.
                                    "id": "str",  # Optional. The goal ID.
                                    "lastModifiedTime": "2020-02-20 00:00:00",  #
                                      Optional. The UTC time at last modification.
                                    "level": 0,  # Optional. The nested level of
                                      the goal in the parent-child hierarchy of scorecard goals.
                                    "name": "str",  # Optional. The goal name.
                                    "notesCount": 0,  # Optional. notesCount.
                                    "parentId": "str",  # Optional. The ID of the
                                      parent goal, if defined.
                                    "permissions": "str",  # Optional. The goal
                                      permissions. Known values are: "None", "View",
                                      "UpdateCurrentValue", "UpdateTargetValue", "UpdateNotes",
                                      "UpdateStatus", "UpdateValues", "All", "11", "13", "15", "19",
                                      "21", "23", "25", "27", and "29".
                                    "rank": 0,  # Optional. The rank of the goal
                                      within the ordered set of sibling goals.
                                    "scorecardId": "str",  # Optional. The
                                      scorecard ID.
                                    "startDate": "2020-02-20 00:00:00",  #
                                      Optional. The UTC timestamp for the start date of the goal. The
                                      time portion of the timestamp is zero.
                                    "statusRules": {
                                        "goalObjectId": "str",  # Optional.
                                          The goal ID.
                                        "lastModifiedTime": "2020-02-20
                                          00:00:00",  # Optional. The UTC time at last modification.
                                        "rules": "str",  # Optional. The list
                                          of rules.
                                        "scorecardObjectId": "str"  #
                                          Optional. The scorecard ID.
                                    },
                                    "valuesFormatString": "str"  # Optional.
                                      valuesFormatString.
                                }
                            ],
                            "groupId": "str",  # Optional. The ID of the workspace.
                            "id": "str",  # Optional. The scorecard ID.
                            "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The
                              UTC time at last modification.
                            "name": "str",  # Optional. The scorecard name.
                            "permissions": "str",  # Optional. The scorecard permissions.
                              Known values are: "None", "Read", "Write", and "ReadWrite".
                            "provisioningStatus": "Initialized",  # Optional. Default
                              value is "Initialized". The provisioning status of the scorecard. Known
                              values are: "Initialized", "Completed", "Failed", "Deprovisioning", and
                              "Deleted".
                            "reportId": "str"  # Optional. The ID of the internal report
                              associated with the scorecard.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_scorecards_preview_get_request(
            group_id=group_id,
            top=top,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def preview_post(
        self, group_id: str, scorecard: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Creates a new scorecard.

        Required Scope
        --------------

        Dataset.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The unique identifier of the workspace. Required.
        :type group_id: str
        :param scorecard: The new scorecard properties. Required.
        :type scorecard: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                scorecard = {
                    "name": "str",  # The scorecard name. Required.
                    "description": "str",  # Optional. Optional. The scorecard description.
                    "sensitivityLabelId": "str"  # Optional. Optional. The GUID of a sensitivity
                      label. If you don't want to select a sensitivity label, use a null or empty GUID
                      ("" ``00000000-0000-0000-0000-000000000000``"" ). If default labels are enabled
                      and/or enforced, they will be applied on the scorecard and dataset.
                }

                # response body for status code(s): 200
                response == {
                    "columnSettings": [
                        {
                            "columnId": "str",  # The ID for one of the columns on the
                              scorecard control or scorecard Web UI page. Required. Known values are:
                              "0", "1", "2", "3", "4", "5", and "6".
                            "show": bool  # Whether the column should be visible on the
                              scorecard. Required.
                        }
                    ],
                    "createdTime": "2020-02-20 00:00:00",  # Optional. The UTC time at creation.
                    "datasetId": "str",  # Optional. The ID of the dataset associated with the
                      scorecard.
                    "description": "str",  # Optional. The scorecard description.
                    "goals": [
                        {
                            "aggregations": [
                                {
                                    "calculationTime": "2020-02-20 00:00:00",  #
                                      The UTC timestamp of the aggregation calculation. Required.
                                    "goalId": "str",  # The goal ID. Required.
                                    "id": "str",  # The aggregation ID. Required.
                                    "maxLastModifiedTime": "2020-02-20 00:00:00",
                                      # The UTC timestamp of the latest modification to the aggregated
                                      property. Required.
                                    "scorecardId": "str",  # The scorecard ID.
                                      Required.
                                    "timestamp": "2020-02-20 00:00:00",  # The
                                      UTC timestamp associated with the aggregated property. The time
                                      portion of the timestamp is zero. Required.
                                    "type": "str",  # The type of the aggregated
                                      property. Required. Known values are: "Value", "Target",
                                      "Status", "Sparkline", and "Change".
                                    "value": 0.0,  # The numeric value of the
                                      aggregated property. Required.
                                    "valueDisplayString": "str"  # Optional.
                                      Optional. The alternative text representation of the aggregated
                                      property value.
                                }
                            ],
                            "completionDate": "2020-02-20 00:00:00",  # Optional. The UTC
                              timestamp for the completion date of the goal. The time portion of the
                              timestamp is zero.
                            "createdTime": "2020-02-20 00:00:00",  # Optional. The UTC
                              time at creation.
                            "datesFormatString": "str",  # Optional. datesFormatString.
                            "description": "str",  # Optional. The goal description.
                            "goalValues": [
                                {
                                    "createdTime": "2020-02-20 00:00:00",  #
                                      Optional. The UTC time at creation.
                                    "forecast": 0.0,  # Optional. The goal value
                                      trend forecast.
                                    "goalId": "str",  # Optional. The goal ID.
                                    "lastModifiedTime": "2020-02-20 00:00:00",  #
                                      Optional. The UTC time at last modification.
                                    "notes": [
                                        {
                                            "body": "str",  # Optional.
                                              The note text.
                                            "content": "str",  #
                                              Optional. The content of this note in special format.
                                            "createdTime": "2020-02-20
                                              00:00:00",  # Optional. The UTC time at creation.
                                            "goalId": "str",  # Optional.
                                              The goal ID.
                                            "id": "str",  # Optional. The
                                              goal value check-in note ID.
                                            "lastModifiedTime":
                                              "2020-02-20 00:00:00",  # Optional. The UTC time at last
                                              modification.
                                            "scorecardId": "str",  #
                                              Optional. The scorecard ID.
                                            "valueTimestamp": "2020-02-20
                                              00:00:00"  # Optional. The UTC timestamp of the goal
                                              value check-in that this note belongs to. The time
                                              portion of the timestamp is zero.
                                        }
                                    ],
                                    "scorecardId": "str",  # Optional. The
                                      scorecard ID.
                                    "status": 0,  # Optional. The ID of the goal
                                      status  .. list-table::    :header-rows: 1     * - ID      -
                                      Description    * - 0      - Not started    * - 1      - On track
                                      * - 2      - At risk    * - 3      - Behind    * - 4      -
                                      Overdue    * - 5      - Completed.
                                    "target": 0.0,  # Optional. The goal target
                                      value.
                                    "targetDisplayString": "str",  # Optional.
                                      The textual representation of the goal target.
                                    "timestamp": "2020-02-20 00:00:00",  #
                                      Optional. The UTC timestamp of the goal value check-in. The time
                                      portion of the timestamp is zero.
                                    "trend": 0,  # Optional. The goal value
                                      trend.
                                    "value": 0.0,  # Optional. The goal current
                                      value.
                                    "valueDisplayString": "str"  # Optional. The
                                      textual representation of the current goal value.
                                }
                            ],
                            "hasStatusRules": bool,  # Optional. Whether the goal has
                              status rules defined.
                            "id": "str",  # Optional. The goal ID.
                            "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The
                              UTC time at last modification.
                            "level": 0,  # Optional. The nested level of the goal in the
                              parent-child hierarchy of scorecard goals.
                            "name": "str",  # Optional. The goal name.
                            "notesCount": 0,  # Optional. notesCount.
                            "parentId": "str",  # Optional. The ID of the parent goal, if
                              defined.
                            "permissions": "str",  # Optional. The goal permissions.
                              Known values are: "None", "View", "UpdateCurrentValue",
                              "UpdateTargetValue", "UpdateNotes", "UpdateStatus", "UpdateValues",
                              "All", "11", "13", "15", "19", "21", "23", "25", "27", and "29".
                            "rank": 0,  # Optional. The rank of the goal within the
                              ordered set of sibling goals.
                            "scorecardId": "str",  # Optional. The scorecard ID.
                            "startDate": "2020-02-20 00:00:00",  # Optional. The UTC
                              timestamp for the start date of the goal. The time portion of the
                              timestamp is zero.
                            "statusRules": {
                                "goalObjectId": "str",  # Optional. The goal ID.
                                "lastModifiedTime": "2020-02-20 00:00:00",  #
                                  Optional. The UTC time at last modification.
                                "rules": "str",  # Optional. The list of rules.
                                "scorecardObjectId": "str"  # Optional. The scorecard
                                  ID.
                            },
                            "valuesFormatString": "str"  # Optional. valuesFormatString.
                        }
                    ],
                    "groupId": "str",  # Optional. The ID of the workspace.
                    "id": "str",  # Optional. The scorecard ID.
                    "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The UTC time at last
                      modification.
                    "name": "str",  # Optional. The scorecard name.
                    "permissions": "str",  # Optional. The scorecard permissions. Known values
                      are: "None", "Read", "Write", and "ReadWrite".
                    "provisioningStatus": "Initialized",  # Optional. Default value is
                      "Initialized". The provisioning status of the scorecard. Known values are:
                      "Initialized", "Completed", "Failed", "Deprovisioning", and "Deleted".
                    "reportId": "str"  # Optional. The ID of the internal report associated with
                      the scorecard.
                }
        """

    @overload
    async def preview_post(
        self, group_id: str, scorecard: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Creates a new scorecard.

        Required Scope
        --------------

        Dataset.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The unique identifier of the workspace. Required.
        :type group_id: str
        :param scorecard: The new scorecard properties. Required.
        :type scorecard: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "columnSettings": [
                        {
                            "columnId": "str",  # The ID for one of the columns on the
                              scorecard control or scorecard Web UI page. Required. Known values are:
                              "0", "1", "2", "3", "4", "5", and "6".
                            "show": bool  # Whether the column should be visible on the
                              scorecard. Required.
                        }
                    ],
                    "createdTime": "2020-02-20 00:00:00",  # Optional. The UTC time at creation.
                    "datasetId": "str",  # Optional. The ID of the dataset associated with the
                      scorecard.
                    "description": "str",  # Optional. The scorecard description.
                    "goals": [
                        {
                            "aggregations": [
                                {
                                    "calculationTime": "2020-02-20 00:00:00",  #
                                      The UTC timestamp of the aggregation calculation. Required.
                                    "goalId": "str",  # The goal ID. Required.
                                    "id": "str",  # The aggregation ID. Required.
                                    "maxLastModifiedTime": "2020-02-20 00:00:00",
                                      # The UTC timestamp of the latest modification to the aggregated
                                      property. Required.
                                    "scorecardId": "str",  # The scorecard ID.
                                      Required.
                                    "timestamp": "2020-02-20 00:00:00",  # The
                                      UTC timestamp associated with the aggregated property. The time
                                      portion of the timestamp is zero. Required.
                                    "type": "str",  # The type of the aggregated
                                      property. Required. Known values are: "Value", "Target",
                                      "Status", "Sparkline", and "Change".
                                    "value": 0.0,  # The numeric value of the
                                      aggregated property. Required.
                                    "valueDisplayString": "str"  # Optional.
                                      Optional. The alternative text representation of the aggregated
                                      property value.
                                }
                            ],
                            "completionDate": "2020-02-20 00:00:00",  # Optional. The UTC
                              timestamp for the completion date of the goal. The time portion of the
                              timestamp is zero.
                            "createdTime": "2020-02-20 00:00:00",  # Optional. The UTC
                              time at creation.
                            "datesFormatString": "str",  # Optional. datesFormatString.
                            "description": "str",  # Optional. The goal description.
                            "goalValues": [
                                {
                                    "createdTime": "2020-02-20 00:00:00",  #
                                      Optional. The UTC time at creation.
                                    "forecast": 0.0,  # Optional. The goal value
                                      trend forecast.
                                    "goalId": "str",  # Optional. The goal ID.
                                    "lastModifiedTime": "2020-02-20 00:00:00",  #
                                      Optional. The UTC time at last modification.
                                    "notes": [
                                        {
                                            "body": "str",  # Optional.
                                              The note text.
                                            "content": "str",  #
                                              Optional. The content of this note in special format.
                                            "createdTime": "2020-02-20
                                              00:00:00",  # Optional. The UTC time at creation.
                                            "goalId": "str",  # Optional.
                                              The goal ID.
                                            "id": "str",  # Optional. The
                                              goal value check-in note ID.
                                            "lastModifiedTime":
                                              "2020-02-20 00:00:00",  # Optional. The UTC time at last
                                              modification.
                                            "scorecardId": "str",  #
                                              Optional. The scorecard ID.
                                            "valueTimestamp": "2020-02-20
                                              00:00:00"  # Optional. The UTC timestamp of the goal
                                              value check-in that this note belongs to. The time
                                              portion of the timestamp is zero.
                                        }
                                    ],
                                    "scorecardId": "str",  # Optional. The
                                      scorecard ID.
                                    "status": 0,  # Optional. The ID of the goal
                                      status  .. list-table::    :header-rows: 1     * - ID      -
                                      Description    * - 0      - Not started    * - 1      - On track
                                      * - 2      - At risk    * - 3      - Behind    * - 4      -
                                      Overdue    * - 5      - Completed.
                                    "target": 0.0,  # Optional. The goal target
                                      value.
                                    "targetDisplayString": "str",  # Optional.
                                      The textual representation of the goal target.
                                    "timestamp": "2020-02-20 00:00:00",  #
                                      Optional. The UTC timestamp of the goal value check-in. The time
                                      portion of the timestamp is zero.
                                    "trend": 0,  # Optional. The goal value
                                      trend.
                                    "value": 0.0,  # Optional. The goal current
                                      value.
                                    "valueDisplayString": "str"  # Optional. The
                                      textual representation of the current goal value.
                                }
                            ],
                            "hasStatusRules": bool,  # Optional. Whether the goal has
                              status rules defined.
                            "id": "str",  # Optional. The goal ID.
                            "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The
                              UTC time at last modification.
                            "level": 0,  # Optional. The nested level of the goal in the
                              parent-child hierarchy of scorecard goals.
                            "name": "str",  # Optional. The goal name.
                            "notesCount": 0,  # Optional. notesCount.
                            "parentId": "str",  # Optional. The ID of the parent goal, if
                              defined.
                            "permissions": "str",  # Optional. The goal permissions.
                              Known values are: "None", "View", "UpdateCurrentValue",
                              "UpdateTargetValue", "UpdateNotes", "UpdateStatus", "UpdateValues",
                              "All", "11", "13", "15", "19", "21", "23", "25", "27", and "29".
                            "rank": 0,  # Optional. The rank of the goal within the
                              ordered set of sibling goals.
                            "scorecardId": "str",  # Optional. The scorecard ID.
                            "startDate": "2020-02-20 00:00:00",  # Optional. The UTC
                              timestamp for the start date of the goal. The time portion of the
                              timestamp is zero.
                            "statusRules": {
                                "goalObjectId": "str",  # Optional. The goal ID.
                                "lastModifiedTime": "2020-02-20 00:00:00",  #
                                  Optional. The UTC time at last modification.
                                "rules": "str",  # Optional. The list of rules.
                                "scorecardObjectId": "str"  # Optional. The scorecard
                                  ID.
                            },
                            "valuesFormatString": "str"  # Optional. valuesFormatString.
                        }
                    ],
                    "groupId": "str",  # Optional. The ID of the workspace.
                    "id": "str",  # Optional. The scorecard ID.
                    "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The UTC time at last
                      modification.
                    "name": "str",  # Optional. The scorecard name.
                    "permissions": "str",  # Optional. The scorecard permissions. Known values
                      are: "None", "Read", "Write", and "ReadWrite".
                    "provisioningStatus": "Initialized",  # Optional. Default value is
                      "Initialized". The provisioning status of the scorecard. Known values are:
                      "Initialized", "Completed", "Failed", "Deprovisioning", and "Deleted".
                    "reportId": "str"  # Optional. The ID of the internal report associated with
                      the scorecard.
                }
        """

    @distributed_trace_async
    async def preview_post(self, group_id: str, scorecard: Union[JSON, IO], **kwargs: Any) -> JSON:
        """Creates a new scorecard.

        Required Scope
        --------------

        Dataset.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The unique identifier of the workspace. Required.
        :type group_id: str
        :param scorecard: The new scorecard properties. Is either a JSON type or a IO type. Required.
        :type scorecard: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                scorecard = {
                    "name": "str",  # The scorecard name. Required.
                    "description": "str",  # Optional. Optional. The scorecard description.
                    "sensitivityLabelId": "str"  # Optional. Optional. The GUID of a sensitivity
                      label. If you don't want to select a sensitivity label, use a null or empty GUID
                      ("" ``00000000-0000-0000-0000-000000000000``"" ). If default labels are enabled
                      and/or enforced, they will be applied on the scorecard and dataset.
                }

                # response body for status code(s): 200
                response == {
                    "columnSettings": [
                        {
                            "columnId": "str",  # The ID for one of the columns on the
                              scorecard control or scorecard Web UI page. Required. Known values are:
                              "0", "1", "2", "3", "4", "5", and "6".
                            "show": bool  # Whether the column should be visible on the
                              scorecard. Required.
                        }
                    ],
                    "createdTime": "2020-02-20 00:00:00",  # Optional. The UTC time at creation.
                    "datasetId": "str",  # Optional. The ID of the dataset associated with the
                      scorecard.
                    "description": "str",  # Optional. The scorecard description.
                    "goals": [
                        {
                            "aggregations": [
                                {
                                    "calculationTime": "2020-02-20 00:00:00",  #
                                      The UTC timestamp of the aggregation calculation. Required.
                                    "goalId": "str",  # The goal ID. Required.
                                    "id": "str",  # The aggregation ID. Required.
                                    "maxLastModifiedTime": "2020-02-20 00:00:00",
                                      # The UTC timestamp of the latest modification to the aggregated
                                      property. Required.
                                    "scorecardId": "str",  # The scorecard ID.
                                      Required.
                                    "timestamp": "2020-02-20 00:00:00",  # The
                                      UTC timestamp associated with the aggregated property. The time
                                      portion of the timestamp is zero. Required.
                                    "type": "str",  # The type of the aggregated
                                      property. Required. Known values are: "Value", "Target",
                                      "Status", "Sparkline", and "Change".
                                    "value": 0.0,  # The numeric value of the
                                      aggregated property. Required.
                                    "valueDisplayString": "str"  # Optional.
                                      Optional. The alternative text representation of the aggregated
                                      property value.
                                }
                            ],
                            "completionDate": "2020-02-20 00:00:00",  # Optional. The UTC
                              timestamp for the completion date of the goal. The time portion of the
                              timestamp is zero.
                            "createdTime": "2020-02-20 00:00:00",  # Optional. The UTC
                              time at creation.
                            "datesFormatString": "str",  # Optional. datesFormatString.
                            "description": "str",  # Optional. The goal description.
                            "goalValues": [
                                {
                                    "createdTime": "2020-02-20 00:00:00",  #
                                      Optional. The UTC time at creation.
                                    "forecast": 0.0,  # Optional. The goal value
                                      trend forecast.
                                    "goalId": "str",  # Optional. The goal ID.
                                    "lastModifiedTime": "2020-02-20 00:00:00",  #
                                      Optional. The UTC time at last modification.
                                    "notes": [
                                        {
                                            "body": "str",  # Optional.
                                              The note text.
                                            "content": "str",  #
                                              Optional. The content of this note in special format.
                                            "createdTime": "2020-02-20
                                              00:00:00",  # Optional. The UTC time at creation.
                                            "goalId": "str",  # Optional.
                                              The goal ID.
                                            "id": "str",  # Optional. The
                                              goal value check-in note ID.
                                            "lastModifiedTime":
                                              "2020-02-20 00:00:00",  # Optional. The UTC time at last
                                              modification.
                                            "scorecardId": "str",  #
                                              Optional. The scorecard ID.
                                            "valueTimestamp": "2020-02-20
                                              00:00:00"  # Optional. The UTC timestamp of the goal
                                              value check-in that this note belongs to. The time
                                              portion of the timestamp is zero.
                                        }
                                    ],
                                    "scorecardId": "str",  # Optional. The
                                      scorecard ID.
                                    "status": 0,  # Optional. The ID of the goal
                                      status  .. list-table::    :header-rows: 1     * - ID      -
                                      Description    * - 0      - Not started    * - 1      - On track
                                      * - 2      - At risk    * - 3      - Behind    * - 4      -
                                      Overdue    * - 5      - Completed.
                                    "target": 0.0,  # Optional. The goal target
                                      value.
                                    "targetDisplayString": "str",  # Optional.
                                      The textual representation of the goal target.
                                    "timestamp": "2020-02-20 00:00:00",  #
                                      Optional. The UTC timestamp of the goal value check-in. The time
                                      portion of the timestamp is zero.
                                    "trend": 0,  # Optional. The goal value
                                      trend.
                                    "value": 0.0,  # Optional. The goal current
                                      value.
                                    "valueDisplayString": "str"  # Optional. The
                                      textual representation of the current goal value.
                                }
                            ],
                            "hasStatusRules": bool,  # Optional. Whether the goal has
                              status rules defined.
                            "id": "str",  # Optional. The goal ID.
                            "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The
                              UTC time at last modification.
                            "level": 0,  # Optional. The nested level of the goal in the
                              parent-child hierarchy of scorecard goals.
                            "name": "str",  # Optional. The goal name.
                            "notesCount": 0,  # Optional. notesCount.
                            "parentId": "str",  # Optional. The ID of the parent goal, if
                              defined.
                            "permissions": "str",  # Optional. The goal permissions.
                              Known values are: "None", "View", "UpdateCurrentValue",
                              "UpdateTargetValue", "UpdateNotes", "UpdateStatus", "UpdateValues",
                              "All", "11", "13", "15", "19", "21", "23", "25", "27", and "29".
                            "rank": 0,  # Optional. The rank of the goal within the
                              ordered set of sibling goals.
                            "scorecardId": "str",  # Optional. The scorecard ID.
                            "startDate": "2020-02-20 00:00:00",  # Optional. The UTC
                              timestamp for the start date of the goal. The time portion of the
                              timestamp is zero.
                            "statusRules": {
                                "goalObjectId": "str",  # Optional. The goal ID.
                                "lastModifiedTime": "2020-02-20 00:00:00",  #
                                  Optional. The UTC time at last modification.
                                "rules": "str",  # Optional. The list of rules.
                                "scorecardObjectId": "str"  # Optional. The scorecard
                                  ID.
                            },
                            "valuesFormatString": "str"  # Optional. valuesFormatString.
                        }
                    ],
                    "groupId": "str",  # Optional. The ID of the workspace.
                    "id": "str",  # Optional. The scorecard ID.
                    "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The UTC time at last
                      modification.
                    "name": "str",  # Optional. The scorecard name.
                    "permissions": "str",  # Optional. The scorecard permissions. Known values
                      are: "None", "Read", "Write", and "ReadWrite".
                    "provisioningStatus": "Initialized",  # Optional. Default value is
                      "Initialized". The provisioning status of the scorecard. Known values are:
                      "Initialized", "Completed", "Failed", "Deprovisioning", and "Deleted".
                    "reportId": "str"  # Optional. The ID of the internal report associated with
                      the scorecard.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(scorecard, (IOBase, bytes)):
            _content = scorecard
        else:
            _json = scorecard

        _request = build_scorecards_preview_post_request(
            group_id=group_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def preview_get_by_id(
        self, group_id: str, scorecard_id: str, *, expand: Optional[str] = None, **kwargs: Any
    ) -> JSON:
        """Returns a scorecard with ID.

        Required Scope
        --------------

        Dataset.Read.All or Dataset.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The unique identifier of the workspace. Required.
        :type group_id: str
        :param scorecard_id: The unique identifier of the scorecard. Required.
        :type scorecard_id: str
        :keyword expand: Accepts a comma-separated list of data types, which will be expanded inline in
         the response. Supports ``goals``\ , ``goalValues``\ , ``aggregations``\ , and ``notes``.
         Default value is None.
        :paramtype expand: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "columnSettings": [
                        {
                            "columnId": "str",  # The ID for one of the columns on the
                              scorecard control or scorecard Web UI page. Required. Known values are:
                              "0", "1", "2", "3", "4", "5", and "6".
                            "show": bool  # Whether the column should be visible on the
                              scorecard. Required.
                        }
                    ],
                    "createdTime": "2020-02-20 00:00:00",  # Optional. The UTC time at creation.
                    "datasetId": "str",  # Optional. The ID of the dataset associated with the
                      scorecard.
                    "description": "str",  # Optional. The scorecard description.
                    "goals": [
                        {
                            "aggregations": [
                                {
                                    "calculationTime": "2020-02-20 00:00:00",  #
                                      The UTC timestamp of the aggregation calculation. Required.
                                    "goalId": "str",  # The goal ID. Required.
                                    "id": "str",  # The aggregation ID. Required.
                                    "maxLastModifiedTime": "2020-02-20 00:00:00",
                                      # The UTC timestamp of the latest modification to the aggregated
                                      property. Required.
                                    "scorecardId": "str",  # The scorecard ID.
                                      Required.
                                    "timestamp": "2020-02-20 00:00:00",  # The
                                      UTC timestamp associated with the aggregated property. The time
                                      portion of the timestamp is zero. Required.
                                    "type": "str",  # The type of the aggregated
                                      property. Required. Known values are: "Value", "Target",
                                      "Status", "Sparkline", and "Change".
                                    "value": 0.0,  # The numeric value of the
                                      aggregated property. Required.
                                    "valueDisplayString": "str"  # Optional.
                                      Optional. The alternative text representation of the aggregated
                                      property value.
                                }
                            ],
                            "completionDate": "2020-02-20 00:00:00",  # Optional. The UTC
                              timestamp for the completion date of the goal. The time portion of the
                              timestamp is zero.
                            "createdTime": "2020-02-20 00:00:00",  # Optional. The UTC
                              time at creation.
                            "datesFormatString": "str",  # Optional. datesFormatString.
                            "description": "str",  # Optional. The goal description.
                            "goalValues": [
                                {
                                    "createdTime": "2020-02-20 00:00:00",  #
                                      Optional. The UTC time at creation.
                                    "forecast": 0.0,  # Optional. The goal value
                                      trend forecast.
                                    "goalId": "str",  # Optional. The goal ID.
                                    "lastModifiedTime": "2020-02-20 00:00:00",  #
                                      Optional. The UTC time at last modification.
                                    "notes": [
                                        {
                                            "body": "str",  # Optional.
                                              The note text.
                                            "content": "str",  #
                                              Optional. The content of this note in special format.
                                            "createdTime": "2020-02-20
                                              00:00:00",  # Optional. The UTC time at creation.
                                            "goalId": "str",  # Optional.
                                              The goal ID.
                                            "id": "str",  # Optional. The
                                              goal value check-in note ID.
                                            "lastModifiedTime":
                                              "2020-02-20 00:00:00",  # Optional. The UTC time at last
                                              modification.
                                            "scorecardId": "str",  #
                                              Optional. The scorecard ID.
                                            "valueTimestamp": "2020-02-20
                                              00:00:00"  # Optional. The UTC timestamp of the goal
                                              value check-in that this note belongs to. The time
                                              portion of the timestamp is zero.
                                        }
                                    ],
                                    "scorecardId": "str",  # Optional. The
                                      scorecard ID.
                                    "status": 0,  # Optional. The ID of the goal
                                      status  .. list-table::    :header-rows: 1     * - ID      -
                                      Description    * - 0      - Not started    * - 1      - On track
                                      * - 2      - At risk    * - 3      - Behind    * - 4      -
                                      Overdue    * - 5      - Completed.
                                    "target": 0.0,  # Optional. The goal target
                                      value.
                                    "targetDisplayString": "str",  # Optional.
                                      The textual representation of the goal target.
                                    "timestamp": "2020-02-20 00:00:00",  #
                                      Optional. The UTC timestamp of the goal value check-in. The time
                                      portion of the timestamp is zero.
                                    "trend": 0,  # Optional. The goal value
                                      trend.
                                    "value": 0.0,  # Optional. The goal current
                                      value.
                                    "valueDisplayString": "str"  # Optional. The
                                      textual representation of the current goal value.
                                }
                            ],
                            "hasStatusRules": bool,  # Optional. Whether the goal has
                              status rules defined.
                            "id": "str",  # Optional. The goal ID.
                            "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The
                              UTC time at last modification.
                            "level": 0,  # Optional. The nested level of the goal in the
                              parent-child hierarchy of scorecard goals.
                            "name": "str",  # Optional. The goal name.
                            "notesCount": 0,  # Optional. notesCount.
                            "parentId": "str",  # Optional. The ID of the parent goal, if
                              defined.
                            "permissions": "str",  # Optional. The goal permissions.
                              Known values are: "None", "View", "UpdateCurrentValue",
                              "UpdateTargetValue", "UpdateNotes", "UpdateStatus", "UpdateValues",
                              "All", "11", "13", "15", "19", "21", "23", "25", "27", and "29".
                            "rank": 0,  # Optional. The rank of the goal within the
                              ordered set of sibling goals.
                            "scorecardId": "str",  # Optional. The scorecard ID.
                            "startDate": "2020-02-20 00:00:00",  # Optional. The UTC
                              timestamp for the start date of the goal. The time portion of the
                              timestamp is zero.
                            "statusRules": {
                                "goalObjectId": "str",  # Optional. The goal ID.
                                "lastModifiedTime": "2020-02-20 00:00:00",  #
                                  Optional. The UTC time at last modification.
                                "rules": "str",  # Optional. The list of rules.
                                "scorecardObjectId": "str"  # Optional. The scorecard
                                  ID.
                            },
                            "valuesFormatString": "str"  # Optional. valuesFormatString.
                        }
                    ],
                    "groupId": "str",  # Optional. The ID of the workspace.
                    "id": "str",  # Optional. The scorecard ID.
                    "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The UTC time at last
                      modification.
                    "name": "str",  # Optional. The scorecard name.
                    "permissions": "str",  # Optional. The scorecard permissions. Known values
                      are: "None", "Read", "Write", and "ReadWrite".
                    "provisioningStatus": "Initialized",  # Optional. Default value is
                      "Initialized". The provisioning status of the scorecard. Known values are:
                      "Initialized", "Completed", "Failed", "Deprovisioning", and "Deleted".
                    "reportId": "str"  # Optional. The ID of the internal report associated with
                      the scorecard.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_scorecards_preview_get_by_id_request(
            group_id=group_id,
            scorecard_id=scorecard_id,
            expand=expand,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def preview_patch_by_id(
        self,
        group_id: str,
        scorecard_id: str,
        scorecard: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Updates a scorecard by its ID.

        Required Scope
        --------------

        Dataset.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The unique identifier of the workspace. Required.
        :type group_id: str
        :param scorecard_id: The unique identifier of the scorecard. Required.
        :type scorecard_id: str
        :param scorecard: The scorecard properties to patch. Required.
        :type scorecard: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                scorecard = {
                    "columnSettings": [
                        {
                            "columnId": "str",  # The ID for one of the columns on the
                              scorecard control or scorecard Web UI page. Required. Known values are:
                              "0", "1", "2", "3", "4", "5", and "6".
                            "show": bool  # Whether the column should be visible on the
                              scorecard. Required.
                        }
                    ],
                    "createdTime": "2020-02-20 00:00:00",  # Optional. The UTC time at creation.
                    "datasetId": "str",  # Optional. The ID of the dataset associated with the
                      scorecard.
                    "description": "str",  # Optional. The scorecard description.
                    "goals": [
                        {
                            "aggregations": [
                                {
                                    "calculationTime": "2020-02-20 00:00:00",  #
                                      The UTC timestamp of the aggregation calculation. Required.
                                    "goalId": "str",  # The goal ID. Required.
                                    "id": "str",  # The aggregation ID. Required.
                                    "maxLastModifiedTime": "2020-02-20 00:00:00",
                                      # The UTC timestamp of the latest modification to the aggregated
                                      property. Required.
                                    "scorecardId": "str",  # The scorecard ID.
                                      Required.
                                    "timestamp": "2020-02-20 00:00:00",  # The
                                      UTC timestamp associated with the aggregated property. The time
                                      portion of the timestamp is zero. Required.
                                    "type": "str",  # The type of the aggregated
                                      property. Required. Known values are: "Value", "Target",
                                      "Status", "Sparkline", and "Change".
                                    "value": 0.0,  # The numeric value of the
                                      aggregated property. Required.
                                    "valueDisplayString": "str"  # Optional.
                                      Optional. The alternative text representation of the aggregated
                                      property value.
                                }
                            ],
                            "completionDate": "2020-02-20 00:00:00",  # Optional. The UTC
                              timestamp for the completion date of the goal. The time portion of the
                              timestamp is zero.
                            "createdTime": "2020-02-20 00:00:00",  # Optional. The UTC
                              time at creation.
                            "datesFormatString": "str",  # Optional. datesFormatString.
                            "description": "str",  # Optional. The goal description.
                            "goalValues": [
                                {
                                    "createdTime": "2020-02-20 00:00:00",  #
                                      Optional. The UTC time at creation.
                                    "forecast": 0.0,  # Optional. The goal value
                                      trend forecast.
                                    "goalId": "str",  # Optional. The goal ID.
                                    "lastModifiedTime": "2020-02-20 00:00:00",  #
                                      Optional. The UTC time at last modification.
                                    "notes": [
                                        {
                                            "body": "str",  # Optional.
                                              The note text.
                                            "content": "str",  #
                                              Optional. The content of this note in special format.
                                            "createdTime": "2020-02-20
                                              00:00:00",  # Optional. The UTC time at creation.
                                            "goalId": "str",  # Optional.
                                              The goal ID.
                                            "id": "str",  # Optional. The
                                              goal value check-in note ID.
                                            "lastModifiedTime":
                                              "2020-02-20 00:00:00",  # Optional. The UTC time at last
                                              modification.
                                            "scorecardId": "str",  #
                                              Optional. The scorecard ID.
                                            "valueTimestamp": "2020-02-20
                                              00:00:00"  # Optional. The UTC timestamp of the goal
                                              value check-in that this note belongs to. The time
                                              portion of the timestamp is zero.
                                        }
                                    ],
                                    "scorecardId": "str",  # Optional. The
                                      scorecard ID.
                                    "status": 0,  # Optional. The ID of the goal
                                      status  .. list-table::    :header-rows: 1     * - ID      -
                                      Description    * - 0      - Not started    * - 1      - On track
                                      * - 2      - At risk    * - 3      - Behind    * - 4      -
                                      Overdue    * - 5      - Completed.
                                    "target": 0.0,  # Optional. The goal target
                                      value.
                                    "targetDisplayString": "str",  # Optional.
                                      The textual representation of the goal target.
                                    "timestamp": "2020-02-20 00:00:00",  #
                                      Optional. The UTC timestamp of the goal value check-in. The time
                                      portion of the timestamp is zero.
                                    "trend": 0,  # Optional. The goal value
                                      trend.
                                    "value": 0.0,  # Optional. The goal current
                                      value.
                                    "valueDisplayString": "str"  # Optional. The
                                      textual representation of the current goal value.
                                }
                            ],
                            "hasStatusRules": bool,  # Optional. Whether the goal has
                              status rules defined.
                            "id": "str",  # Optional. The goal ID.
                            "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The
                              UTC time at last modification.
                            "level": 0,  # Optional. The nested level of the goal in the
                              parent-child hierarchy of scorecard goals.
                            "name": "str",  # Optional. The goal name.
                            "notesCount": 0,  # Optional. notesCount.
                            "parentId": "str",  # Optional. The ID of the parent goal, if
                              defined.
                            "permissions": "str",  # Optional. The goal permissions.
                              Known values are: "None", "View", "UpdateCurrentValue",
                              "UpdateTargetValue", "UpdateNotes", "UpdateStatus", "UpdateValues",
                              "All", "11", "13", "15", "19", "21", "23", "25", "27", and "29".
                            "rank": 0,  # Optional. The rank of the goal within the
                              ordered set of sibling goals.
                            "scorecardId": "str",  # Optional. The scorecard ID.
                            "startDate": "2020-02-20 00:00:00",  # Optional. The UTC
                              timestamp for the start date of the goal. The time portion of the
                              timestamp is zero.
                            "statusRules": {
                                "goalObjectId": "str",  # Optional. The goal ID.
                                "lastModifiedTime": "2020-02-20 00:00:00",  #
                                  Optional. The UTC time at last modification.
                                "rules": "str",  # Optional. The list of rules.
                                "scorecardObjectId": "str"  # Optional. The scorecard
                                  ID.
                            },
                            "valuesFormatString": "str"  # Optional. valuesFormatString.
                        }
                    ],
                    "groupId": "str",  # Optional. The ID of the workspace.
                    "id": "str",  # Optional. The scorecard ID.
                    "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The UTC time at last
                      modification.
                    "name": "str",  # Optional. The scorecard name.
                    "permissions": "str",  # Optional. The scorecard permissions. Known values
                      are: "None", "Read", "Write", and "ReadWrite".
                    "provisioningStatus": "Initialized",  # Optional. Default value is
                      "Initialized". The provisioning status of the scorecard. Known values are:
                      "Initialized", "Completed", "Failed", "Deprovisioning", and "Deleted".
                    "reportId": "str"  # Optional. The ID of the internal report associated with
                      the scorecard.
                }

                # response body for status code(s): 200
                response == {
                    "columnSettings": [
                        {
                            "columnId": "str",  # The ID for one of the columns on the
                              scorecard control or scorecard Web UI page. Required. Known values are:
                              "0", "1", "2", "3", "4", "5", and "6".
                            "show": bool  # Whether the column should be visible on the
                              scorecard. Required.
                        }
                    ],
                    "createdTime": "2020-02-20 00:00:00",  # Optional. The UTC time at creation.
                    "datasetId": "str",  # Optional. The ID of the dataset associated with the
                      scorecard.
                    "description": "str",  # Optional. The scorecard description.
                    "goals": [
                        {
                            "aggregations": [
                                {
                                    "calculationTime": "2020-02-20 00:00:00",  #
                                      The UTC timestamp of the aggregation calculation. Required.
                                    "goalId": "str",  # The goal ID. Required.
                                    "id": "str",  # The aggregation ID. Required.
                                    "maxLastModifiedTime": "2020-02-20 00:00:00",
                                      # The UTC timestamp of the latest modification to the aggregated
                                      property. Required.
                                    "scorecardId": "str",  # The scorecard ID.
                                      Required.
                                    "timestamp": "2020-02-20 00:00:00",  # The
                                      UTC timestamp associated with the aggregated property. The time
                                      portion of the timestamp is zero. Required.
                                    "type": "str",  # The type of the aggregated
                                      property. Required. Known values are: "Value", "Target",
                                      "Status", "Sparkline", and "Change".
                                    "value": 0.0,  # The numeric value of the
                                      aggregated property. Required.
                                    "valueDisplayString": "str"  # Optional.
                                      Optional. The alternative text representation of the aggregated
                                      property value.
                                }
                            ],
                            "completionDate": "2020-02-20 00:00:00",  # Optional. The UTC
                              timestamp for the completion date of the goal. The time portion of the
                              timestamp is zero.
                            "createdTime": "2020-02-20 00:00:00",  # Optional. The UTC
                              time at creation.
                            "datesFormatString": "str",  # Optional. datesFormatString.
                            "description": "str",  # Optional. The goal description.
                            "goalValues": [
                                {
                                    "createdTime": "2020-02-20 00:00:00",  #
                                      Optional. The UTC time at creation.
                                    "forecast": 0.0,  # Optional. The goal value
                                      trend forecast.
                                    "goalId": "str",  # Optional. The goal ID.
                                    "lastModifiedTime": "2020-02-20 00:00:00",  #
                                      Optional. The UTC time at last modification.
                                    "notes": [
                                        {
                                            "body": "str",  # Optional.
                                              The note text.
                                            "content": "str",  #
                                              Optional. The content of this note in special format.
                                            "createdTime": "2020-02-20
                                              00:00:00",  # Optional. The UTC time at creation.
                                            "goalId": "str",  # Optional.
                                              The goal ID.
                                            "id": "str",  # Optional. The
                                              goal value check-in note ID.
                                            "lastModifiedTime":
                                              "2020-02-20 00:00:00",  # Optional. The UTC time at last
                                              modification.
                                            "scorecardId": "str",  #
                                              Optional. The scorecard ID.
                                            "valueTimestamp": "2020-02-20
                                              00:00:00"  # Optional. The UTC timestamp of the goal
                                              value check-in that this note belongs to. The time
                                              portion of the timestamp is zero.
                                        }
                                    ],
                                    "scorecardId": "str",  # Optional. The
                                      scorecard ID.
                                    "status": 0,  # Optional. The ID of the goal
                                      status  .. list-table::    :header-rows: 1     * - ID      -
                                      Description    * - 0      - Not started    * - 1      - On track
                                      * - 2      - At risk    * - 3      - Behind    * - 4      -
                                      Overdue    * - 5      - Completed.
                                    "target": 0.0,  # Optional. The goal target
                                      value.
                                    "targetDisplayString": "str",  # Optional.
                                      The textual representation of the goal target.
                                    "timestamp": "2020-02-20 00:00:00",  #
                                      Optional. The UTC timestamp of the goal value check-in. The time
                                      portion of the timestamp is zero.
                                    "trend": 0,  # Optional. The goal value
                                      trend.
                                    "value": 0.0,  # Optional. The goal current
                                      value.
                                    "valueDisplayString": "str"  # Optional. The
                                      textual representation of the current goal value.
                                }
                            ],
                            "hasStatusRules": bool,  # Optional. Whether the goal has
                              status rules defined.
                            "id": "str",  # Optional. The goal ID.
                            "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The
                              UTC time at last modification.
                            "level": 0,  # Optional. The nested level of the goal in the
                              parent-child hierarchy of scorecard goals.
                            "name": "str",  # Optional. The goal name.
                            "notesCount": 0,  # Optional. notesCount.
                            "parentId": "str",  # Optional. The ID of the parent goal, if
                              defined.
                            "permissions": "str",  # Optional. The goal permissions.
                              Known values are: "None", "View", "UpdateCurrentValue",
                              "UpdateTargetValue", "UpdateNotes", "UpdateStatus", "UpdateValues",
                              "All", "11", "13", "15", "19", "21", "23", "25", "27", and "29".
                            "rank": 0,  # Optional. The rank of the goal within the
                              ordered set of sibling goals.
                            "scorecardId": "str",  # Optional. The scorecard ID.
                            "startDate": "2020-02-20 00:00:00",  # Optional. The UTC
                              timestamp for the start date of the goal. The time portion of the
                              timestamp is zero.
                            "statusRules": {
                                "goalObjectId": "str",  # Optional. The goal ID.
                                "lastModifiedTime": "2020-02-20 00:00:00",  #
                                  Optional. The UTC time at last modification.
                                "rules": "str",  # Optional. The list of rules.
                                "scorecardObjectId": "str"  # Optional. The scorecard
                                  ID.
                            },
                            "valuesFormatString": "str"  # Optional. valuesFormatString.
                        }
                    ],
                    "groupId": "str",  # Optional. The ID of the workspace.
                    "id": "str",  # Optional. The scorecard ID.
                    "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The UTC time at last
                      modification.
                    "name": "str",  # Optional. The scorecard name.
                    "permissions": "str",  # Optional. The scorecard permissions. Known values
                      are: "None", "Read", "Write", and "ReadWrite".
                    "provisioningStatus": "Initialized",  # Optional. Default value is
                      "Initialized". The provisioning status of the scorecard. Known values are:
                      "Initialized", "Completed", "Failed", "Deprovisioning", and "Deleted".
                    "reportId": "str"  # Optional. The ID of the internal report associated with
                      the scorecard.
                }
        """

    @overload
    async def preview_patch_by_id(
        self, group_id: str, scorecard_id: str, scorecard: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Updates a scorecard by its ID.

        Required Scope
        --------------

        Dataset.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The unique identifier of the workspace. Required.
        :type group_id: str
        :param scorecard_id: The unique identifier of the scorecard. Required.
        :type scorecard_id: str
        :param scorecard: The scorecard properties to patch. Required.
        :type scorecard: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "columnSettings": [
                        {
                            "columnId": "str",  # The ID for one of the columns on the
                              scorecard control or scorecard Web UI page. Required. Known values are:
                              "0", "1", "2", "3", "4", "5", and "6".
                            "show": bool  # Whether the column should be visible on the
                              scorecard. Required.
                        }
                    ],
                    "createdTime": "2020-02-20 00:00:00",  # Optional. The UTC time at creation.
                    "datasetId": "str",  # Optional. The ID of the dataset associated with the
                      scorecard.
                    "description": "str",  # Optional. The scorecard description.
                    "goals": [
                        {
                            "aggregations": [
                                {
                                    "calculationTime": "2020-02-20 00:00:00",  #
                                      The UTC timestamp of the aggregation calculation. Required.
                                    "goalId": "str",  # The goal ID. Required.
                                    "id": "str",  # The aggregation ID. Required.
                                    "maxLastModifiedTime": "2020-02-20 00:00:00",
                                      # The UTC timestamp of the latest modification to the aggregated
                                      property. Required.
                                    "scorecardId": "str",  # The scorecard ID.
                                      Required.
                                    "timestamp": "2020-02-20 00:00:00",  # The
                                      UTC timestamp associated with the aggregated property. The time
                                      portion of the timestamp is zero. Required.
                                    "type": "str",  # The type of the aggregated
                                      property. Required. Known values are: "Value", "Target",
                                      "Status", "Sparkline", and "Change".
                                    "value": 0.0,  # The numeric value of the
                                      aggregated property. Required.
                                    "valueDisplayString": "str"  # Optional.
                                      Optional. The alternative text representation of the aggregated
                                      property value.
                                }
                            ],
                            "completionDate": "2020-02-20 00:00:00",  # Optional. The UTC
                              timestamp for the completion date of the goal. The time portion of the
                              timestamp is zero.
                            "createdTime": "2020-02-20 00:00:00",  # Optional. The UTC
                              time at creation.
                            "datesFormatString": "str",  # Optional. datesFormatString.
                            "description": "str",  # Optional. The goal description.
                            "goalValues": [
                                {
                                    "createdTime": "2020-02-20 00:00:00",  #
                                      Optional. The UTC time at creation.
                                    "forecast": 0.0,  # Optional. The goal value
                                      trend forecast.
                                    "goalId": "str",  # Optional. The goal ID.
                                    "lastModifiedTime": "2020-02-20 00:00:00",  #
                                      Optional. The UTC time at last modification.
                                    "notes": [
                                        {
                                            "body": "str",  # Optional.
                                              The note text.
                                            "content": "str",  #
                                              Optional. The content of this note in special format.
                                            "createdTime": "2020-02-20
                                              00:00:00",  # Optional. The UTC time at creation.
                                            "goalId": "str",  # Optional.
                                              The goal ID.
                                            "id": "str",  # Optional. The
                                              goal value check-in note ID.
                                            "lastModifiedTime":
                                              "2020-02-20 00:00:00",  # Optional. The UTC time at last
                                              modification.
                                            "scorecardId": "str",  #
                                              Optional. The scorecard ID.
                                            "valueTimestamp": "2020-02-20
                                              00:00:00"  # Optional. The UTC timestamp of the goal
                                              value check-in that this note belongs to. The time
                                              portion of the timestamp is zero.
                                        }
                                    ],
                                    "scorecardId": "str",  # Optional. The
                                      scorecard ID.
                                    "status": 0,  # Optional. The ID of the goal
                                      status  .. list-table::    :header-rows: 1     * - ID      -
                                      Description    * - 0      - Not started    * - 1      - On track
                                      * - 2      - At risk    * - 3      - Behind    * - 4      -
                                      Overdue    * - 5      - Completed.
                                    "target": 0.0,  # Optional. The goal target
                                      value.
                                    "targetDisplayString": "str",  # Optional.
                                      The textual representation of the goal target.
                                    "timestamp": "2020-02-20 00:00:00",  #
                                      Optional. The UTC timestamp of the goal value check-in. The time
                                      portion of the timestamp is zero.
                                    "trend": 0,  # Optional. The goal value
                                      trend.
                                    "value": 0.0,  # Optional. The goal current
                                      value.
                                    "valueDisplayString": "str"  # Optional. The
                                      textual representation of the current goal value.
                                }
                            ],
                            "hasStatusRules": bool,  # Optional. Whether the goal has
                              status rules defined.
                            "id": "str",  # Optional. The goal ID.
                            "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The
                              UTC time at last modification.
                            "level": 0,  # Optional. The nested level of the goal in the
                              parent-child hierarchy of scorecard goals.
                            "name": "str",  # Optional. The goal name.
                            "notesCount": 0,  # Optional. notesCount.
                            "parentId": "str",  # Optional. The ID of the parent goal, if
                              defined.
                            "permissions": "str",  # Optional. The goal permissions.
                              Known values are: "None", "View", "UpdateCurrentValue",
                              "UpdateTargetValue", "UpdateNotes", "UpdateStatus", "UpdateValues",
                              "All", "11", "13", "15", "19", "21", "23", "25", "27", and "29".
                            "rank": 0,  # Optional. The rank of the goal within the
                              ordered set of sibling goals.
                            "scorecardId": "str",  # Optional. The scorecard ID.
                            "startDate": "2020-02-20 00:00:00",  # Optional. The UTC
                              timestamp for the start date of the goal. The time portion of the
                              timestamp is zero.
                            "statusRules": {
                                "goalObjectId": "str",  # Optional. The goal ID.
                                "lastModifiedTime": "2020-02-20 00:00:00",  #
                                  Optional. The UTC time at last modification.
                                "rules": "str",  # Optional. The list of rules.
                                "scorecardObjectId": "str"  # Optional. The scorecard
                                  ID.
                            },
                            "valuesFormatString": "str"  # Optional. valuesFormatString.
                        }
                    ],
                    "groupId": "str",  # Optional. The ID of the workspace.
                    "id": "str",  # Optional. The scorecard ID.
                    "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The UTC time at last
                      modification.
                    "name": "str",  # Optional. The scorecard name.
                    "permissions": "str",  # Optional. The scorecard permissions. Known values
                      are: "None", "Read", "Write", and "ReadWrite".
                    "provisioningStatus": "Initialized",  # Optional. Default value is
                      "Initialized". The provisioning status of the scorecard. Known values are:
                      "Initialized", "Completed", "Failed", "Deprovisioning", and "Deleted".
                    "reportId": "str"  # Optional. The ID of the internal report associated with
                      the scorecard.
                }
        """

    @distributed_trace_async
    async def preview_patch_by_id(
        self, group_id: str, scorecard_id: str, scorecard: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Updates a scorecard by its ID.

        Required Scope
        --------------

        Dataset.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The unique identifier of the workspace. Required.
        :type group_id: str
        :param scorecard_id: The unique identifier of the scorecard. Required.
        :type scorecard_id: str
        :param scorecard: The scorecard properties to patch. Is either a JSON type or a IO type.
         Required.
        :type scorecard: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                scorecard = {
                    "columnSettings": [
                        {
                            "columnId": "str",  # The ID for one of the columns on the
                              scorecard control or scorecard Web UI page. Required. Known values are:
                              "0", "1", "2", "3", "4", "5", and "6".
                            "show": bool  # Whether the column should be visible on the
                              scorecard. Required.
                        }
                    ],
                    "createdTime": "2020-02-20 00:00:00",  # Optional. The UTC time at creation.
                    "datasetId": "str",  # Optional. The ID of the dataset associated with the
                      scorecard.
                    "description": "str",  # Optional. The scorecard description.
                    "goals": [
                        {
                            "aggregations": [
                                {
                                    "calculationTime": "2020-02-20 00:00:00",  #
                                      The UTC timestamp of the aggregation calculation. Required.
                                    "goalId": "str",  # The goal ID. Required.
                                    "id": "str",  # The aggregation ID. Required.
                                    "maxLastModifiedTime": "2020-02-20 00:00:00",
                                      # The UTC timestamp of the latest modification to the aggregated
                                      property. Required.
                                    "scorecardId": "str",  # The scorecard ID.
                                      Required.
                                    "timestamp": "2020-02-20 00:00:00",  # The
                                      UTC timestamp associated with the aggregated property. The time
                                      portion of the timestamp is zero. Required.
                                    "type": "str",  # The type of the aggregated
                                      property. Required. Known values are: "Value", "Target",
                                      "Status", "Sparkline", and "Change".
                                    "value": 0.0,  # The numeric value of the
                                      aggregated property. Required.
                                    "valueDisplayString": "str"  # Optional.
                                      Optional. The alternative text representation of the aggregated
                                      property value.
                                }
                            ],
                            "completionDate": "2020-02-20 00:00:00",  # Optional. The UTC
                              timestamp for the completion date of the goal. The time portion of the
                              timestamp is zero.
                            "createdTime": "2020-02-20 00:00:00",  # Optional. The UTC
                              time at creation.
                            "datesFormatString": "str",  # Optional. datesFormatString.
                            "description": "str",  # Optional. The goal description.
                            "goalValues": [
                                {
                                    "createdTime": "2020-02-20 00:00:00",  #
                                      Optional. The UTC time at creation.
                                    "forecast": 0.0,  # Optional. The goal value
                                      trend forecast.
                                    "goalId": "str",  # Optional. The goal ID.
                                    "lastModifiedTime": "2020-02-20 00:00:00",  #
                                      Optional. The UTC time at last modification.
                                    "notes": [
                                        {
                                            "body": "str",  # Optional.
                                              The note text.
                                            "content": "str",  #
                                              Optional. The content of this note in special format.
                                            "createdTime": "2020-02-20
                                              00:00:00",  # Optional. The UTC time at creation.
                                            "goalId": "str",  # Optional.
                                              The goal ID.
                                            "id": "str",  # Optional. The
                                              goal value check-in note ID.
                                            "lastModifiedTime":
                                              "2020-02-20 00:00:00",  # Optional. The UTC time at last
                                              modification.
                                            "scorecardId": "str",  #
                                              Optional. The scorecard ID.
                                            "valueTimestamp": "2020-02-20
                                              00:00:00"  # Optional. The UTC timestamp of the goal
                                              value check-in that this note belongs to. The time
                                              portion of the timestamp is zero.
                                        }
                                    ],
                                    "scorecardId": "str",  # Optional. The
                                      scorecard ID.
                                    "status": 0,  # Optional. The ID of the goal
                                      status  .. list-table::    :header-rows: 1     * - ID      -
                                      Description    * - 0      - Not started    * - 1      - On track
                                      * - 2      - At risk    * - 3      - Behind    * - 4      -
                                      Overdue    * - 5      - Completed.
                                    "target": 0.0,  # Optional. The goal target
                                      value.
                                    "targetDisplayString": "str",  # Optional.
                                      The textual representation of the goal target.
                                    "timestamp": "2020-02-20 00:00:00",  #
                                      Optional. The UTC timestamp of the goal value check-in. The time
                                      portion of the timestamp is zero.
                                    "trend": 0,  # Optional. The goal value
                                      trend.
                                    "value": 0.0,  # Optional. The goal current
                                      value.
                                    "valueDisplayString": "str"  # Optional. The
                                      textual representation of the current goal value.
                                }
                            ],
                            "hasStatusRules": bool,  # Optional. Whether the goal has
                              status rules defined.
                            "id": "str",  # Optional. The goal ID.
                            "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The
                              UTC time at last modification.
                            "level": 0,  # Optional. The nested level of the goal in the
                              parent-child hierarchy of scorecard goals.
                            "name": "str",  # Optional. The goal name.
                            "notesCount": 0,  # Optional. notesCount.
                            "parentId": "str",  # Optional. The ID of the parent goal, if
                              defined.
                            "permissions": "str",  # Optional. The goal permissions.
                              Known values are: "None", "View", "UpdateCurrentValue",
                              "UpdateTargetValue", "UpdateNotes", "UpdateStatus", "UpdateValues",
                              "All", "11", "13", "15", "19", "21", "23", "25", "27", and "29".
                            "rank": 0,  # Optional. The rank of the goal within the
                              ordered set of sibling goals.
                            "scorecardId": "str",  # Optional. The scorecard ID.
                            "startDate": "2020-02-20 00:00:00",  # Optional. The UTC
                              timestamp for the start date of the goal. The time portion of the
                              timestamp is zero.
                            "statusRules": {
                                "goalObjectId": "str",  # Optional. The goal ID.
                                "lastModifiedTime": "2020-02-20 00:00:00",  #
                                  Optional. The UTC time at last modification.
                                "rules": "str",  # Optional. The list of rules.
                                "scorecardObjectId": "str"  # Optional. The scorecard
                                  ID.
                            },
                            "valuesFormatString": "str"  # Optional. valuesFormatString.
                        }
                    ],
                    "groupId": "str",  # Optional. The ID of the workspace.
                    "id": "str",  # Optional. The scorecard ID.
                    "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The UTC time at last
                      modification.
                    "name": "str",  # Optional. The scorecard name.
                    "permissions": "str",  # Optional. The scorecard permissions. Known values
                      are: "None", "Read", "Write", and "ReadWrite".
                    "provisioningStatus": "Initialized",  # Optional. Default value is
                      "Initialized". The provisioning status of the scorecard. Known values are:
                      "Initialized", "Completed", "Failed", "Deprovisioning", and "Deleted".
                    "reportId": "str"  # Optional. The ID of the internal report associated with
                      the scorecard.
                }

                # response body for status code(s): 200
                response == {
                    "columnSettings": [
                        {
                            "columnId": "str",  # The ID for one of the columns on the
                              scorecard control or scorecard Web UI page. Required. Known values are:
                              "0", "1", "2", "3", "4", "5", and "6".
                            "show": bool  # Whether the column should be visible on the
                              scorecard. Required.
                        }
                    ],
                    "createdTime": "2020-02-20 00:00:00",  # Optional. The UTC time at creation.
                    "datasetId": "str",  # Optional. The ID of the dataset associated with the
                      scorecard.
                    "description": "str",  # Optional. The scorecard description.
                    "goals": [
                        {
                            "aggregations": [
                                {
                                    "calculationTime": "2020-02-20 00:00:00",  #
                                      The UTC timestamp of the aggregation calculation. Required.
                                    "goalId": "str",  # The goal ID. Required.
                                    "id": "str",  # The aggregation ID. Required.
                                    "maxLastModifiedTime": "2020-02-20 00:00:00",
                                      # The UTC timestamp of the latest modification to the aggregated
                                      property. Required.
                                    "scorecardId": "str",  # The scorecard ID.
                                      Required.
                                    "timestamp": "2020-02-20 00:00:00",  # The
                                      UTC timestamp associated with the aggregated property. The time
                                      portion of the timestamp is zero. Required.
                                    "type": "str",  # The type of the aggregated
                                      property. Required. Known values are: "Value", "Target",
                                      "Status", "Sparkline", and "Change".
                                    "value": 0.0,  # The numeric value of the
                                      aggregated property. Required.
                                    "valueDisplayString": "str"  # Optional.
                                      Optional. The alternative text representation of the aggregated
                                      property value.
                                }
                            ],
                            "completionDate": "2020-02-20 00:00:00",  # Optional. The UTC
                              timestamp for the completion date of the goal. The time portion of the
                              timestamp is zero.
                            "createdTime": "2020-02-20 00:00:00",  # Optional. The UTC
                              time at creation.
                            "datesFormatString": "str",  # Optional. datesFormatString.
                            "description": "str",  # Optional. The goal description.
                            "goalValues": [
                                {
                                    "createdTime": "2020-02-20 00:00:00",  #
                                      Optional. The UTC time at creation.
                                    "forecast": 0.0,  # Optional. The goal value
                                      trend forecast.
                                    "goalId": "str",  # Optional. The goal ID.
                                    "lastModifiedTime": "2020-02-20 00:00:00",  #
                                      Optional. The UTC time at last modification.
                                    "notes": [
                                        {
                                            "body": "str",  # Optional.
                                              The note text.
                                            "content": "str",  #
                                              Optional. The content of this note in special format.
                                            "createdTime": "2020-02-20
                                              00:00:00",  # Optional. The UTC time at creation.
                                            "goalId": "str",  # Optional.
                                              The goal ID.
                                            "id": "str",  # Optional. The
                                              goal value check-in note ID.
                                            "lastModifiedTime":
                                              "2020-02-20 00:00:00",  # Optional. The UTC time at last
                                              modification.
                                            "scorecardId": "str",  #
                                              Optional. The scorecard ID.
                                            "valueTimestamp": "2020-02-20
                                              00:00:00"  # Optional. The UTC timestamp of the goal
                                              value check-in that this note belongs to. The time
                                              portion of the timestamp is zero.
                                        }
                                    ],
                                    "scorecardId": "str",  # Optional. The
                                      scorecard ID.
                                    "status": 0,  # Optional. The ID of the goal
                                      status  .. list-table::    :header-rows: 1     * - ID      -
                                      Description    * - 0      - Not started    * - 1      - On track
                                      * - 2      - At risk    * - 3      - Behind    * - 4      -
                                      Overdue    * - 5      - Completed.
                                    "target": 0.0,  # Optional. The goal target
                                      value.
                                    "targetDisplayString": "str",  # Optional.
                                      The textual representation of the goal target.
                                    "timestamp": "2020-02-20 00:00:00",  #
                                      Optional. The UTC timestamp of the goal value check-in. The time
                                      portion of the timestamp is zero.
                                    "trend": 0,  # Optional. The goal value
                                      trend.
                                    "value": 0.0,  # Optional. The goal current
                                      value.
                                    "valueDisplayString": "str"  # Optional. The
                                      textual representation of the current goal value.
                                }
                            ],
                            "hasStatusRules": bool,  # Optional. Whether the goal has
                              status rules defined.
                            "id": "str",  # Optional. The goal ID.
                            "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The
                              UTC time at last modification.
                            "level": 0,  # Optional. The nested level of the goal in the
                              parent-child hierarchy of scorecard goals.
                            "name": "str",  # Optional. The goal name.
                            "notesCount": 0,  # Optional. notesCount.
                            "parentId": "str",  # Optional. The ID of the parent goal, if
                              defined.
                            "permissions": "str",  # Optional. The goal permissions.
                              Known values are: "None", "View", "UpdateCurrentValue",
                              "UpdateTargetValue", "UpdateNotes", "UpdateStatus", "UpdateValues",
                              "All", "11", "13", "15", "19", "21", "23", "25", "27", and "29".
                            "rank": 0,  # Optional. The rank of the goal within the
                              ordered set of sibling goals.
                            "scorecardId": "str",  # Optional. The scorecard ID.
                            "startDate": "2020-02-20 00:00:00",  # Optional. The UTC
                              timestamp for the start date of the goal. The time portion of the
                              timestamp is zero.
                            "statusRules": {
                                "goalObjectId": "str",  # Optional. The goal ID.
                                "lastModifiedTime": "2020-02-20 00:00:00",  #
                                  Optional. The UTC time at last modification.
                                "rules": "str",  # Optional. The list of rules.
                                "scorecardObjectId": "str"  # Optional. The scorecard
                                  ID.
                            },
                            "valuesFormatString": "str"  # Optional. valuesFormatString.
                        }
                    ],
                    "groupId": "str",  # Optional. The ID of the workspace.
                    "id": "str",  # Optional. The scorecard ID.
                    "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The UTC time at last
                      modification.
                    "name": "str",  # Optional. The scorecard name.
                    "permissions": "str",  # Optional. The scorecard permissions. Known values
                      are: "None", "Read", "Write", and "ReadWrite".
                    "provisioningStatus": "Initialized",  # Optional. Default value is
                      "Initialized". The provisioning status of the scorecard. Known values are:
                      "Initialized", "Completed", "Failed", "Deprovisioning", and "Deleted".
                    "reportId": "str"  # Optional. The ID of the internal report associated with
                      the scorecard.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(scorecard, (IOBase, bytes)):
            _content = scorecard
        else:
            _json = scorecard

        _request = build_scorecards_preview_patch_by_id_request(
            group_id=group_id,
            scorecard_id=scorecard_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def preview_delete_by_id(  # pylint: disable=inconsistent-return-statements
        self, group_id: str, scorecard_id: str, **kwargs: Any
    ) -> None:
        """Deletes a scorecard by its ID.

        Required Scope
        --------------

        Dataset.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The unique identifier of the workspace. Required.
        :type group_id: str
        :param scorecard_id: The unique identifier of the scorecard. Required.
        :type scorecard_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_scorecards_preview_delete_by_id_request(
            group_id=group_id,
            scorecard_id=scorecard_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def preview_get_scorecard_by_report_id(
        self, group_id: str, report_id: str, *, expand: Optional[str] = None, **kwargs: Any
    ) -> JSON:
        """Reads a scorecard associated with an internal report ID.

        Required Scope
        --------------

        Dataset.Read.All or Dataset.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The unique identifier of the workspace. Required.
        :type group_id: str
        :param report_id: The ID of the internal report associated with the scorecard. Required.
        :type report_id: str
        :keyword expand: Accepts a comma-separated list of data types, which will be expanded inline in
         the response. Supports ``goals``\ , ``goalValues``\ , and ``aggregations``. Default value is
         None.
        :paramtype expand: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "columnSettings": [
                        {
                            "columnId": "str",  # The ID for one of the columns on the
                              scorecard control or scorecard Web UI page. Required. Known values are:
                              "0", "1", "2", "3", "4", "5", and "6".
                            "show": bool  # Whether the column should be visible on the
                              scorecard. Required.
                        }
                    ],
                    "createdTime": "2020-02-20 00:00:00",  # Optional. The UTC time at creation.
                    "datasetId": "str",  # Optional. The ID of the dataset associated with the
                      scorecard.
                    "description": "str",  # Optional. The scorecard description.
                    "goals": [
                        {
                            "aggregations": [
                                {
                                    "calculationTime": "2020-02-20 00:00:00",  #
                                      The UTC timestamp of the aggregation calculation. Required.
                                    "goalId": "str",  # The goal ID. Required.
                                    "id": "str",  # The aggregation ID. Required.
                                    "maxLastModifiedTime": "2020-02-20 00:00:00",
                                      # The UTC timestamp of the latest modification to the aggregated
                                      property. Required.
                                    "scorecardId": "str",  # The scorecard ID.
                                      Required.
                                    "timestamp": "2020-02-20 00:00:00",  # The
                                      UTC timestamp associated with the aggregated property. The time
                                      portion of the timestamp is zero. Required.
                                    "type": "str",  # The type of the aggregated
                                      property. Required. Known values are: "Value", "Target",
                                      "Status", "Sparkline", and "Change".
                                    "value": 0.0,  # The numeric value of the
                                      aggregated property. Required.
                                    "valueDisplayString": "str"  # Optional.
                                      Optional. The alternative text representation of the aggregated
                                      property value.
                                }
                            ],
                            "completionDate": "2020-02-20 00:00:00",  # Optional. The UTC
                              timestamp for the completion date of the goal. The time portion of the
                              timestamp is zero.
                            "createdTime": "2020-02-20 00:00:00",  # Optional. The UTC
                              time at creation.
                            "datesFormatString": "str",  # Optional. datesFormatString.
                            "description": "str",  # Optional. The goal description.
                            "goalValues": [
                                {
                                    "createdTime": "2020-02-20 00:00:00",  #
                                      Optional. The UTC time at creation.
                                    "forecast": 0.0,  # Optional. The goal value
                                      trend forecast.
                                    "goalId": "str",  # Optional. The goal ID.
                                    "lastModifiedTime": "2020-02-20 00:00:00",  #
                                      Optional. The UTC time at last modification.
                                    "notes": [
                                        {
                                            "body": "str",  # Optional.
                                              The note text.
                                            "content": "str",  #
                                              Optional. The content of this note in special format.
                                            "createdTime": "2020-02-20
                                              00:00:00",  # Optional. The UTC time at creation.
                                            "goalId": "str",  # Optional.
                                              The goal ID.
                                            "id": "str",  # Optional. The
                                              goal value check-in note ID.
                                            "lastModifiedTime":
                                              "2020-02-20 00:00:00",  # Optional. The UTC time at last
                                              modification.
                                            "scorecardId": "str",  #
                                              Optional. The scorecard ID.
                                            "valueTimestamp": "2020-02-20
                                              00:00:00"  # Optional. The UTC timestamp of the goal
                                              value check-in that this note belongs to. The time
                                              portion of the timestamp is zero.
                                        }
                                    ],
                                    "scorecardId": "str",  # Optional. The
                                      scorecard ID.
                                    "status": 0,  # Optional. The ID of the goal
                                      status  .. list-table::    :header-rows: 1     * - ID      -
                                      Description    * - 0      - Not started    * - 1      - On track
                                      * - 2      - At risk    * - 3      - Behind    * - 4      -
                                      Overdue    * - 5      - Completed.
                                    "target": 0.0,  # Optional. The goal target
                                      value.
                                    "targetDisplayString": "str",  # Optional.
                                      The textual representation of the goal target.
                                    "timestamp": "2020-02-20 00:00:00",  #
                                      Optional. The UTC timestamp of the goal value check-in. The time
                                      portion of the timestamp is zero.
                                    "trend": 0,  # Optional. The goal value
                                      trend.
                                    "value": 0.0,  # Optional. The goal current
                                      value.
                                    "valueDisplayString": "str"  # Optional. The
                                      textual representation of the current goal value.
                                }
                            ],
                            "hasStatusRules": bool,  # Optional. Whether the goal has
                              status rules defined.
                            "id": "str",  # Optional. The goal ID.
                            "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The
                              UTC time at last modification.
                            "level": 0,  # Optional. The nested level of the goal in the
                              parent-child hierarchy of scorecard goals.
                            "name": "str",  # Optional. The goal name.
                            "notesCount": 0,  # Optional. notesCount.
                            "parentId": "str",  # Optional. The ID of the parent goal, if
                              defined.
                            "permissions": "str",  # Optional. The goal permissions.
                              Known values are: "None", "View", "UpdateCurrentValue",
                              "UpdateTargetValue", "UpdateNotes", "UpdateStatus", "UpdateValues",
                              "All", "11", "13", "15", "19", "21", "23", "25", "27", and "29".
                            "rank": 0,  # Optional. The rank of the goal within the
                              ordered set of sibling goals.
                            "scorecardId": "str",  # Optional. The scorecard ID.
                            "startDate": "2020-02-20 00:00:00",  # Optional. The UTC
                              timestamp for the start date of the goal. The time portion of the
                              timestamp is zero.
                            "statusRules": {
                                "goalObjectId": "str",  # Optional. The goal ID.
                                "lastModifiedTime": "2020-02-20 00:00:00",  #
                                  Optional. The UTC time at last modification.
                                "rules": "str",  # Optional. The list of rules.
                                "scorecardObjectId": "str"  # Optional. The scorecard
                                  ID.
                            },
                            "valuesFormatString": "str"  # Optional. valuesFormatString.
                        }
                    ],
                    "groupId": "str",  # Optional. The ID of the workspace.
                    "id": "str",  # Optional. The scorecard ID.
                    "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The UTC time at last
                      modification.
                    "name": "str",  # Optional. The scorecard name.
                    "permissions": "str",  # Optional. The scorecard permissions. Known values
                      are: "None", "Read", "Write", and "ReadWrite".
                    "provisioningStatus": "Initialized",  # Optional. Default value is
                      "Initialized". The provisioning status of the scorecard. Known values are:
                      "Initialized", "Completed", "Failed", "Deprovisioning", and "Deleted".
                    "reportId": "str"  # Optional. The ID of the internal report associated with
                      the scorecard.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_scorecards_preview_get_scorecard_by_report_id_request(
            group_id=group_id,
            report_id=report_id,
            expand=expand,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def preview_move_goals(  # pylint: disable=inconsistent-return-statements
        self,
        group_id: str,
        scorecard_id: str,
        move_goals_request: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Moves goals within the scorecard. Changes their ranks and parents.

        Required Scope
        --------------

        Dataset.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The unique identifier of the workspace. Required.
        :type group_id: str
        :param scorecard_id: The unique identifier of the scorecard. Required.
        :type scorecard_id: str
        :param move_goals_request: The request describing the move operation. Required.
        :type move_goals_request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                move_goals_request = {
                    "goalToMove": {
                        "currentParentId": "str",  # Optional. The ID of the current parent
                          goal.
                        "goalId": "str"  # Optional. The goal ID.
                    },
                    "newNext": {
                        "currentParentId": "str",  # Optional. The ID of the current parent
                          goal.
                        "goalId": "str"  # Optional. The goal ID.
                    },
                    "newParent": {
                        "currentParentId": "str",  # Optional. The ID of the current parent
                          goal.
                        "goalId": "str"  # Optional. The goal ID.
                    },
                    "newPrevious": {
                        "currentParentId": "str",  # Optional. The ID of the current parent
                          goal.
                        "goalId": "str"  # Optional. The goal ID.
                    }
                }
        """

    @overload
    async def preview_move_goals(  # pylint: disable=inconsistent-return-statements
        self,
        group_id: str,
        scorecard_id: str,
        move_goals_request: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Moves goals within the scorecard. Changes their ranks and parents.

        Required Scope
        --------------

        Dataset.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The unique identifier of the workspace. Required.
        :type group_id: str
        :param scorecard_id: The unique identifier of the scorecard. Required.
        :type scorecard_id: str
        :param move_goals_request: The request describing the move operation. Required.
        :type move_goals_request: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def preview_move_goals(  # pylint: disable=inconsistent-return-statements
        self, group_id: str, scorecard_id: str, move_goals_request: Union[JSON, IO], **kwargs: Any
    ) -> None:
        """Moves goals within the scorecard. Changes their ranks and parents.

        Required Scope
        --------------

        Dataset.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The unique identifier of the workspace. Required.
        :type group_id: str
        :param scorecard_id: The unique identifier of the scorecard. Required.
        :type scorecard_id: str
        :param move_goals_request: The request describing the move operation. Is either a JSON type or
         a IO type. Required.
        :type move_goals_request: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                move_goals_request = {
                    "goalToMove": {
                        "currentParentId": "str",  # Optional. The ID of the current parent
                          goal.
                        "goalId": "str"  # Optional. The goal ID.
                    },
                    "newNext": {
                        "currentParentId": "str",  # Optional. The ID of the current parent
                          goal.
                        "goalId": "str"  # Optional. The goal ID.
                    },
                    "newParent": {
                        "currentParentId": "str",  # Optional. The ID of the current parent
                          goal.
                        "goalId": "str"  # Optional. The goal ID.
                    },
                    "newPrevious": {
                        "currentParentId": "str",  # Optional. The ID of the current parent
                          goal.
                        "goalId": "str"  # Optional. The goal ID.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(move_goals_request, (IOBase, bytes)):
            _content = move_goals_request
        else:
            _json = move_goals_request

        _request = build_scorecards_preview_move_goals_request(
            group_id=group_id,
            scorecard_id=scorecard_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class GoalsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~power_bi_client.aio.PowerBIClient`'s
        :attr:`goals` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def preview_get(
        self,
        group_id: str,
        scorecard_id: str,
        *,
        expand: Optional[str] = None,
        select: Optional[str] = None,
        **kwargs: Any
    ) -> JSON:
        """Returns a list of goals from a scorecard.

        Required Scope
        --------------

        Dataset.Read.All or Dataset.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The unique identifier of the workspace. Required.
        :type group_id: str
        :param scorecard_id: The unique identifier of the scorecard. Required.
        :type scorecard_id: str
        :keyword expand: Accepts a comma-separated list of data types, which will be expanded inline in
         the response. Supports ``goalValues`` and ``aggregations``. Default value is None.
        :paramtype expand: str
        :keyword select: Allows the clients to select specific properties from the server. Default
         value is None.
        :paramtype select: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "@odata.context": "str",  # Optional. OData context.
                    "value": [
                        {
                            "aggregations": [
                                {
                                    "calculationTime": "2020-02-20 00:00:00",  #
                                      The UTC timestamp of the aggregation calculation. Required.
                                    "goalId": "str",  # The goal ID. Required.
                                    "id": "str",  # The aggregation ID. Required.
                                    "maxLastModifiedTime": "2020-02-20 00:00:00",
                                      # The UTC timestamp of the latest modification to the aggregated
                                      property. Required.
                                    "scorecardId": "str",  # The scorecard ID.
                                      Required.
                                    "timestamp": "2020-02-20 00:00:00",  # The
                                      UTC timestamp associated with the aggregated property. The time
                                      portion of the timestamp is zero. Required.
                                    "type": "str",  # The type of the aggregated
                                      property. Required. Known values are: "Value", "Target",
                                      "Status", "Sparkline", and "Change".
                                    "value": 0.0,  # The numeric value of the
                                      aggregated property. Required.
                                    "valueDisplayString": "str"  # Optional.
                                      Optional. The alternative text representation of the aggregated
                                      property value.
                                }
                            ],
                            "completionDate": "2020-02-20 00:00:00",  # Optional. The UTC
                              timestamp for the completion date of the goal. The time portion of the
                              timestamp is zero.
                            "createdTime": "2020-02-20 00:00:00",  # Optional. The UTC
                              time at creation.
                            "datesFormatString": "str",  # Optional. datesFormatString.
                            "description": "str",  # Optional. The goal description.
                            "goalValues": [
                                {
                                    "createdTime": "2020-02-20 00:00:00",  #
                                      Optional. The UTC time at creation.
                                    "forecast": 0.0,  # Optional. The goal value
                                      trend forecast.
                                    "goalId": "str",  # Optional. The goal ID.
                                    "lastModifiedTime": "2020-02-20 00:00:00",  #
                                      Optional. The UTC time at last modification.
                                    "notes": [
                                        {
                                            "body": "str",  # Optional.
                                              The note text.
                                            "content": "str",  #
                                              Optional. The content of this note in special format.
                                            "createdTime": "2020-02-20
                                              00:00:00",  # Optional. The UTC time at creation.
                                            "goalId": "str",  # Optional.
                                              The goal ID.
                                            "id": "str",  # Optional. The
                                              goal value check-in note ID.
                                            "lastModifiedTime":
                                              "2020-02-20 00:00:00",  # Optional. The UTC time at last
                                              modification.
                                            "scorecardId": "str",  #
                                              Optional. The scorecard ID.
                                            "valueTimestamp": "2020-02-20
                                              00:00:00"  # Optional. The UTC timestamp of the goal
                                              value check-in that this note belongs to. The time
                                              portion of the timestamp is zero.
                                        }
                                    ],
                                    "scorecardId": "str",  # Optional. The
                                      scorecard ID.
                                    "status": 0,  # Optional. The ID of the goal
                                      status  .. list-table::    :header-rows: 1     * - ID      -
                                      Description    * - 0      - Not started    * - 1      - On track
                                      * - 2      - At risk    * - 3      - Behind    * - 4      -
                                      Overdue    * - 5      - Completed.
                                    "target": 0.0,  # Optional. The goal target
                                      value.
                                    "targetDisplayString": "str",  # Optional.
                                      The textual representation of the goal target.
                                    "timestamp": "2020-02-20 00:00:00",  #
                                      Optional. The UTC timestamp of the goal value check-in. The time
                                      portion of the timestamp is zero.
                                    "trend": 0,  # Optional. The goal value
                                      trend.
                                    "value": 0.0,  # Optional. The goal current
                                      value.
                                    "valueDisplayString": "str"  # Optional. The
                                      textual representation of the current goal value.
                                }
                            ],
                            "hasStatusRules": bool,  # Optional. Whether the goal has
                              status rules defined.
                            "id": "str",  # Optional. The goal ID.
                            "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The
                              UTC time at last modification.
                            "level": 0,  # Optional. The nested level of the goal in the
                              parent-child hierarchy of scorecard goals.
                            "name": "str",  # Optional. The goal name.
                            "notesCount": 0,  # Optional. notesCount.
                            "parentId": "str",  # Optional. The ID of the parent goal, if
                              defined.
                            "permissions": "str",  # Optional. The goal permissions.
                              Known values are: "None", "View", "UpdateCurrentValue",
                              "UpdateTargetValue", "UpdateNotes", "UpdateStatus", "UpdateValues",
                              "All", "11", "13", "15", "19", "21", "23", "25", "27", and "29".
                            "rank": 0,  # Optional. The rank of the goal within the
                              ordered set of sibling goals.
                            "scorecardId": "str",  # Optional. The scorecard ID.
                            "startDate": "2020-02-20 00:00:00",  # Optional. The UTC
                              timestamp for the start date of the goal. The time portion of the
                              timestamp is zero.
                            "statusRules": {
                                "goalObjectId": "str",  # Optional. The goal ID.
                                "lastModifiedTime": "2020-02-20 00:00:00",  #
                                  Optional. The UTC time at last modification.
                                "rules": "str",  # Optional. The list of rules.
                                "scorecardObjectId": "str"  # Optional. The scorecard
                                  ID.
                            },
                            "valuesFormatString": "str"  # Optional. valuesFormatString.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_goals_preview_get_request(
            group_id=group_id,
            scorecard_id=scorecard_id,
            expand=expand,
            select=select,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def preview_post(
        self, group_id: str, scorecard_id: str, goal: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Adds a new goal to a scorecard.

        Required Scope
        --------------

        Dataset.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The unique identifier of the workspace. Required.
        :type group_id: str
        :param scorecard_id: The unique identifier of the scorecard. Required.
        :type scorecard_id: str
        :param goal: The properties of the new goal. Required.
        :type goal: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                goal = {
                    "name": "str",  # The goal name. Required.
                    "completionDate": "2020-02-20 00:00:00",  # Optional. Optional. The UTC
                      timestamp for the completion date of the goal. The time portion of the timestamp
                      is zero.
                    "datesFormatString": "str",  # Optional. Optional. The `custom format string
                      </power-bi/create-reports/desktop-custom-format-strings>`_ for dates.
                    "parentId": "str",  # Optional. Optional. The ID of the parent goal, if
                      defined.
                    "startDate": "2020-02-20 00:00:00",  # Optional. Optional. The UTC timestamp
                      for the start date of the goal. The time portion of the timestamp is zero.
                    "valuesFormatString": "str"  # Optional. Optional. The `custom format string
                      </power-bi/create-reports/desktop-custom-format-strings>`_ for values.
                }

                # response body for status code(s): 200
                response == {
                    "aggregations": [
                        {
                            "calculationTime": "2020-02-20 00:00:00",  # The UTC
                              timestamp of the aggregation calculation. Required.
                            "goalId": "str",  # The goal ID. Required.
                            "id": "str",  # The aggregation ID. Required.
                            "maxLastModifiedTime": "2020-02-20 00:00:00",  # The UTC
                              timestamp of the latest modification to the aggregated property.
                              Required.
                            "scorecardId": "str",  # The scorecard ID. Required.
                            "timestamp": "2020-02-20 00:00:00",  # The UTC timestamp
                              associated with the aggregated property. The time portion of the
                              timestamp is zero. Required.
                            "type": "str",  # The type of the aggregated property.
                              Required. Known values are: "Value", "Target", "Status", "Sparkline", and
                              "Change".
                            "value": 0.0,  # The numeric value of the aggregated
                              property. Required.
                            "valueDisplayString": "str"  # Optional. Optional. The
                              alternative text representation of the aggregated property value.
                        }
                    ],
                    "completionDate": "2020-02-20 00:00:00",  # Optional. The UTC timestamp for
                      the completion date of the goal. The time portion of the timestamp is zero.
                    "createdTime": "2020-02-20 00:00:00",  # Optional. The UTC time at creation.
                    "datesFormatString": "str",  # Optional. datesFormatString.
                    "description": "str",  # Optional. The goal description.
                    "goalValues": [
                        {
                            "createdTime": "2020-02-20 00:00:00",  # Optional. The UTC
                              time at creation.
                            "forecast": 0.0,  # Optional. The goal value trend forecast.
                            "goalId": "str",  # Optional. The goal ID.
                            "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The
                              UTC time at last modification.
                            "notes": [
                                {
                                    "body": "str",  # Optional. The note text.
                                    "content": "str",  # Optional. The content of
                                      this note in special format.
                                    "createdTime": "2020-02-20 00:00:00",  #
                                      Optional. The UTC time at creation.
                                    "goalId": "str",  # Optional. The goal ID.
                                    "id": "str",  # Optional. The goal value
                                      check-in note ID.
                                    "lastModifiedTime": "2020-02-20 00:00:00",  #
                                      Optional. The UTC time at last modification.
                                    "scorecardId": "str",  # Optional. The
                                      scorecard ID.
                                    "valueTimestamp": "2020-02-20 00:00:00"  #
                                      Optional. The UTC timestamp of the goal value check-in that this
                                      note belongs to. The time portion of the timestamp is zero.
                                }
                            ],
                            "scorecardId": "str",  # Optional. The scorecard ID.
                            "status": 0,  # Optional. The ID of the goal status  ..
                              list-table::    :header-rows: 1     * - ID      - Description    * - 0
                              - Not started    * - 1      - On track    * - 2      - At risk    * - 3
                              - Behind    * - 4      - Overdue    * - 5      - Completed.
                            "target": 0.0,  # Optional. The goal target value.
                            "targetDisplayString": "str",  # Optional. The textual
                              representation of the goal target.
                            "timestamp": "2020-02-20 00:00:00",  # Optional. The UTC
                              timestamp of the goal value check-in. The time portion of the timestamp
                              is zero.
                            "trend": 0,  # Optional. The goal value trend.
                            "value": 0.0,  # Optional. The goal current value.
                            "valueDisplayString": "str"  # Optional. The textual
                              representation of the current goal value.
                        }
                    ],
                    "hasStatusRules": bool,  # Optional. Whether the goal has status rules
                      defined.
                    "id": "str",  # Optional. The goal ID.
                    "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The UTC time at last
                      modification.
                    "level": 0,  # Optional. The nested level of the goal in the parent-child
                      hierarchy of scorecard goals.
                    "name": "str",  # Optional. The goal name.
                    "notesCount": 0,  # Optional. notesCount.
                    "parentId": "str",  # Optional. The ID of the parent goal, if defined.
                    "permissions": "str",  # Optional. The goal permissions. Known values are:
                      "None", "View", "UpdateCurrentValue", "UpdateTargetValue", "UpdateNotes",
                      "UpdateStatus", "UpdateValues", "All", "11", "13", "15", "19", "21", "23", "25",
                      "27", and "29".
                    "rank": 0,  # Optional. The rank of the goal within the ordered set of
                      sibling goals.
                    "scorecardId": "str",  # Optional. The scorecard ID.
                    "startDate": "2020-02-20 00:00:00",  # Optional. The UTC timestamp for the
                      start date of the goal. The time portion of the timestamp is zero.
                    "statusRules": {
                        "goalObjectId": "str",  # Optional. The goal ID.
                        "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The UTC time
                          at last modification.
                        "rules": "str",  # Optional. The list of rules.
                        "scorecardObjectId": "str"  # Optional. The scorecard ID.
                    },
                    "valuesFormatString": "str"  # Optional. valuesFormatString.
                }
        """

    @overload
    async def preview_post(
        self, group_id: str, scorecard_id: str, goal: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Adds a new goal to a scorecard.

        Required Scope
        --------------

        Dataset.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The unique identifier of the workspace. Required.
        :type group_id: str
        :param scorecard_id: The unique identifier of the scorecard. Required.
        :type scorecard_id: str
        :param goal: The properties of the new goal. Required.
        :type goal: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "aggregations": [
                        {
                            "calculationTime": "2020-02-20 00:00:00",  # The UTC
                              timestamp of the aggregation calculation. Required.
                            "goalId": "str",  # The goal ID. Required.
                            "id": "str",  # The aggregation ID. Required.
                            "maxLastModifiedTime": "2020-02-20 00:00:00",  # The UTC
                              timestamp of the latest modification to the aggregated property.
                              Required.
                            "scorecardId": "str",  # The scorecard ID. Required.
                            "timestamp": "2020-02-20 00:00:00",  # The UTC timestamp
                              associated with the aggregated property. The time portion of the
                              timestamp is zero. Required.
                            "type": "str",  # The type of the aggregated property.
                              Required. Known values are: "Value", "Target", "Status", "Sparkline", and
                              "Change".
                            "value": 0.0,  # The numeric value of the aggregated
                              property. Required.
                            "valueDisplayString": "str"  # Optional. Optional. The
                              alternative text representation of the aggregated property value.
                        }
                    ],
                    "completionDate": "2020-02-20 00:00:00",  # Optional. The UTC timestamp for
                      the completion date of the goal. The time portion of the timestamp is zero.
                    "createdTime": "2020-02-20 00:00:00",  # Optional. The UTC time at creation.
                    "datesFormatString": "str",  # Optional. datesFormatString.
                    "description": "str",  # Optional. The goal description.
                    "goalValues": [
                        {
                            "createdTime": "2020-02-20 00:00:00",  # Optional. The UTC
                              time at creation.
                            "forecast": 0.0,  # Optional. The goal value trend forecast.
                            "goalId": "str",  # Optional. The goal ID.
                            "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The
                              UTC time at last modification.
                            "notes": [
                                {
                                    "body": "str",  # Optional. The note text.
                                    "content": "str",  # Optional. The content of
                                      this note in special format.
                                    "createdTime": "2020-02-20 00:00:00",  #
                                      Optional. The UTC time at creation.
                                    "goalId": "str",  # Optional. The goal ID.
                                    "id": "str",  # Optional. The goal value
                                      check-in note ID.
                                    "lastModifiedTime": "2020-02-20 00:00:00",  #
                                      Optional. The UTC time at last modification.
                                    "scorecardId": "str",  # Optional. The
                                      scorecard ID.
                                    "valueTimestamp": "2020-02-20 00:00:00"  #
                                      Optional. The UTC timestamp of the goal value check-in that this
                                      note belongs to. The time portion of the timestamp is zero.
                                }
                            ],
                            "scorecardId": "str",  # Optional. The scorecard ID.
                            "status": 0,  # Optional. The ID of the goal status  ..
                              list-table::    :header-rows: 1     * - ID      - Description    * - 0
                              - Not started    * - 1      - On track    * - 2      - At risk    * - 3
                              - Behind    * - 4      - Overdue    * - 5      - Completed.
                            "target": 0.0,  # Optional. The goal target value.
                            "targetDisplayString": "str",  # Optional. The textual
                              representation of the goal target.
                            "timestamp": "2020-02-20 00:00:00",  # Optional. The UTC
                              timestamp of the goal value check-in. The time portion of the timestamp
                              is zero.
                            "trend": 0,  # Optional. The goal value trend.
                            "value": 0.0,  # Optional. The goal current value.
                            "valueDisplayString": "str"  # Optional. The textual
                              representation of the current goal value.
                        }
                    ],
                    "hasStatusRules": bool,  # Optional. Whether the goal has status rules
                      defined.
                    "id": "str",  # Optional. The goal ID.
                    "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The UTC time at last
                      modification.
                    "level": 0,  # Optional. The nested level of the goal in the parent-child
                      hierarchy of scorecard goals.
                    "name": "str",  # Optional. The goal name.
                    "notesCount": 0,  # Optional. notesCount.
                    "parentId": "str",  # Optional. The ID of the parent goal, if defined.
                    "permissions": "str",  # Optional. The goal permissions. Known values are:
                      "None", "View", "UpdateCurrentValue", "UpdateTargetValue", "UpdateNotes",
                      "UpdateStatus", "UpdateValues", "All", "11", "13", "15", "19", "21", "23", "25",
                      "27", and "29".
                    "rank": 0,  # Optional. The rank of the goal within the ordered set of
                      sibling goals.
                    "scorecardId": "str",  # Optional. The scorecard ID.
                    "startDate": "2020-02-20 00:00:00",  # Optional. The UTC timestamp for the
                      start date of the goal. The time portion of the timestamp is zero.
                    "statusRules": {
                        "goalObjectId": "str",  # Optional. The goal ID.
                        "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The UTC time
                          at last modification.
                        "rules": "str",  # Optional. The list of rules.
                        "scorecardObjectId": "str"  # Optional. The scorecard ID.
                    },
                    "valuesFormatString": "str"  # Optional. valuesFormatString.
                }
        """

    @distributed_trace_async
    async def preview_post(self, group_id: str, scorecard_id: str, goal: Union[JSON, IO], **kwargs: Any) -> JSON:
        """Adds a new goal to a scorecard.

        Required Scope
        --------------

        Dataset.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The unique identifier of the workspace. Required.
        :type group_id: str
        :param scorecard_id: The unique identifier of the scorecard. Required.
        :type scorecard_id: str
        :param goal: The properties of the new goal. Is either a JSON type or a IO type. Required.
        :type goal: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                goal = {
                    "name": "str",  # The goal name. Required.
                    "completionDate": "2020-02-20 00:00:00",  # Optional. Optional. The UTC
                      timestamp for the completion date of the goal. The time portion of the timestamp
                      is zero.
                    "datesFormatString": "str",  # Optional. Optional. The `custom format string
                      </power-bi/create-reports/desktop-custom-format-strings>`_ for dates.
                    "parentId": "str",  # Optional. Optional. The ID of the parent goal, if
                      defined.
                    "startDate": "2020-02-20 00:00:00",  # Optional. Optional. The UTC timestamp
                      for the start date of the goal. The time portion of the timestamp is zero.
                    "valuesFormatString": "str"  # Optional. Optional. The `custom format string
                      </power-bi/create-reports/desktop-custom-format-strings>`_ for values.
                }

                # response body for status code(s): 200
                response == {
                    "aggregations": [
                        {
                            "calculationTime": "2020-02-20 00:00:00",  # The UTC
                              timestamp of the aggregation calculation. Required.
                            "goalId": "str",  # The goal ID. Required.
                            "id": "str",  # The aggregation ID. Required.
                            "maxLastModifiedTime": "2020-02-20 00:00:00",  # The UTC
                              timestamp of the latest modification to the aggregated property.
                              Required.
                            "scorecardId": "str",  # The scorecard ID. Required.
                            "timestamp": "2020-02-20 00:00:00",  # The UTC timestamp
                              associated with the aggregated property. The time portion of the
                              timestamp is zero. Required.
                            "type": "str",  # The type of the aggregated property.
                              Required. Known values are: "Value", "Target", "Status", "Sparkline", and
                              "Change".
                            "value": 0.0,  # The numeric value of the aggregated
                              property. Required.
                            "valueDisplayString": "str"  # Optional. Optional. The
                              alternative text representation of the aggregated property value.
                        }
                    ],
                    "completionDate": "2020-02-20 00:00:00",  # Optional. The UTC timestamp for
                      the completion date of the goal. The time portion of the timestamp is zero.
                    "createdTime": "2020-02-20 00:00:00",  # Optional. The UTC time at creation.
                    "datesFormatString": "str",  # Optional. datesFormatString.
                    "description": "str",  # Optional. The goal description.
                    "goalValues": [
                        {
                            "createdTime": "2020-02-20 00:00:00",  # Optional. The UTC
                              time at creation.
                            "forecast": 0.0,  # Optional. The goal value trend forecast.
                            "goalId": "str",  # Optional. The goal ID.
                            "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The
                              UTC time at last modification.
                            "notes": [
                                {
                                    "body": "str",  # Optional. The note text.
                                    "content": "str",  # Optional. The content of
                                      this note in special format.
                                    "createdTime": "2020-02-20 00:00:00",  #
                                      Optional. The UTC time at creation.
                                    "goalId": "str",  # Optional. The goal ID.
                                    "id": "str",  # Optional. The goal value
                                      check-in note ID.
                                    "lastModifiedTime": "2020-02-20 00:00:00",  #
                                      Optional. The UTC time at last modification.
                                    "scorecardId": "str",  # Optional. The
                                      scorecard ID.
                                    "valueTimestamp": "2020-02-20 00:00:00"  #
                                      Optional. The UTC timestamp of the goal value check-in that this
                                      note belongs to. The time portion of the timestamp is zero.
                                }
                            ],
                            "scorecardId": "str",  # Optional. The scorecard ID.
                            "status": 0,  # Optional. The ID of the goal status  ..
                              list-table::    :header-rows: 1     * - ID      - Description    * - 0
                              - Not started    * - 1      - On track    * - 2      - At risk    * - 3
                              - Behind    * - 4      - Overdue    * - 5      - Completed.
                            "target": 0.0,  # Optional. The goal target value.
                            "targetDisplayString": "str",  # Optional. The textual
                              representation of the goal target.
                            "timestamp": "2020-02-20 00:00:00",  # Optional. The UTC
                              timestamp of the goal value check-in. The time portion of the timestamp
                              is zero.
                            "trend": 0,  # Optional. The goal value trend.
                            "value": 0.0,  # Optional. The goal current value.
                            "valueDisplayString": "str"  # Optional. The textual
                              representation of the current goal value.
                        }
                    ],
                    "hasStatusRules": bool,  # Optional. Whether the goal has status rules
                      defined.
                    "id": "str",  # Optional. The goal ID.
                    "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The UTC time at last
                      modification.
                    "level": 0,  # Optional. The nested level of the goal in the parent-child
                      hierarchy of scorecard goals.
                    "name": "str",  # Optional. The goal name.
                    "notesCount": 0,  # Optional. notesCount.
                    "parentId": "str",  # Optional. The ID of the parent goal, if defined.
                    "permissions": "str",  # Optional. The goal permissions. Known values are:
                      "None", "View", "UpdateCurrentValue", "UpdateTargetValue", "UpdateNotes",
                      "UpdateStatus", "UpdateValues", "All", "11", "13", "15", "19", "21", "23", "25",
                      "27", and "29".
                    "rank": 0,  # Optional. The rank of the goal within the ordered set of
                      sibling goals.
                    "scorecardId": "str",  # Optional. The scorecard ID.
                    "startDate": "2020-02-20 00:00:00",  # Optional. The UTC timestamp for the
                      start date of the goal. The time portion of the timestamp is zero.
                    "statusRules": {
                        "goalObjectId": "str",  # Optional. The goal ID.
                        "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The UTC time
                          at last modification.
                        "rules": "str",  # Optional. The list of rules.
                        "scorecardObjectId": "str"  # Optional. The scorecard ID.
                    },
                    "valuesFormatString": "str"  # Optional. valuesFormatString.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(goal, (IOBase, bytes)):
            _content = goal
        else:
            _json = goal

        _request = build_goals_preview_post_request(
            group_id=group_id,
            scorecard_id=scorecard_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def preview_get_by_id(
        self, group_id: str, scorecard_id: str, goal_id: str, *, expand: Optional[str] = None, **kwargs: Any
    ) -> JSON:
        """Returns a goal by ID from a scorecard.

        Required Scope
        --------------

        Dataset.Read.All or Dataset.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The unique identifier of the workspace. Required.
        :type group_id: str
        :param scorecard_id: The unique identifier of the scorecard. Required.
        :type scorecard_id: str
        :param goal_id: The unique identifier of the goal. Required.
        :type goal_id: str
        :keyword expand: description. Default value is None.
        :paramtype expand: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "aggregations": [
                        {
                            "calculationTime": "2020-02-20 00:00:00",  # The UTC
                              timestamp of the aggregation calculation. Required.
                            "goalId": "str",  # The goal ID. Required.
                            "id": "str",  # The aggregation ID. Required.
                            "maxLastModifiedTime": "2020-02-20 00:00:00",  # The UTC
                              timestamp of the latest modification to the aggregated property.
                              Required.
                            "scorecardId": "str",  # The scorecard ID. Required.
                            "timestamp": "2020-02-20 00:00:00",  # The UTC timestamp
                              associated with the aggregated property. The time portion of the
                              timestamp is zero. Required.
                            "type": "str",  # The type of the aggregated property.
                              Required. Known values are: "Value", "Target", "Status", "Sparkline", and
                              "Change".
                            "value": 0.0,  # The numeric value of the aggregated
                              property. Required.
                            "valueDisplayString": "str"  # Optional. Optional. The
                              alternative text representation of the aggregated property value.
                        }
                    ],
                    "completionDate": "2020-02-20 00:00:00",  # Optional. The UTC timestamp for
                      the completion date of the goal. The time portion of the timestamp is zero.
                    "createdTime": "2020-02-20 00:00:00",  # Optional. The UTC time at creation.
                    "datesFormatString": "str",  # Optional. datesFormatString.
                    "description": "str",  # Optional. The goal description.
                    "goalValues": [
                        {
                            "createdTime": "2020-02-20 00:00:00",  # Optional. The UTC
                              time at creation.
                            "forecast": 0.0,  # Optional. The goal value trend forecast.
                            "goalId": "str",  # Optional. The goal ID.
                            "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The
                              UTC time at last modification.
                            "notes": [
                                {
                                    "body": "str",  # Optional. The note text.
                                    "content": "str",  # Optional. The content of
                                      this note in special format.
                                    "createdTime": "2020-02-20 00:00:00",  #
                                      Optional. The UTC time at creation.
                                    "goalId": "str",  # Optional. The goal ID.
                                    "id": "str",  # Optional. The goal value
                                      check-in note ID.
                                    "lastModifiedTime": "2020-02-20 00:00:00",  #
                                      Optional. The UTC time at last modification.
                                    "scorecardId": "str",  # Optional. The
                                      scorecard ID.
                                    "valueTimestamp": "2020-02-20 00:00:00"  #
                                      Optional. The UTC timestamp of the goal value check-in that this
                                      note belongs to. The time portion of the timestamp is zero.
                                }
                            ],
                            "scorecardId": "str",  # Optional. The scorecard ID.
                            "status": 0,  # Optional. The ID of the goal status  ..
                              list-table::    :header-rows: 1     * - ID      - Description    * - 0
                              - Not started    * - 1      - On track    * - 2      - At risk    * - 3
                              - Behind    * - 4      - Overdue    * - 5      - Completed.
                            "target": 0.0,  # Optional. The goal target value.
                            "targetDisplayString": "str",  # Optional. The textual
                              representation of the goal target.
                            "timestamp": "2020-02-20 00:00:00",  # Optional. The UTC
                              timestamp of the goal value check-in. The time portion of the timestamp
                              is zero.
                            "trend": 0,  # Optional. The goal value trend.
                            "value": 0.0,  # Optional. The goal current value.
                            "valueDisplayString": "str"  # Optional. The textual
                              representation of the current goal value.
                        }
                    ],
                    "hasStatusRules": bool,  # Optional. Whether the goal has status rules
                      defined.
                    "id": "str",  # Optional. The goal ID.
                    "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The UTC time at last
                      modification.
                    "level": 0,  # Optional. The nested level of the goal in the parent-child
                      hierarchy of scorecard goals.
                    "name": "str",  # Optional. The goal name.
                    "notesCount": 0,  # Optional. notesCount.
                    "parentId": "str",  # Optional. The ID of the parent goal, if defined.
                    "permissions": "str",  # Optional. The goal permissions. Known values are:
                      "None", "View", "UpdateCurrentValue", "UpdateTargetValue", "UpdateNotes",
                      "UpdateStatus", "UpdateValues", "All", "11", "13", "15", "19", "21", "23", "25",
                      "27", and "29".
                    "rank": 0,  # Optional. The rank of the goal within the ordered set of
                      sibling goals.
                    "scorecardId": "str",  # Optional. The scorecard ID.
                    "startDate": "2020-02-20 00:00:00",  # Optional. The UTC timestamp for the
                      start date of the goal. The time portion of the timestamp is zero.
                    "statusRules": {
                        "goalObjectId": "str",  # Optional. The goal ID.
                        "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The UTC time
                          at last modification.
                        "rules": "str",  # Optional. The list of rules.
                        "scorecardObjectId": "str"  # Optional. The scorecard ID.
                    },
                    "valuesFormatString": "str"  # Optional. valuesFormatString.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_goals_preview_get_by_id_request(
            group_id=group_id,
            scorecard_id=scorecard_id,
            goal_id=goal_id,
            expand=expand,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def preview_patch_by_id(
        self,
        group_id: str,
        scorecard_id: str,
        goal_id: str,
        goal: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Updates a goal by ID.

        Required Scope
        --------------

        Dataset.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The unique identifier of the workspace. Required.
        :type group_id: str
        :param scorecard_id: The unique identifier of the scorecard. Required.
        :type scorecard_id: str
        :param goal_id: The unique identifier of the goal. Required.
        :type goal_id: str
        :param goal: The goal properties to patch. Required.
        :type goal: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                goal = {
                    "aggregations": [
                        {
                            "calculationTime": "2020-02-20 00:00:00",  # The UTC
                              timestamp of the aggregation calculation. Required.
                            "goalId": "str",  # The goal ID. Required.
                            "id": "str",  # The aggregation ID. Required.
                            "maxLastModifiedTime": "2020-02-20 00:00:00",  # The UTC
                              timestamp of the latest modification to the aggregated property.
                              Required.
                            "scorecardId": "str",  # The scorecard ID. Required.
                            "timestamp": "2020-02-20 00:00:00",  # The UTC timestamp
                              associated with the aggregated property. The time portion of the
                              timestamp is zero. Required.
                            "type": "str",  # The type of the aggregated property.
                              Required. Known values are: "Value", "Target", "Status", "Sparkline", and
                              "Change".
                            "value": 0.0,  # The numeric value of the aggregated
                              property. Required.
                            "valueDisplayString": "str"  # Optional. Optional. The
                              alternative text representation of the aggregated property value.
                        }
                    ],
                    "completionDate": "2020-02-20 00:00:00",  # Optional. The UTC timestamp for
                      the completion date of the goal. The time portion of the timestamp is zero.
                    "createdTime": "2020-02-20 00:00:00",  # Optional. The UTC time at creation.
                    "datesFormatString": "str",  # Optional. datesFormatString.
                    "description": "str",  # Optional. The goal description.
                    "goalValues": [
                        {
                            "createdTime": "2020-02-20 00:00:00",  # Optional. The UTC
                              time at creation.
                            "forecast": 0.0,  # Optional. The goal value trend forecast.
                            "goalId": "str",  # Optional. The goal ID.
                            "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The
                              UTC time at last modification.
                            "notes": [
                                {
                                    "body": "str",  # Optional. The note text.
                                    "content": "str",  # Optional. The content of
                                      this note in special format.
                                    "createdTime": "2020-02-20 00:00:00",  #
                                      Optional. The UTC time at creation.
                                    "goalId": "str",  # Optional. The goal ID.
                                    "id": "str",  # Optional. The goal value
                                      check-in note ID.
                                    "lastModifiedTime": "2020-02-20 00:00:00",  #
                                      Optional. The UTC time at last modification.
                                    "scorecardId": "str",  # Optional. The
                                      scorecard ID.
                                    "valueTimestamp": "2020-02-20 00:00:00"  #
                                      Optional. The UTC timestamp of the goal value check-in that this
                                      note belongs to. The time portion of the timestamp is zero.
                                }
                            ],
                            "scorecardId": "str",  # Optional. The scorecard ID.
                            "status": 0,  # Optional. The ID of the goal status  ..
                              list-table::    :header-rows: 1     * - ID      - Description    * - 0
                              - Not started    * - 1      - On track    * - 2      - At risk    * - 3
                              - Behind    * - 4      - Overdue    * - 5      - Completed.
                            "target": 0.0,  # Optional. The goal target value.
                            "targetDisplayString": "str",  # Optional. The textual
                              representation of the goal target.
                            "timestamp": "2020-02-20 00:00:00",  # Optional. The UTC
                              timestamp of the goal value check-in. The time portion of the timestamp
                              is zero.
                            "trend": 0,  # Optional. The goal value trend.
                            "value": 0.0,  # Optional. The goal current value.
                            "valueDisplayString": "str"  # Optional. The textual
                              representation of the current goal value.
                        }
                    ],
                    "hasStatusRules": bool,  # Optional. Whether the goal has status rules
                      defined.
                    "id": "str",  # Optional. The goal ID.
                    "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The UTC time at last
                      modification.
                    "level": 0,  # Optional. The nested level of the goal in the parent-child
                      hierarchy of scorecard goals.
                    "name": "str",  # Optional. The goal name.
                    "notesCount": 0,  # Optional. notesCount.
                    "parentId": "str",  # Optional. The ID of the parent goal, if defined.
                    "permissions": "str",  # Optional. The goal permissions. Known values are:
                      "None", "View", "UpdateCurrentValue", "UpdateTargetValue", "UpdateNotes",
                      "UpdateStatus", "UpdateValues", "All", "11", "13", "15", "19", "21", "23", "25",
                      "27", and "29".
                    "rank": 0,  # Optional. The rank of the goal within the ordered set of
                      sibling goals.
                    "scorecardId": "str",  # Optional. The scorecard ID.
                    "startDate": "2020-02-20 00:00:00",  # Optional. The UTC timestamp for the
                      start date of the goal. The time portion of the timestamp is zero.
                    "statusRules": {
                        "goalObjectId": "str",  # Optional. The goal ID.
                        "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The UTC time
                          at last modification.
                        "rules": "str",  # Optional. The list of rules.
                        "scorecardObjectId": "str"  # Optional. The scorecard ID.
                    },
                    "valuesFormatString": "str"  # Optional. valuesFormatString.
                }

                # response body for status code(s): 200
                response == {
                    "aggregations": [
                        {
                            "calculationTime": "2020-02-20 00:00:00",  # The UTC
                              timestamp of the aggregation calculation. Required.
                            "goalId": "str",  # The goal ID. Required.
                            "id": "str",  # The aggregation ID. Required.
                            "maxLastModifiedTime": "2020-02-20 00:00:00",  # The UTC
                              timestamp of the latest modification to the aggregated property.
                              Required.
                            "scorecardId": "str",  # The scorecard ID. Required.
                            "timestamp": "2020-02-20 00:00:00",  # The UTC timestamp
                              associated with the aggregated property. The time portion of the
                              timestamp is zero. Required.
                            "type": "str",  # The type of the aggregated property.
                              Required. Known values are: "Value", "Target", "Status", "Sparkline", and
                              "Change".
                            "value": 0.0,  # The numeric value of the aggregated
                              property. Required.
                            "valueDisplayString": "str"  # Optional. Optional. The
                              alternative text representation of the aggregated property value.
                        }
                    ],
                    "completionDate": "2020-02-20 00:00:00",  # Optional. The UTC timestamp for
                      the completion date of the goal. The time portion of the timestamp is zero.
                    "createdTime": "2020-02-20 00:00:00",  # Optional. The UTC time at creation.
                    "datesFormatString": "str",  # Optional. datesFormatString.
                    "description": "str",  # Optional. The goal description.
                    "goalValues": [
                        {
                            "createdTime": "2020-02-20 00:00:00",  # Optional. The UTC
                              time at creation.
                            "forecast": 0.0,  # Optional. The goal value trend forecast.
                            "goalId": "str",  # Optional. The goal ID.
                            "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The
                              UTC time at last modification.
                            "notes": [
                                {
                                    "body": "str",  # Optional. The note text.
                                    "content": "str",  # Optional. The content of
                                      this note in special format.
                                    "createdTime": "2020-02-20 00:00:00",  #
                                      Optional. The UTC time at creation.
                                    "goalId": "str",  # Optional. The goal ID.
                                    "id": "str",  # Optional. The goal value
                                      check-in note ID.
                                    "lastModifiedTime": "2020-02-20 00:00:00",  #
                                      Optional. The UTC time at last modification.
                                    "scorecardId": "str",  # Optional. The
                                      scorecard ID.
                                    "valueTimestamp": "2020-02-20 00:00:00"  #
                                      Optional. The UTC timestamp of the goal value check-in that this
                                      note belongs to. The time portion of the timestamp is zero.
                                }
                            ],
                            "scorecardId": "str",  # Optional. The scorecard ID.
                            "status": 0,  # Optional. The ID of the goal status  ..
                              list-table::    :header-rows: 1     * - ID      - Description    * - 0
                              - Not started    * - 1      - On track    * - 2      - At risk    * - 3
                              - Behind    * - 4      - Overdue    * - 5      - Completed.
                            "target": 0.0,  # Optional. The goal target value.
                            "targetDisplayString": "str",  # Optional. The textual
                              representation of the goal target.
                            "timestamp": "2020-02-20 00:00:00",  # Optional. The UTC
                              timestamp of the goal value check-in. The time portion of the timestamp
                              is zero.
                            "trend": 0,  # Optional. The goal value trend.
                            "value": 0.0,  # Optional. The goal current value.
                            "valueDisplayString": "str"  # Optional. The textual
                              representation of the current goal value.
                        }
                    ],
                    "hasStatusRules": bool,  # Optional. Whether the goal has status rules
                      defined.
                    "id": "str",  # Optional. The goal ID.
                    "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The UTC time at last
                      modification.
                    "level": 0,  # Optional. The nested level of the goal in the parent-child
                      hierarchy of scorecard goals.
                    "name": "str",  # Optional. The goal name.
                    "notesCount": 0,  # Optional. notesCount.
                    "parentId": "str",  # Optional. The ID of the parent goal, if defined.
                    "permissions": "str",  # Optional. The goal permissions. Known values are:
                      "None", "View", "UpdateCurrentValue", "UpdateTargetValue", "UpdateNotes",
                      "UpdateStatus", "UpdateValues", "All", "11", "13", "15", "19", "21", "23", "25",
                      "27", and "29".
                    "rank": 0,  # Optional. The rank of the goal within the ordered set of
                      sibling goals.
                    "scorecardId": "str",  # Optional. The scorecard ID.
                    "startDate": "2020-02-20 00:00:00",  # Optional. The UTC timestamp for the
                      start date of the goal. The time portion of the timestamp is zero.
                    "statusRules": {
                        "goalObjectId": "str",  # Optional. The goal ID.
                        "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The UTC time
                          at last modification.
                        "rules": "str",  # Optional. The list of rules.
                        "scorecardObjectId": "str"  # Optional. The scorecard ID.
                    },
                    "valuesFormatString": "str"  # Optional. valuesFormatString.
                }
        """

    @overload
    async def preview_patch_by_id(
        self,
        group_id: str,
        scorecard_id: str,
        goal_id: str,
        goal: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Updates a goal by ID.

        Required Scope
        --------------

        Dataset.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The unique identifier of the workspace. Required.
        :type group_id: str
        :param scorecard_id: The unique identifier of the scorecard. Required.
        :type scorecard_id: str
        :param goal_id: The unique identifier of the goal. Required.
        :type goal_id: str
        :param goal: The goal properties to patch. Required.
        :type goal: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "aggregations": [
                        {
                            "calculationTime": "2020-02-20 00:00:00",  # The UTC
                              timestamp of the aggregation calculation. Required.
                            "goalId": "str",  # The goal ID. Required.
                            "id": "str",  # The aggregation ID. Required.
                            "maxLastModifiedTime": "2020-02-20 00:00:00",  # The UTC
                              timestamp of the latest modification to the aggregated property.
                              Required.
                            "scorecardId": "str",  # The scorecard ID. Required.
                            "timestamp": "2020-02-20 00:00:00",  # The UTC timestamp
                              associated with the aggregated property. The time portion of the
                              timestamp is zero. Required.
                            "type": "str",  # The type of the aggregated property.
                              Required. Known values are: "Value", "Target", "Status", "Sparkline", and
                              "Change".
                            "value": 0.0,  # The numeric value of the aggregated
                              property. Required.
                            "valueDisplayString": "str"  # Optional. Optional. The
                              alternative text representation of the aggregated property value.
                        }
                    ],
                    "completionDate": "2020-02-20 00:00:00",  # Optional. The UTC timestamp for
                      the completion date of the goal. The time portion of the timestamp is zero.
                    "createdTime": "2020-02-20 00:00:00",  # Optional. The UTC time at creation.
                    "datesFormatString": "str",  # Optional. datesFormatString.
                    "description": "str",  # Optional. The goal description.
                    "goalValues": [
                        {
                            "createdTime": "2020-02-20 00:00:00",  # Optional. The UTC
                              time at creation.
                            "forecast": 0.0,  # Optional. The goal value trend forecast.
                            "goalId": "str",  # Optional. The goal ID.
                            "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The
                              UTC time at last modification.
                            "notes": [
                                {
                                    "body": "str",  # Optional. The note text.
                                    "content": "str",  # Optional. The content of
                                      this note in special format.
                                    "createdTime": "2020-02-20 00:00:00",  #
                                      Optional. The UTC time at creation.
                                    "goalId": "str",  # Optional. The goal ID.
                                    "id": "str",  # Optional. The goal value
                                      check-in note ID.
                                    "lastModifiedTime": "2020-02-20 00:00:00",  #
                                      Optional. The UTC time at last modification.
                                    "scorecardId": "str",  # Optional. The
                                      scorecard ID.
                                    "valueTimestamp": "2020-02-20 00:00:00"  #
                                      Optional. The UTC timestamp of the goal value check-in that this
                                      note belongs to. The time portion of the timestamp is zero.
                                }
                            ],
                            "scorecardId": "str",  # Optional. The scorecard ID.
                            "status": 0,  # Optional. The ID of the goal status  ..
                              list-table::    :header-rows: 1     * - ID      - Description    * - 0
                              - Not started    * - 1      - On track    * - 2      - At risk    * - 3
                              - Behind    * - 4      - Overdue    * - 5      - Completed.
                            "target": 0.0,  # Optional. The goal target value.
                            "targetDisplayString": "str",  # Optional. The textual
                              representation of the goal target.
                            "timestamp": "2020-02-20 00:00:00",  # Optional. The UTC
                              timestamp of the goal value check-in. The time portion of the timestamp
                              is zero.
                            "trend": 0,  # Optional. The goal value trend.
                            "value": 0.0,  # Optional. The goal current value.
                            "valueDisplayString": "str"  # Optional. The textual
                              representation of the current goal value.
                        }
                    ],
                    "hasStatusRules": bool,  # Optional. Whether the goal has status rules
                      defined.
                    "id": "str",  # Optional. The goal ID.
                    "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The UTC time at last
                      modification.
                    "level": 0,  # Optional. The nested level of the goal in the parent-child
                      hierarchy of scorecard goals.
                    "name": "str",  # Optional. The goal name.
                    "notesCount": 0,  # Optional. notesCount.
                    "parentId": "str",  # Optional. The ID of the parent goal, if defined.
                    "permissions": "str",  # Optional. The goal permissions. Known values are:
                      "None", "View", "UpdateCurrentValue", "UpdateTargetValue", "UpdateNotes",
                      "UpdateStatus", "UpdateValues", "All", "11", "13", "15", "19", "21", "23", "25",
                      "27", and "29".
                    "rank": 0,  # Optional. The rank of the goal within the ordered set of
                      sibling goals.
                    "scorecardId": "str",  # Optional. The scorecard ID.
                    "startDate": "2020-02-20 00:00:00",  # Optional. The UTC timestamp for the
                      start date of the goal. The time portion of the timestamp is zero.
                    "statusRules": {
                        "goalObjectId": "str",  # Optional. The goal ID.
                        "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The UTC time
                          at last modification.
                        "rules": "str",  # Optional. The list of rules.
                        "scorecardObjectId": "str"  # Optional. The scorecard ID.
                    },
                    "valuesFormatString": "str"  # Optional. valuesFormatString.
                }
        """

    @distributed_trace_async
    async def preview_patch_by_id(
        self, group_id: str, scorecard_id: str, goal_id: str, goal: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Updates a goal by ID.

        Required Scope
        --------------

        Dataset.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The unique identifier of the workspace. Required.
        :type group_id: str
        :param scorecard_id: The unique identifier of the scorecard. Required.
        :type scorecard_id: str
        :param goal_id: The unique identifier of the goal. Required.
        :type goal_id: str
        :param goal: The goal properties to patch. Is either a JSON type or a IO type. Required.
        :type goal: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                goal = {
                    "aggregations": [
                        {
                            "calculationTime": "2020-02-20 00:00:00",  # The UTC
                              timestamp of the aggregation calculation. Required.
                            "goalId": "str",  # The goal ID. Required.
                            "id": "str",  # The aggregation ID. Required.
                            "maxLastModifiedTime": "2020-02-20 00:00:00",  # The UTC
                              timestamp of the latest modification to the aggregated property.
                              Required.
                            "scorecardId": "str",  # The scorecard ID. Required.
                            "timestamp": "2020-02-20 00:00:00",  # The UTC timestamp
                              associated with the aggregated property. The time portion of the
                              timestamp is zero. Required.
                            "type": "str",  # The type of the aggregated property.
                              Required. Known values are: "Value", "Target", "Status", "Sparkline", and
                              "Change".
                            "value": 0.0,  # The numeric value of the aggregated
                              property. Required.
                            "valueDisplayString": "str"  # Optional. Optional. The
                              alternative text representation of the aggregated property value.
                        }
                    ],
                    "completionDate": "2020-02-20 00:00:00",  # Optional. The UTC timestamp for
                      the completion date of the goal. The time portion of the timestamp is zero.
                    "createdTime": "2020-02-20 00:00:00",  # Optional. The UTC time at creation.
                    "datesFormatString": "str",  # Optional. datesFormatString.
                    "description": "str",  # Optional. The goal description.
                    "goalValues": [
                        {
                            "createdTime": "2020-02-20 00:00:00",  # Optional. The UTC
                              time at creation.
                            "forecast": 0.0,  # Optional. The goal value trend forecast.
                            "goalId": "str",  # Optional. The goal ID.
                            "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The
                              UTC time at last modification.
                            "notes": [
                                {
                                    "body": "str",  # Optional. The note text.
                                    "content": "str",  # Optional. The content of
                                      this note in special format.
                                    "createdTime": "2020-02-20 00:00:00",  #
                                      Optional. The UTC time at creation.
                                    "goalId": "str",  # Optional. The goal ID.
                                    "id": "str",  # Optional. The goal value
                                      check-in note ID.
                                    "lastModifiedTime": "2020-02-20 00:00:00",  #
                                      Optional. The UTC time at last modification.
                                    "scorecardId": "str",  # Optional. The
                                      scorecard ID.
                                    "valueTimestamp": "2020-02-20 00:00:00"  #
                                      Optional. The UTC timestamp of the goal value check-in that this
                                      note belongs to. The time portion of the timestamp is zero.
                                }
                            ],
                            "scorecardId": "str",  # Optional. The scorecard ID.
                            "status": 0,  # Optional. The ID of the goal status  ..
                              list-table::    :header-rows: 1     * - ID      - Description    * - 0
                              - Not started    * - 1      - On track    * - 2      - At risk    * - 3
                              - Behind    * - 4      - Overdue    * - 5      - Completed.
                            "target": 0.0,  # Optional. The goal target value.
                            "targetDisplayString": "str",  # Optional. The textual
                              representation of the goal target.
                            "timestamp": "2020-02-20 00:00:00",  # Optional. The UTC
                              timestamp of the goal value check-in. The time portion of the timestamp
                              is zero.
                            "trend": 0,  # Optional. The goal value trend.
                            "value": 0.0,  # Optional. The goal current value.
                            "valueDisplayString": "str"  # Optional. The textual
                              representation of the current goal value.
                        }
                    ],
                    "hasStatusRules": bool,  # Optional. Whether the goal has status rules
                      defined.
                    "id": "str",  # Optional. The goal ID.
                    "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The UTC time at last
                      modification.
                    "level": 0,  # Optional. The nested level of the goal in the parent-child
                      hierarchy of scorecard goals.
                    "name": "str",  # Optional. The goal name.
                    "notesCount": 0,  # Optional. notesCount.
                    "parentId": "str",  # Optional. The ID of the parent goal, if defined.
                    "permissions": "str",  # Optional. The goal permissions. Known values are:
                      "None", "View", "UpdateCurrentValue", "UpdateTargetValue", "UpdateNotes",
                      "UpdateStatus", "UpdateValues", "All", "11", "13", "15", "19", "21", "23", "25",
                      "27", and "29".
                    "rank": 0,  # Optional. The rank of the goal within the ordered set of
                      sibling goals.
                    "scorecardId": "str",  # Optional. The scorecard ID.
                    "startDate": "2020-02-20 00:00:00",  # Optional. The UTC timestamp for the
                      start date of the goal. The time portion of the timestamp is zero.
                    "statusRules": {
                        "goalObjectId": "str",  # Optional. The goal ID.
                        "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The UTC time
                          at last modification.
                        "rules": "str",  # Optional. The list of rules.
                        "scorecardObjectId": "str"  # Optional. The scorecard ID.
                    },
                    "valuesFormatString": "str"  # Optional. valuesFormatString.
                }

                # response body for status code(s): 200
                response == {
                    "aggregations": [
                        {
                            "calculationTime": "2020-02-20 00:00:00",  # The UTC
                              timestamp of the aggregation calculation. Required.
                            "goalId": "str",  # The goal ID. Required.
                            "id": "str",  # The aggregation ID. Required.
                            "maxLastModifiedTime": "2020-02-20 00:00:00",  # The UTC
                              timestamp of the latest modification to the aggregated property.
                              Required.
                            "scorecardId": "str",  # The scorecard ID. Required.
                            "timestamp": "2020-02-20 00:00:00",  # The UTC timestamp
                              associated with the aggregated property. The time portion of the
                              timestamp is zero. Required.
                            "type": "str",  # The type of the aggregated property.
                              Required. Known values are: "Value", "Target", "Status", "Sparkline", and
                              "Change".
                            "value": 0.0,  # The numeric value of the aggregated
                              property. Required.
                            "valueDisplayString": "str"  # Optional. Optional. The
                              alternative text representation of the aggregated property value.
                        }
                    ],
                    "completionDate": "2020-02-20 00:00:00",  # Optional. The UTC timestamp for
                      the completion date of the goal. The time portion of the timestamp is zero.
                    "createdTime": "2020-02-20 00:00:00",  # Optional. The UTC time at creation.
                    "datesFormatString": "str",  # Optional. datesFormatString.
                    "description": "str",  # Optional. The goal description.
                    "goalValues": [
                        {
                            "createdTime": "2020-02-20 00:00:00",  # Optional. The UTC
                              time at creation.
                            "forecast": 0.0,  # Optional. The goal value trend forecast.
                            "goalId": "str",  # Optional. The goal ID.
                            "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The
                              UTC time at last modification.
                            "notes": [
                                {
                                    "body": "str",  # Optional. The note text.
                                    "content": "str",  # Optional. The content of
                                      this note in special format.
                                    "createdTime": "2020-02-20 00:00:00",  #
                                      Optional. The UTC time at creation.
                                    "goalId": "str",  # Optional. The goal ID.
                                    "id": "str",  # Optional. The goal value
                                      check-in note ID.
                                    "lastModifiedTime": "2020-02-20 00:00:00",  #
                                      Optional. The UTC time at last modification.
                                    "scorecardId": "str",  # Optional. The
                                      scorecard ID.
                                    "valueTimestamp": "2020-02-20 00:00:00"  #
                                      Optional. The UTC timestamp of the goal value check-in that this
                                      note belongs to. The time portion of the timestamp is zero.
                                }
                            ],
                            "scorecardId": "str",  # Optional. The scorecard ID.
                            "status": 0,  # Optional. The ID of the goal status  ..
                              list-table::    :header-rows: 1     * - ID      - Description    * - 0
                              - Not started    * - 1      - On track    * - 2      - At risk    * - 3
                              - Behind    * - 4      - Overdue    * - 5      - Completed.
                            "target": 0.0,  # Optional. The goal target value.
                            "targetDisplayString": "str",  # Optional. The textual
                              representation of the goal target.
                            "timestamp": "2020-02-20 00:00:00",  # Optional. The UTC
                              timestamp of the goal value check-in. The time portion of the timestamp
                              is zero.
                            "trend": 0,  # Optional. The goal value trend.
                            "value": 0.0,  # Optional. The goal current value.
                            "valueDisplayString": "str"  # Optional. The textual
                              representation of the current goal value.
                        }
                    ],
                    "hasStatusRules": bool,  # Optional. Whether the goal has status rules
                      defined.
                    "id": "str",  # Optional. The goal ID.
                    "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The UTC time at last
                      modification.
                    "level": 0,  # Optional. The nested level of the goal in the parent-child
                      hierarchy of scorecard goals.
                    "name": "str",  # Optional. The goal name.
                    "notesCount": 0,  # Optional. notesCount.
                    "parentId": "str",  # Optional. The ID of the parent goal, if defined.
                    "permissions": "str",  # Optional. The goal permissions. Known values are:
                      "None", "View", "UpdateCurrentValue", "UpdateTargetValue", "UpdateNotes",
                      "UpdateStatus", "UpdateValues", "All", "11", "13", "15", "19", "21", "23", "25",
                      "27", and "29".
                    "rank": 0,  # Optional. The rank of the goal within the ordered set of
                      sibling goals.
                    "scorecardId": "str",  # Optional. The scorecard ID.
                    "startDate": "2020-02-20 00:00:00",  # Optional. The UTC timestamp for the
                      start date of the goal. The time portion of the timestamp is zero.
                    "statusRules": {
                        "goalObjectId": "str",  # Optional. The goal ID.
                        "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The UTC time
                          at last modification.
                        "rules": "str",  # Optional. The list of rules.
                        "scorecardObjectId": "str"  # Optional. The scorecard ID.
                    },
                    "valuesFormatString": "str"  # Optional. valuesFormatString.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(goal, (IOBase, bytes)):
            _content = goal
        else:
            _json = goal

        _request = build_goals_preview_patch_by_id_request(
            group_id=group_id,
            scorecard_id=scorecard_id,
            goal_id=goal_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def preview_delete_by_id(  # pylint: disable=inconsistent-return-statements
        self, group_id: str, scorecard_id: str, goal_id: str, **kwargs: Any
    ) -> None:
        """Deletes a goal from a scorecard by goal ID.

        Required Scope
        --------------

        Dataset.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The unique identifier of the workspace. Required.
        :type group_id: str
        :param scorecard_id: The unique identifier of the scorecard. Required.
        :type scorecard_id: str
        :param goal_id: The unique identifier of the goal. Required.
        :type goal_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_goals_preview_delete_by_id_request(
            group_id=group_id,
            scorecard_id=scorecard_id,
            goal_id=goal_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def preview_get_refresh_history(self, group_id: str, scorecard_id: str, goal_id: str, **kwargs: Any) -> JSON:
        """Reads refresh history of a connected goal.

        Required Scope
        --------------

        Dataset.Read.All or Dataset.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The unique identifier of the workspace. Required.
        :type group_id: str
        :param scorecard_id: The unique identifier of the scorecard. Required.
        :type scorecard_id: str
        :param goal_id: The unique identifier of the goal. Required.
        :type goal_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "@odata.context": "str",  # Optional. OData context.
                    "value": [
                        {
                            "connectionType": "str",  # Optional. The refresh connection
                              type. Known values are: "Current", "Target", and "Status".
                            "goalId": "str",  # Optional. The goal ID.
                            "message": "str",  # Optional. The verbal description of the
                              status of the refresh operation.
                            "rootActivityId": "str",  # Optional. The root activity ID.
                            "status": "str",  # Optional. The status of the refresh
                              processing. Known values are: "NotProcessed", "Succeeded", "Failed",
                              "UserNotFound", "QueryExecutionError", "QueryResultError",
                              "BadQueryResultMetadata", "EmptyGoalValues", "ConnectedDatasetDeleted",
                              "UserNotAuthorized", "ModelNotFound", and "ScorecardNotFound".
                            "timestamp": "2020-02-20 00:00:00"  # Optional. The UTC
                              timestamp of the refresh operation.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_goals_preview_get_refresh_history_request(
            group_id=group_id,
            scorecard_id=scorecard_id,
            goal_id=goal_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def preview_delete_goal_current_value_connection(  # pylint: disable=name-too-long
        self, group_id: str, scorecard_id: str, goal_id: str, **kwargs: Any
    ) -> JSON:
        """Disconnects the current value of a goal.

        Required Scope
        --------------

        Dataset.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The unique identifier of the workspace. Required.
        :type group_id: str
        :param scorecard_id: The unique identifier of the scorecard. Required.
        :type scorecard_id: str
        :param goal_id: The unique identifier of the goal. Required.
        :type goal_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "aggregations": [
                        {
                            "calculationTime": "2020-02-20 00:00:00",  # The UTC
                              timestamp of the aggregation calculation. Required.
                            "goalId": "str",  # The goal ID. Required.
                            "id": "str",  # The aggregation ID. Required.
                            "maxLastModifiedTime": "2020-02-20 00:00:00",  # The UTC
                              timestamp of the latest modification to the aggregated property.
                              Required.
                            "scorecardId": "str",  # The scorecard ID. Required.
                            "timestamp": "2020-02-20 00:00:00",  # The UTC timestamp
                              associated with the aggregated property. The time portion of the
                              timestamp is zero. Required.
                            "type": "str",  # The type of the aggregated property.
                              Required. Known values are: "Value", "Target", "Status", "Sparkline", and
                              "Change".
                            "value": 0.0,  # The numeric value of the aggregated
                              property. Required.
                            "valueDisplayString": "str"  # Optional. Optional. The
                              alternative text representation of the aggregated property value.
                        }
                    ],
                    "completionDate": "2020-02-20 00:00:00",  # Optional. The UTC timestamp for
                      the completion date of the goal. The time portion of the timestamp is zero.
                    "createdTime": "2020-02-20 00:00:00",  # Optional. The UTC time at creation.
                    "datesFormatString": "str",  # Optional. datesFormatString.
                    "description": "str",  # Optional. The goal description.
                    "goalValues": [
                        {
                            "createdTime": "2020-02-20 00:00:00",  # Optional. The UTC
                              time at creation.
                            "forecast": 0.0,  # Optional. The goal value trend forecast.
                            "goalId": "str",  # Optional. The goal ID.
                            "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The
                              UTC time at last modification.
                            "notes": [
                                {
                                    "body": "str",  # Optional. The note text.
                                    "content": "str",  # Optional. The content of
                                      this note in special format.
                                    "createdTime": "2020-02-20 00:00:00",  #
                                      Optional. The UTC time at creation.
                                    "goalId": "str",  # Optional. The goal ID.
                                    "id": "str",  # Optional. The goal value
                                      check-in note ID.
                                    "lastModifiedTime": "2020-02-20 00:00:00",  #
                                      Optional. The UTC time at last modification.
                                    "scorecardId": "str",  # Optional. The
                                      scorecard ID.
                                    "valueTimestamp": "2020-02-20 00:00:00"  #
                                      Optional. The UTC timestamp of the goal value check-in that this
                                      note belongs to. The time portion of the timestamp is zero.
                                }
                            ],
                            "scorecardId": "str",  # Optional. The scorecard ID.
                            "status": 0,  # Optional. The ID of the goal status  ..
                              list-table::    :header-rows: 1     * - ID      - Description    * - 0
                              - Not started    * - 1      - On track    * - 2      - At risk    * - 3
                              - Behind    * - 4      - Overdue    * - 5      - Completed.
                            "target": 0.0,  # Optional. The goal target value.
                            "targetDisplayString": "str",  # Optional. The textual
                              representation of the goal target.
                            "timestamp": "2020-02-20 00:00:00",  # Optional. The UTC
                              timestamp of the goal value check-in. The time portion of the timestamp
                              is zero.
                            "trend": 0,  # Optional. The goal value trend.
                            "value": 0.0,  # Optional. The goal current value.
                            "valueDisplayString": "str"  # Optional. The textual
                              representation of the current goal value.
                        }
                    ],
                    "hasStatusRules": bool,  # Optional. Whether the goal has status rules
                      defined.
                    "id": "str",  # Optional. The goal ID.
                    "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The UTC time at last
                      modification.
                    "level": 0,  # Optional. The nested level of the goal in the parent-child
                      hierarchy of scorecard goals.
                    "name": "str",  # Optional. The goal name.
                    "notesCount": 0,  # Optional. notesCount.
                    "parentId": "str",  # Optional. The ID of the parent goal, if defined.
                    "permissions": "str",  # Optional. The goal permissions. Known values are:
                      "None", "View", "UpdateCurrentValue", "UpdateTargetValue", "UpdateNotes",
                      "UpdateStatus", "UpdateValues", "All", "11", "13", "15", "19", "21", "23", "25",
                      "27", and "29".
                    "rank": 0,  # Optional. The rank of the goal within the ordered set of
                      sibling goals.
                    "scorecardId": "str",  # Optional. The scorecard ID.
                    "startDate": "2020-02-20 00:00:00",  # Optional. The UTC timestamp for the
                      start date of the goal. The time portion of the timestamp is zero.
                    "statusRules": {
                        "goalObjectId": "str",  # Optional. The goal ID.
                        "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The UTC time
                          at last modification.
                        "rules": "str",  # Optional. The list of rules.
                        "scorecardObjectId": "str"  # Optional. The scorecard ID.
                    },
                    "valuesFormatString": "str"  # Optional. valuesFormatString.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_goals_preview_delete_goal_current_value_connection_request(
            group_id=group_id,
            scorecard_id=scorecard_id,
            goal_id=goal_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def preview_delete_goal_target_value_connection(  # pylint: disable=name-too-long
        self, group_id: str, scorecard_id: str, goal_id: str, **kwargs: Any
    ) -> JSON:
        """Disconnects the target value of a goal.

        Required Scope
        --------------

        Dataset.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The unique identifier of the workspace. Required.
        :type group_id: str
        :param scorecard_id: The unique identifier of the scorecard. Required.
        :type scorecard_id: str
        :param goal_id: The unique identifier of the goal. Required.
        :type goal_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "aggregations": [
                        {
                            "calculationTime": "2020-02-20 00:00:00",  # The UTC
                              timestamp of the aggregation calculation. Required.
                            "goalId": "str",  # The goal ID. Required.
                            "id": "str",  # The aggregation ID. Required.
                            "maxLastModifiedTime": "2020-02-20 00:00:00",  # The UTC
                              timestamp of the latest modification to the aggregated property.
                              Required.
                            "scorecardId": "str",  # The scorecard ID. Required.
                            "timestamp": "2020-02-20 00:00:00",  # The UTC timestamp
                              associated with the aggregated property. The time portion of the
                              timestamp is zero. Required.
                            "type": "str",  # The type of the aggregated property.
                              Required. Known values are: "Value", "Target", "Status", "Sparkline", and
                              "Change".
                            "value": 0.0,  # The numeric value of the aggregated
                              property. Required.
                            "valueDisplayString": "str"  # Optional. Optional. The
                              alternative text representation of the aggregated property value.
                        }
                    ],
                    "completionDate": "2020-02-20 00:00:00",  # Optional. The UTC timestamp for
                      the completion date of the goal. The time portion of the timestamp is zero.
                    "createdTime": "2020-02-20 00:00:00",  # Optional. The UTC time at creation.
                    "datesFormatString": "str",  # Optional. datesFormatString.
                    "description": "str",  # Optional. The goal description.
                    "goalValues": [
                        {
                            "createdTime": "2020-02-20 00:00:00",  # Optional. The UTC
                              time at creation.
                            "forecast": 0.0,  # Optional. The goal value trend forecast.
                            "goalId": "str",  # Optional. The goal ID.
                            "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The
                              UTC time at last modification.
                            "notes": [
                                {
                                    "body": "str",  # Optional. The note text.
                                    "content": "str",  # Optional. The content of
                                      this note in special format.
                                    "createdTime": "2020-02-20 00:00:00",  #
                                      Optional. The UTC time at creation.
                                    "goalId": "str",  # Optional. The goal ID.
                                    "id": "str",  # Optional. The goal value
                                      check-in note ID.
                                    "lastModifiedTime": "2020-02-20 00:00:00",  #
                                      Optional. The UTC time at last modification.
                                    "scorecardId": "str",  # Optional. The
                                      scorecard ID.
                                    "valueTimestamp": "2020-02-20 00:00:00"  #
                                      Optional. The UTC timestamp of the goal value check-in that this
                                      note belongs to. The time portion of the timestamp is zero.
                                }
                            ],
                            "scorecardId": "str",  # Optional. The scorecard ID.
                            "status": 0,  # Optional. The ID of the goal status  ..
                              list-table::    :header-rows: 1     * - ID      - Description    * - 0
                              - Not started    * - 1      - On track    * - 2      - At risk    * - 3
                              - Behind    * - 4      - Overdue    * - 5      - Completed.
                            "target": 0.0,  # Optional. The goal target value.
                            "targetDisplayString": "str",  # Optional. The textual
                              representation of the goal target.
                            "timestamp": "2020-02-20 00:00:00",  # Optional. The UTC
                              timestamp of the goal value check-in. The time portion of the timestamp
                              is zero.
                            "trend": 0,  # Optional. The goal value trend.
                            "value": 0.0,  # Optional. The goal current value.
                            "valueDisplayString": "str"  # Optional. The textual
                              representation of the current goal value.
                        }
                    ],
                    "hasStatusRules": bool,  # Optional. Whether the goal has status rules
                      defined.
                    "id": "str",  # Optional. The goal ID.
                    "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The UTC time at last
                      modification.
                    "level": 0,  # Optional. The nested level of the goal in the parent-child
                      hierarchy of scorecard goals.
                    "name": "str",  # Optional. The goal name.
                    "notesCount": 0,  # Optional. notesCount.
                    "parentId": "str",  # Optional. The ID of the parent goal, if defined.
                    "permissions": "str",  # Optional. The goal permissions. Known values are:
                      "None", "View", "UpdateCurrentValue", "UpdateTargetValue", "UpdateNotes",
                      "UpdateStatus", "UpdateValues", "All", "11", "13", "15", "19", "21", "23", "25",
                      "27", and "29".
                    "rank": 0,  # Optional. The rank of the goal within the ordered set of
                      sibling goals.
                    "scorecardId": "str",  # Optional. The scorecard ID.
                    "startDate": "2020-02-20 00:00:00",  # Optional. The UTC timestamp for the
                      start date of the goal. The time portion of the timestamp is zero.
                    "statusRules": {
                        "goalObjectId": "str",  # Optional. The goal ID.
                        "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The UTC time
                          at last modification.
                        "rules": "str",  # Optional. The list of rules.
                        "scorecardObjectId": "str"  # Optional. The scorecard ID.
                    },
                    "valuesFormatString": "str"  # Optional. valuesFormatString.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_goals_preview_delete_goal_target_value_connection_request(
            group_id=group_id,
            scorecard_id=scorecard_id,
            goal_id=goal_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def preview_refresh_goal_current_value(  # pylint: disable=inconsistent-return-statements
        self, group_id: str, scorecard_id: str, goal_id: str, **kwargs: Any
    ) -> None:
        """Schedules a refresh of the connected value of a goal.

        Required Scope
        --------------

        Dataset.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The unique identifier of the workspace. Required.
        :type group_id: str
        :param scorecard_id: The unique identifier of the scorecard. Required.
        :type scorecard_id: str
        :param goal_id: The unique identifier of the goal. Required.
        :type goal_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_goals_preview_refresh_goal_current_value_request(
            group_id=group_id,
            scorecard_id=scorecard_id,
            goal_id=goal_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def preview_refresh_goal_target_value(  # pylint: disable=inconsistent-return-statements
        self, group_id: str, scorecard_id: str, goal_id: str, **kwargs: Any
    ) -> None:
        """Schedules a refresh of the target value of a goal.

        Required Scope
        --------------

        Dataset.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The unique identifier of the workspace. Required.
        :type group_id: str
        :param scorecard_id: The unique identifier of the scorecard. Required.
        :type scorecard_id: str
        :param goal_id: The unique identifier of the goal. Required.
        :type goal_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_goals_preview_refresh_goal_target_value_request(
            group_id=group_id,
            scorecard_id=scorecard_id,
            goal_id=goal_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class GoalsStatusRulesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~power_bi_client.aio.PowerBIClient`'s
        :attr:`goals_status_rules` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def preview_get(self, group_id: str, scorecard_id: str, goal_id: str, **kwargs: Any) -> JSON:
        """Returns status rules of a goal.

        Required Scope
        --------------

        Dataset.Read.All or Dataset.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The unique identifier of the workspace. Required.
        :type group_id: str
        :param scorecard_id: The unique identifier of the scorecard. Required.
        :type scorecard_id: str
        :param goal_id: The unique identifier of the goal. Required.
        :type goal_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "defaultOutput": 0,  # Optional. The status ID when no rule matches  ..
                      list-table::    :header-rows: 1     * - ID      - Description    * - 0      - Not
                      started    * - 1      - On track    * - 2      - At risk    * - 3      - Behind
                      * - 4      - Overdue    * - 5      - Completed.
                    "goalObjectId": "str",  # Optional. The goal ID.
                    "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The UTC time at last
                      modification.
                    "rules": [
                        {
                            "conditions": [
                                {
                                    "expression": "str",  # Optional. The rule
                                      condition expression when ``fieldComparison`` isn't defined.
                                    "fieldComparison": {
                                        "field": "str",  # Optional. The name
                                          of the field, such as ``Timestamp``"" , ``Value``"" , or
                                          ``Change``.
                                        "operator": "str",  # Optional. The
                                          comparison operator. Known values are: "Equal",
                                          "GreaterThan", "GreaterThanOrEqual", "LessThan", and
                                          "LessThanOrEqual".
                                        "value": {
                                            "dateTime": "2020-02-20
                                              00:00:00",  # Optional. The rule value timestamp.
                                            "field": "str",  # Optional.
                                              The rule value.
                                            "number": 0.0,  # Optional.
                                              The rule value number.
                                            "percentOf": {
                                                "field": "str",  #
                                                  Optional. The field for which the percent value is
                                                  computed.
                                                "percent": 0.0  #
                                                  Optional. The percent value.
                                            }
                                        }
                                    }
                                }
                            ],
                            "output": 0  # Optional. The status ID when conditions are
                              met  .. list-table::    :header-rows: 1     * - ID      - Description
                              * - 0      - Not started    * - 1      - On track    * - 2      - At risk
                              * - 3      - Behind    * - 4      - Overdue    * - 5      - Completed.
                        }
                    ],
                    "scorecardObjectId": "str"  # Optional. The scorecard ID.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_goals_status_rules_preview_get_request(
            group_id=group_id,
            scorecard_id=scorecard_id,
            goal_id=goal_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def preview_post(
        self,
        group_id: str,
        scorecard_id: str,
        goal_id: str,
        status_rules_update_request: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Creates or updates status rules of a goal.

        Required Scope
        --------------

        Dataset.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The unique identifier of the workspace. Required.
        :type group_id: str
        :param scorecard_id: The unique identifier of the scorecard. Required.
        :type scorecard_id: str
        :param goal_id: The unique identifier of the goal. Required.
        :type goal_id: str
        :param status_rules_update_request: The status rules definition. Required.
        :type status_rules_update_request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                status_rules_update_request = {
                    "defaultOutput": 0,  # The status ID when no rule matches  .. list-table::
                      :header-rows: 1     * - ID      - Description    * - 0      - Not started    * -
                      1      - On track    * - 2      - At risk    * - 3      - Behind    * - 4      -
                      Overdue    * - 5      - Completed. Required.
                    "rules": [
                        {
                            "conditions": [
                                {
                                    "expression": "str",  # Optional. The rule
                                      condition expression when ``fieldComparison`` isn't defined.
                                    "fieldComparison": {
                                        "field": "str",  # Optional. The name
                                          of the field, such as ``Timestamp``"" , ``Value``"" , or
                                          ``Change``.
                                        "operator": "str",  # Optional. The
                                          comparison operator. Known values are: "Equal",
                                          "GreaterThan", "GreaterThanOrEqual", "LessThan", and
                                          "LessThanOrEqual".
                                        "value": {
                                            "dateTime": "2020-02-20
                                              00:00:00",  # Optional. The rule value timestamp.
                                            "field": "str",  # Optional.
                                              The rule value.
                                            "number": 0.0,  # Optional.
                                              The rule value number.
                                            "percentOf": {
                                                "field": "str",  #
                                                  Optional. The field for which the percent value is
                                                  computed.
                                                "percent": 0.0  #
                                                  Optional. The percent value.
                                            }
                                        }
                                    }
                                }
                            ],
                            "output": 0  # Optional. The status ID when conditions are
                              met  .. list-table::    :header-rows: 1     * - ID      - Description
                              * - 0      - Not started    * - 1      - On track    * - 2      - At risk
                              * - 3      - Behind    * - 4      - Overdue    * - 5      - Completed.
                        }
                    ]
                }

                # response body for status code(s): 200
                response == {
                    "defaultOutput": 0,  # Optional. The status ID when no rule matches  ..
                      list-table::    :header-rows: 1     * - ID      - Description    * - 0      - Not
                      started    * - 1      - On track    * - 2      - At risk    * - 3      - Behind
                      * - 4      - Overdue    * - 5      - Completed.
                    "goalObjectId": "str",  # Optional. The goal ID.
                    "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The UTC time at last
                      modification.
                    "rules": [
                        {
                            "conditions": [
                                {
                                    "expression": "str",  # Optional. The rule
                                      condition expression when ``fieldComparison`` isn't defined.
                                    "fieldComparison": {
                                        "field": "str",  # Optional. The name
                                          of the field, such as ``Timestamp``"" , ``Value``"" , or
                                          ``Change``.
                                        "operator": "str",  # Optional. The
                                          comparison operator. Known values are: "Equal",
                                          "GreaterThan", "GreaterThanOrEqual", "LessThan", and
                                          "LessThanOrEqual".
                                        "value": {
                                            "dateTime": "2020-02-20
                                              00:00:00",  # Optional. The rule value timestamp.
                                            "field": "str",  # Optional.
                                              The rule value.
                                            "number": 0.0,  # Optional.
                                              The rule value number.
                                            "percentOf": {
                                                "field": "str",  #
                                                  Optional. The field for which the percent value is
                                                  computed.
                                                "percent": 0.0  #
                                                  Optional. The percent value.
                                            }
                                        }
                                    }
                                }
                            ],
                            "output": 0  # Optional. The status ID when conditions are
                              met  .. list-table::    :header-rows: 1     * - ID      - Description
                              * - 0      - Not started    * - 1      - On track    * - 2      - At risk
                              * - 3      - Behind    * - 4      - Overdue    * - 5      - Completed.
                        }
                    ],
                    "scorecardObjectId": "str"  # Optional. The scorecard ID.
                }
        """

    @overload
    async def preview_post(
        self,
        group_id: str,
        scorecard_id: str,
        goal_id: str,
        status_rules_update_request: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Creates or updates status rules of a goal.

        Required Scope
        --------------

        Dataset.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The unique identifier of the workspace. Required.
        :type group_id: str
        :param scorecard_id: The unique identifier of the scorecard. Required.
        :type scorecard_id: str
        :param goal_id: The unique identifier of the goal. Required.
        :type goal_id: str
        :param status_rules_update_request: The status rules definition. Required.
        :type status_rules_update_request: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "defaultOutput": 0,  # Optional. The status ID when no rule matches  ..
                      list-table::    :header-rows: 1     * - ID      - Description    * - 0      - Not
                      started    * - 1      - On track    * - 2      - At risk    * - 3      - Behind
                      * - 4      - Overdue    * - 5      - Completed.
                    "goalObjectId": "str",  # Optional. The goal ID.
                    "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The UTC time at last
                      modification.
                    "rules": [
                        {
                            "conditions": [
                                {
                                    "expression": "str",  # Optional. The rule
                                      condition expression when ``fieldComparison`` isn't defined.
                                    "fieldComparison": {
                                        "field": "str",  # Optional. The name
                                          of the field, such as ``Timestamp``"" , ``Value``"" , or
                                          ``Change``.
                                        "operator": "str",  # Optional. The
                                          comparison operator. Known values are: "Equal",
                                          "GreaterThan", "GreaterThanOrEqual", "LessThan", and
                                          "LessThanOrEqual".
                                        "value": {
                                            "dateTime": "2020-02-20
                                              00:00:00",  # Optional. The rule value timestamp.
                                            "field": "str",  # Optional.
                                              The rule value.
                                            "number": 0.0,  # Optional.
                                              The rule value number.
                                            "percentOf": {
                                                "field": "str",  #
                                                  Optional. The field for which the percent value is
                                                  computed.
                                                "percent": 0.0  #
                                                  Optional. The percent value.
                                            }
                                        }
                                    }
                                }
                            ],
                            "output": 0  # Optional. The status ID when conditions are
                              met  .. list-table::    :header-rows: 1     * - ID      - Description
                              * - 0      - Not started    * - 1      - On track    * - 2      - At risk
                              * - 3      - Behind    * - 4      - Overdue    * - 5      - Completed.
                        }
                    ],
                    "scorecardObjectId": "str"  # Optional. The scorecard ID.
                }
        """

    @distributed_trace_async
    async def preview_post(
        self,
        group_id: str,
        scorecard_id: str,
        goal_id: str,
        status_rules_update_request: Union[JSON, IO],
        **kwargs: Any
    ) -> JSON:
        """Creates or updates status rules of a goal.

        Required Scope
        --------------

        Dataset.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The unique identifier of the workspace. Required.
        :type group_id: str
        :param scorecard_id: The unique identifier of the scorecard. Required.
        :type scorecard_id: str
        :param goal_id: The unique identifier of the goal. Required.
        :type goal_id: str
        :param status_rules_update_request: The status rules definition. Is either a JSON type or a IO
         type. Required.
        :type status_rules_update_request: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                status_rules_update_request = {
                    "defaultOutput": 0,  # The status ID when no rule matches  .. list-table::
                      :header-rows: 1     * - ID      - Description    * - 0      - Not started    * -
                      1      - On track    * - 2      - At risk    * - 3      - Behind    * - 4      -
                      Overdue    * - 5      - Completed. Required.
                    "rules": [
                        {
                            "conditions": [
                                {
                                    "expression": "str",  # Optional. The rule
                                      condition expression when ``fieldComparison`` isn't defined.
                                    "fieldComparison": {
                                        "field": "str",  # Optional. The name
                                          of the field, such as ``Timestamp``"" , ``Value``"" , or
                                          ``Change``.
                                        "operator": "str",  # Optional. The
                                          comparison operator. Known values are: "Equal",
                                          "GreaterThan", "GreaterThanOrEqual", "LessThan", and
                                          "LessThanOrEqual".
                                        "value": {
                                            "dateTime": "2020-02-20
                                              00:00:00",  # Optional. The rule value timestamp.
                                            "field": "str",  # Optional.
                                              The rule value.
                                            "number": 0.0,  # Optional.
                                              The rule value number.
                                            "percentOf": {
                                                "field": "str",  #
                                                  Optional. The field for which the percent value is
                                                  computed.
                                                "percent": 0.0  #
                                                  Optional. The percent value.
                                            }
                                        }
                                    }
                                }
                            ],
                            "output": 0  # Optional. The status ID when conditions are
                              met  .. list-table::    :header-rows: 1     * - ID      - Description
                              * - 0      - Not started    * - 1      - On track    * - 2      - At risk
                              * - 3      - Behind    * - 4      - Overdue    * - 5      - Completed.
                        }
                    ]
                }

                # response body for status code(s): 200
                response == {
                    "defaultOutput": 0,  # Optional. The status ID when no rule matches  ..
                      list-table::    :header-rows: 1     * - ID      - Description    * - 0      - Not
                      started    * - 1      - On track    * - 2      - At risk    * - 3      - Behind
                      * - 4      - Overdue    * - 5      - Completed.
                    "goalObjectId": "str",  # Optional. The goal ID.
                    "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The UTC time at last
                      modification.
                    "rules": [
                        {
                            "conditions": [
                                {
                                    "expression": "str",  # Optional. The rule
                                      condition expression when ``fieldComparison`` isn't defined.
                                    "fieldComparison": {
                                        "field": "str",  # Optional. The name
                                          of the field, such as ``Timestamp``"" , ``Value``"" , or
                                          ``Change``.
                                        "operator": "str",  # Optional. The
                                          comparison operator. Known values are: "Equal",
                                          "GreaterThan", "GreaterThanOrEqual", "LessThan", and
                                          "LessThanOrEqual".
                                        "value": {
                                            "dateTime": "2020-02-20
                                              00:00:00",  # Optional. The rule value timestamp.
                                            "field": "str",  # Optional.
                                              The rule value.
                                            "number": 0.0,  # Optional.
                                              The rule value number.
                                            "percentOf": {
                                                "field": "str",  #
                                                  Optional. The field for which the percent value is
                                                  computed.
                                                "percent": 0.0  #
                                                  Optional. The percent value.
                                            }
                                        }
                                    }
                                }
                            ],
                            "output": 0  # Optional. The status ID when conditions are
                              met  .. list-table::    :header-rows: 1     * - ID      - Description
                              * - 0      - Not started    * - 1      - On track    * - 2      - At risk
                              * - 3      - Behind    * - 4      - Overdue    * - 5      - Completed.
                        }
                    ],
                    "scorecardObjectId": "str"  # Optional. The scorecard ID.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(status_rules_update_request, (IOBase, bytes)):
            _content = status_rules_update_request
        else:
            _json = status_rules_update_request

        _request = build_goals_status_rules_preview_post_request(
            group_id=group_id,
            scorecard_id=scorecard_id,
            goal_id=goal_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def preview_delete(  # pylint: disable=inconsistent-return-statements
        self, group_id: str, scorecard_id: str, goal_id: str, **kwargs: Any
    ) -> None:
        """Removes status rule definitions from a goal.

        Required Scope
        --------------

        Dataset.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The unique identifier of the workspace. Required.
        :type group_id: str
        :param scorecard_id: The unique identifier of the scorecard. Required.
        :type scorecard_id: str
        :param goal_id: The unique identifier of the goal. Required.
        :type goal_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_goals_status_rules_preview_delete_request(
            group_id=group_id,
            scorecard_id=scorecard_id,
            goal_id=goal_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class GoalValuesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~power_bi_client.aio.PowerBIClient`'s
        :attr:`goal_values` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def preview_get(
        self, group_id: str, scorecard_id: str, goal_id: str, *, expand: Optional[str] = None, **kwargs: Any
    ) -> JSON:
        """Reads goal value check-ins.

        Required Scope
        --------------

        Dataset.Read.All or Dataset.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The unique identifier of the workspace. Required.
        :type group_id: str
        :param scorecard_id: The unique identifier of the scorecard. Required.
        :type scorecard_id: str
        :param goal_id: The unique identifier of the goal. Required.
        :type goal_id: str
        :keyword expand: Accepts a comma-separated list of data types, which will be expanded inline in
         the response. Supports ``notes``. Default value is None.
        :paramtype expand: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "@odata.context": "str",  # Optional. OData context.
                    "value": [
                        {
                            "createdTime": "2020-02-20 00:00:00",  # Optional. The UTC
                              time at creation.
                            "forecast": 0.0,  # Optional. The goal value trend forecast.
                            "goalId": "str",  # Optional. The goal ID.
                            "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The
                              UTC time at last modification.
                            "notes": [
                                {
                                    "body": "str",  # Optional. The note text.
                                    "content": "str",  # Optional. The content of
                                      this note in special format.
                                    "createdTime": "2020-02-20 00:00:00",  #
                                      Optional. The UTC time at creation.
                                    "goalId": "str",  # Optional. The goal ID.
                                    "id": "str",  # Optional. The goal value
                                      check-in note ID.
                                    "lastModifiedTime": "2020-02-20 00:00:00",  #
                                      Optional. The UTC time at last modification.
                                    "scorecardId": "str",  # Optional. The
                                      scorecard ID.
                                    "valueTimestamp": "2020-02-20 00:00:00"  #
                                      Optional. The UTC timestamp of the goal value check-in that this
                                      note belongs to. The time portion of the timestamp is zero.
                                }
                            ],
                            "scorecardId": "str",  # Optional. The scorecard ID.
                            "status": 0,  # Optional. The ID of the goal status  ..
                              list-table::    :header-rows: 1     * - ID      - Description    * - 0
                              - Not started    * - 1      - On track    * - 2      - At risk    * - 3
                              - Behind    * - 4      - Overdue    * - 5      - Completed.
                            "target": 0.0,  # Optional. The goal target value.
                            "targetDisplayString": "str",  # Optional. The textual
                              representation of the goal target.
                            "timestamp": "2020-02-20 00:00:00",  # Optional. The UTC
                              timestamp of the goal value check-in. The time portion of the timestamp
                              is zero.
                            "trend": 0,  # Optional. The goal value trend.
                            "value": 0.0,  # Optional. The goal current value.
                            "valueDisplayString": "str"  # Optional. The textual
                              representation of the current goal value.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_goal_values_preview_get_request(
            group_id=group_id,
            scorecard_id=scorecard_id,
            goal_id=goal_id,
            expand=expand,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def preview_post(
        self,
        group_id: str,
        scorecard_id: str,
        goal_id: str,
        goal_value: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Creates a new goal value check-in.

        Required Scope
        --------------

        Dataset.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The unique identifier of the workspace. Required.
        :type group_id: str
        :param scorecard_id: The unique identifier of the scorecard. Required.
        :type scorecard_id: str
        :param goal_id: The unique identifier of the goal. Required.
        :type goal_id: str
        :param goal_value: Goal value content. Required.
        :type goal_value: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                goal_value = {
                    "timestamp": "2020-02-20 00:00:00",  # The UTC timestamp of the goal value
                      check-in. The time portion of the timestamp is zero. Required.
                    "forecast": 0.0,  # Optional. Optional. The value trend forecast of the goal.
                    "status": 0,  # Optional. Optional. The goal status ID.  .. list-table::
                      :header-rows: 1     * - ID      - Description    * - 0      - Not started    * -
                      1      - On track    * - 2      - At risk    * - 3      - Behind    * - 4      -
                      Overdue    * - 5      - Completed.
                    "target": 0.0,  # Optional. Optional. The target value of the goal.
                    "trend": 0,  # Optional. Optional. The value trend of the goal.
                    "value": 0.0  # Optional. Optional. The current value of the goal.
                }

                # response body for status code(s): 200
                response == {
                    "createdTime": "2020-02-20 00:00:00",  # Optional. The UTC time at creation.
                    "forecast": 0.0,  # Optional. The goal value trend forecast.
                    "goalId": "str",  # Optional. The goal ID.
                    "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The UTC time at last
                      modification.
                    "notes": [
                        {
                            "body": "str",  # Optional. The note text.
                            "content": "str",  # Optional. The content of this note in
                              special format.
                            "createdTime": "2020-02-20 00:00:00",  # Optional. The UTC
                              time at creation.
                            "goalId": "str",  # Optional. The goal ID.
                            "id": "str",  # Optional. The goal value check-in note ID.
                            "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The
                              UTC time at last modification.
                            "scorecardId": "str",  # Optional. The scorecard ID.
                            "valueTimestamp": "2020-02-20 00:00:00"  # Optional. The UTC
                              timestamp of the goal value check-in that this note belongs to. The time
                              portion of the timestamp is zero.
                        }
                    ],
                    "scorecardId": "str",  # Optional. The scorecard ID.
                    "status": 0,  # Optional. The ID of the goal status  .. list-table::
                      :header-rows: 1     * - ID      - Description    * - 0      - Not started    * -
                      1      - On track    * - 2      - At risk    * - 3      - Behind    * - 4      -
                      Overdue    * - 5      - Completed.
                    "target": 0.0,  # Optional. The goal target value.
                    "targetDisplayString": "str",  # Optional. The textual representation of the
                      goal target.
                    "timestamp": "2020-02-20 00:00:00",  # Optional. The UTC timestamp of the
                      goal value check-in. The time portion of the timestamp is zero.
                    "trend": 0,  # Optional. The goal value trend.
                    "value": 0.0,  # Optional. The goal current value.
                    "valueDisplayString": "str"  # Optional. The textual representation of the
                      current goal value.
                }
        """

    @overload
    async def preview_post(
        self,
        group_id: str,
        scorecard_id: str,
        goal_id: str,
        goal_value: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Creates a new goal value check-in.

        Required Scope
        --------------

        Dataset.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The unique identifier of the workspace. Required.
        :type group_id: str
        :param scorecard_id: The unique identifier of the scorecard. Required.
        :type scorecard_id: str
        :param goal_id: The unique identifier of the goal. Required.
        :type goal_id: str
        :param goal_value: Goal value content. Required.
        :type goal_value: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "createdTime": "2020-02-20 00:00:00",  # Optional. The UTC time at creation.
                    "forecast": 0.0,  # Optional. The goal value trend forecast.
                    "goalId": "str",  # Optional. The goal ID.
                    "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The UTC time at last
                      modification.
                    "notes": [
                        {
                            "body": "str",  # Optional. The note text.
                            "content": "str",  # Optional. The content of this note in
                              special format.
                            "createdTime": "2020-02-20 00:00:00",  # Optional. The UTC
                              time at creation.
                            "goalId": "str",  # Optional. The goal ID.
                            "id": "str",  # Optional. The goal value check-in note ID.
                            "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The
                              UTC time at last modification.
                            "scorecardId": "str",  # Optional. The scorecard ID.
                            "valueTimestamp": "2020-02-20 00:00:00"  # Optional. The UTC
                              timestamp of the goal value check-in that this note belongs to. The time
                              portion of the timestamp is zero.
                        }
                    ],
                    "scorecardId": "str",  # Optional. The scorecard ID.
                    "status": 0,  # Optional. The ID of the goal status  .. list-table::
                      :header-rows: 1     * - ID      - Description    * - 0      - Not started    * -
                      1      - On track    * - 2      - At risk    * - 3      - Behind    * - 4      -
                      Overdue    * - 5      - Completed.
                    "target": 0.0,  # Optional. The goal target value.
                    "targetDisplayString": "str",  # Optional. The textual representation of the
                      goal target.
                    "timestamp": "2020-02-20 00:00:00",  # Optional. The UTC timestamp of the
                      goal value check-in. The time portion of the timestamp is zero.
                    "trend": 0,  # Optional. The goal value trend.
                    "value": 0.0,  # Optional. The goal current value.
                    "valueDisplayString": "str"  # Optional. The textual representation of the
                      current goal value.
                }
        """

    @distributed_trace_async
    async def preview_post(
        self, group_id: str, scorecard_id: str, goal_id: str, goal_value: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Creates a new goal value check-in.

        Required Scope
        --------------

        Dataset.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The unique identifier of the workspace. Required.
        :type group_id: str
        :param scorecard_id: The unique identifier of the scorecard. Required.
        :type scorecard_id: str
        :param goal_id: The unique identifier of the goal. Required.
        :type goal_id: str
        :param goal_value: Goal value content. Is either a JSON type or a IO type. Required.
        :type goal_value: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                goal_value = {
                    "timestamp": "2020-02-20 00:00:00",  # The UTC timestamp of the goal value
                      check-in. The time portion of the timestamp is zero. Required.
                    "forecast": 0.0,  # Optional. Optional. The value trend forecast of the goal.
                    "status": 0,  # Optional. Optional. The goal status ID.  .. list-table::
                      :header-rows: 1     * - ID      - Description    * - 0      - Not started    * -
                      1      - On track    * - 2      - At risk    * - 3      - Behind    * - 4      -
                      Overdue    * - 5      - Completed.
                    "target": 0.0,  # Optional. Optional. The target value of the goal.
                    "trend": 0,  # Optional. Optional. The value trend of the goal.
                    "value": 0.0  # Optional. Optional. The current value of the goal.
                }

                # response body for status code(s): 200
                response == {
                    "createdTime": "2020-02-20 00:00:00",  # Optional. The UTC time at creation.
                    "forecast": 0.0,  # Optional. The goal value trend forecast.
                    "goalId": "str",  # Optional. The goal ID.
                    "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The UTC time at last
                      modification.
                    "notes": [
                        {
                            "body": "str",  # Optional. The note text.
                            "content": "str",  # Optional. The content of this note in
                              special format.
                            "createdTime": "2020-02-20 00:00:00",  # Optional. The UTC
                              time at creation.
                            "goalId": "str",  # Optional. The goal ID.
                            "id": "str",  # Optional. The goal value check-in note ID.
                            "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The
                              UTC time at last modification.
                            "scorecardId": "str",  # Optional. The scorecard ID.
                            "valueTimestamp": "2020-02-20 00:00:00"  # Optional. The UTC
                              timestamp of the goal value check-in that this note belongs to. The time
                              portion of the timestamp is zero.
                        }
                    ],
                    "scorecardId": "str",  # Optional. The scorecard ID.
                    "status": 0,  # Optional. The ID of the goal status  .. list-table::
                      :header-rows: 1     * - ID      - Description    * - 0      - Not started    * -
                      1      - On track    * - 2      - At risk    * - 3      - Behind    * - 4      -
                      Overdue    * - 5      - Completed.
                    "target": 0.0,  # Optional. The goal target value.
                    "targetDisplayString": "str",  # Optional. The textual representation of the
                      goal target.
                    "timestamp": "2020-02-20 00:00:00",  # Optional. The UTC timestamp of the
                      goal value check-in. The time portion of the timestamp is zero.
                    "trend": 0,  # Optional. The goal value trend.
                    "value": 0.0,  # Optional. The goal current value.
                    "valueDisplayString": "str"  # Optional. The textual representation of the
                      current goal value.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(goal_value, (IOBase, bytes)):
            _content = goal_value
        else:
            _json = goal_value

        _request = build_goal_values_preview_post_request(
            group_id=group_id,
            scorecard_id=scorecard_id,
            goal_id=goal_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def preview_get_by_id(
        self,
        group_id: str,
        scorecard_id: str,
        goal_id: str,
        timestamp: datetime.date,
        *,
        expand: Optional[str] = None,
        **kwargs: Any
    ) -> JSON:
        """Reads a goal value check-in by a UTC date timestamp.

        Required Scope
        --------------

        Dataset.Read.All or Dataset.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The unique identifier of the workspace. Required.
        :type group_id: str
        :param scorecard_id: The unique identifier of the scorecard. Required.
        :type scorecard_id: str
        :param goal_id: The unique identifier of the goal. Required.
        :type goal_id: str
        :param timestamp: The timestamp for the value of the goal. Required.
        :type timestamp: ~datetime.date
        :keyword expand: Accepts a comma-separated list of data types, which will be expanded inline in
         the response. Supports ``notes``. Default value is None.
        :paramtype expand: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "createdTime": "2020-02-20 00:00:00",  # Optional. The UTC time at creation.
                    "forecast": 0.0,  # Optional. The goal value trend forecast.
                    "goalId": "str",  # Optional. The goal ID.
                    "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The UTC time at last
                      modification.
                    "notes": [
                        {
                            "body": "str",  # Optional. The note text.
                            "content": "str",  # Optional. The content of this note in
                              special format.
                            "createdTime": "2020-02-20 00:00:00",  # Optional. The UTC
                              time at creation.
                            "goalId": "str",  # Optional. The goal ID.
                            "id": "str",  # Optional. The goal value check-in note ID.
                            "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The
                              UTC time at last modification.
                            "scorecardId": "str",  # Optional. The scorecard ID.
                            "valueTimestamp": "2020-02-20 00:00:00"  # Optional. The UTC
                              timestamp of the goal value check-in that this note belongs to. The time
                              portion of the timestamp is zero.
                        }
                    ],
                    "scorecardId": "str",  # Optional. The scorecard ID.
                    "status": 0,  # Optional. The ID of the goal status  .. list-table::
                      :header-rows: 1     * - ID      - Description    * - 0      - Not started    * -
                      1      - On track    * - 2      - At risk    * - 3      - Behind    * - 4      -
                      Overdue    * - 5      - Completed.
                    "target": 0.0,  # Optional. The goal target value.
                    "targetDisplayString": "str",  # Optional. The textual representation of the
                      goal target.
                    "timestamp": "2020-02-20 00:00:00",  # Optional. The UTC timestamp of the
                      goal value check-in. The time portion of the timestamp is zero.
                    "trend": 0,  # Optional. The goal value trend.
                    "value": 0.0,  # Optional. The goal current value.
                    "valueDisplayString": "str"  # Optional. The textual representation of the
                      current goal value.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_goal_values_preview_get_by_id_request(
            group_id=group_id,
            scorecard_id=scorecard_id,
            goal_id=goal_id,
            timestamp=timestamp,
            expand=expand,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def preview_patch_by_id(
        self,
        group_id: str,
        scorecard_id: str,
        goal_id: str,
        timestamp: datetime.date,
        goal_value: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Updates a goal value check-in by a UTC date timestamp.

        Required Scope
        --------------

        Dataset.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The unique identifier of the workspace. Required.
        :type group_id: str
        :param scorecard_id: The unique identifier of the scorecard. Required.
        :type scorecard_id: str
        :param goal_id: The unique identifier of the goal. Required.
        :type goal_id: str
        :param timestamp: The timestamp for the value of the goal. Required.
        :type timestamp: ~datetime.date
        :param goal_value: The updated content of goal value check-in. Required.
        :type goal_value: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                goal_value = {
                    "createdTime": "2020-02-20 00:00:00",  # Optional. The UTC time at creation.
                    "forecast": 0.0,  # Optional. The goal value trend forecast.
                    "goalId": "str",  # Optional. The goal ID.
                    "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The UTC time at last
                      modification.
                    "notes": [
                        {
                            "body": "str",  # Optional. The note text.
                            "content": "str",  # Optional. The content of this note in
                              special format.
                            "createdTime": "2020-02-20 00:00:00",  # Optional. The UTC
                              time at creation.
                            "goalId": "str",  # Optional. The goal ID.
                            "id": "str",  # Optional. The goal value check-in note ID.
                            "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The
                              UTC time at last modification.
                            "scorecardId": "str",  # Optional. The scorecard ID.
                            "valueTimestamp": "2020-02-20 00:00:00"  # Optional. The UTC
                              timestamp of the goal value check-in that this note belongs to. The time
                              portion of the timestamp is zero.
                        }
                    ],
                    "scorecardId": "str",  # Optional. The scorecard ID.
                    "status": 0,  # Optional. The ID of the goal status  .. list-table::
                      :header-rows: 1     * - ID      - Description    * - 0      - Not started    * -
                      1      - On track    * - 2      - At risk    * - 3      - Behind    * - 4      -
                      Overdue    * - 5      - Completed.
                    "target": 0.0,  # Optional. The goal target value.
                    "targetDisplayString": "str",  # Optional. The textual representation of the
                      goal target.
                    "timestamp": "2020-02-20 00:00:00",  # Optional. The UTC timestamp of the
                      goal value check-in. The time portion of the timestamp is zero.
                    "trend": 0,  # Optional. The goal value trend.
                    "value": 0.0,  # Optional. The goal current value.
                    "valueDisplayString": "str"  # Optional. The textual representation of the
                      current goal value.
                }

                # response body for status code(s): 200
                response == {
                    "createdTime": "2020-02-20 00:00:00",  # Optional. The UTC time at creation.
                    "forecast": 0.0,  # Optional. The goal value trend forecast.
                    "goalId": "str",  # Optional. The goal ID.
                    "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The UTC time at last
                      modification.
                    "notes": [
                        {
                            "body": "str",  # Optional. The note text.
                            "content": "str",  # Optional. The content of this note in
                              special format.
                            "createdTime": "2020-02-20 00:00:00",  # Optional. The UTC
                              time at creation.
                            "goalId": "str",  # Optional. The goal ID.
                            "id": "str",  # Optional. The goal value check-in note ID.
                            "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The
                              UTC time at last modification.
                            "scorecardId": "str",  # Optional. The scorecard ID.
                            "valueTimestamp": "2020-02-20 00:00:00"  # Optional. The UTC
                              timestamp of the goal value check-in that this note belongs to. The time
                              portion of the timestamp is zero.
                        }
                    ],
                    "scorecardId": "str",  # Optional. The scorecard ID.
                    "status": 0,  # Optional. The ID of the goal status  .. list-table::
                      :header-rows: 1     * - ID      - Description    * - 0      - Not started    * -
                      1      - On track    * - 2      - At risk    * - 3      - Behind    * - 4      -
                      Overdue    * - 5      - Completed.
                    "target": 0.0,  # Optional. The goal target value.
                    "targetDisplayString": "str",  # Optional. The textual representation of the
                      goal target.
                    "timestamp": "2020-02-20 00:00:00",  # Optional. The UTC timestamp of the
                      goal value check-in. The time portion of the timestamp is zero.
                    "trend": 0,  # Optional. The goal value trend.
                    "value": 0.0,  # Optional. The goal current value.
                    "valueDisplayString": "str"  # Optional. The textual representation of the
                      current goal value.
                }
        """

    @overload
    async def preview_patch_by_id(
        self,
        group_id: str,
        scorecard_id: str,
        goal_id: str,
        timestamp: datetime.date,
        goal_value: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Updates a goal value check-in by a UTC date timestamp.

        Required Scope
        --------------

        Dataset.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The unique identifier of the workspace. Required.
        :type group_id: str
        :param scorecard_id: The unique identifier of the scorecard. Required.
        :type scorecard_id: str
        :param goal_id: The unique identifier of the goal. Required.
        :type goal_id: str
        :param timestamp: The timestamp for the value of the goal. Required.
        :type timestamp: ~datetime.date
        :param goal_value: The updated content of goal value check-in. Required.
        :type goal_value: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "createdTime": "2020-02-20 00:00:00",  # Optional. The UTC time at creation.
                    "forecast": 0.0,  # Optional. The goal value trend forecast.
                    "goalId": "str",  # Optional. The goal ID.
                    "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The UTC time at last
                      modification.
                    "notes": [
                        {
                            "body": "str",  # Optional. The note text.
                            "content": "str",  # Optional. The content of this note in
                              special format.
                            "createdTime": "2020-02-20 00:00:00",  # Optional. The UTC
                              time at creation.
                            "goalId": "str",  # Optional. The goal ID.
                            "id": "str",  # Optional. The goal value check-in note ID.
                            "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The
                              UTC time at last modification.
                            "scorecardId": "str",  # Optional. The scorecard ID.
                            "valueTimestamp": "2020-02-20 00:00:00"  # Optional. The UTC
                              timestamp of the goal value check-in that this note belongs to. The time
                              portion of the timestamp is zero.
                        }
                    ],
                    "scorecardId": "str",  # Optional. The scorecard ID.
                    "status": 0,  # Optional. The ID of the goal status  .. list-table::
                      :header-rows: 1     * - ID      - Description    * - 0      - Not started    * -
                      1      - On track    * - 2      - At risk    * - 3      - Behind    * - 4      -
                      Overdue    * - 5      - Completed.
                    "target": 0.0,  # Optional. The goal target value.
                    "targetDisplayString": "str",  # Optional. The textual representation of the
                      goal target.
                    "timestamp": "2020-02-20 00:00:00",  # Optional. The UTC timestamp of the
                      goal value check-in. The time portion of the timestamp is zero.
                    "trend": 0,  # Optional. The goal value trend.
                    "value": 0.0,  # Optional. The goal current value.
                    "valueDisplayString": "str"  # Optional. The textual representation of the
                      current goal value.
                }
        """

    @distributed_trace_async
    async def preview_patch_by_id(
        self,
        group_id: str,
        scorecard_id: str,
        goal_id: str,
        timestamp: datetime.date,
        goal_value: Union[JSON, IO],
        **kwargs: Any
    ) -> JSON:
        """Updates a goal value check-in by a UTC date timestamp.

        Required Scope
        --------------

        Dataset.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The unique identifier of the workspace. Required.
        :type group_id: str
        :param scorecard_id: The unique identifier of the scorecard. Required.
        :type scorecard_id: str
        :param goal_id: The unique identifier of the goal. Required.
        :type goal_id: str
        :param timestamp: The timestamp for the value of the goal. Required.
        :type timestamp: ~datetime.date
        :param goal_value: The updated content of goal value check-in. Is either a JSON type or a IO
         type. Required.
        :type goal_value: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                goal_value = {
                    "createdTime": "2020-02-20 00:00:00",  # Optional. The UTC time at creation.
                    "forecast": 0.0,  # Optional. The goal value trend forecast.
                    "goalId": "str",  # Optional. The goal ID.
                    "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The UTC time at last
                      modification.
                    "notes": [
                        {
                            "body": "str",  # Optional. The note text.
                            "content": "str",  # Optional. The content of this note in
                              special format.
                            "createdTime": "2020-02-20 00:00:00",  # Optional. The UTC
                              time at creation.
                            "goalId": "str",  # Optional. The goal ID.
                            "id": "str",  # Optional. The goal value check-in note ID.
                            "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The
                              UTC time at last modification.
                            "scorecardId": "str",  # Optional. The scorecard ID.
                            "valueTimestamp": "2020-02-20 00:00:00"  # Optional. The UTC
                              timestamp of the goal value check-in that this note belongs to. The time
                              portion of the timestamp is zero.
                        }
                    ],
                    "scorecardId": "str",  # Optional. The scorecard ID.
                    "status": 0,  # Optional. The ID of the goal status  .. list-table::
                      :header-rows: 1     * - ID      - Description    * - 0      - Not started    * -
                      1      - On track    * - 2      - At risk    * - 3      - Behind    * - 4      -
                      Overdue    * - 5      - Completed.
                    "target": 0.0,  # Optional. The goal target value.
                    "targetDisplayString": "str",  # Optional. The textual representation of the
                      goal target.
                    "timestamp": "2020-02-20 00:00:00",  # Optional. The UTC timestamp of the
                      goal value check-in. The time portion of the timestamp is zero.
                    "trend": 0,  # Optional. The goal value trend.
                    "value": 0.0,  # Optional. The goal current value.
                    "valueDisplayString": "str"  # Optional. The textual representation of the
                      current goal value.
                }

                # response body for status code(s): 200
                response == {
                    "createdTime": "2020-02-20 00:00:00",  # Optional. The UTC time at creation.
                    "forecast": 0.0,  # Optional. The goal value trend forecast.
                    "goalId": "str",  # Optional. The goal ID.
                    "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The UTC time at last
                      modification.
                    "notes": [
                        {
                            "body": "str",  # Optional. The note text.
                            "content": "str",  # Optional. The content of this note in
                              special format.
                            "createdTime": "2020-02-20 00:00:00",  # Optional. The UTC
                              time at creation.
                            "goalId": "str",  # Optional. The goal ID.
                            "id": "str",  # Optional. The goal value check-in note ID.
                            "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The
                              UTC time at last modification.
                            "scorecardId": "str",  # Optional. The scorecard ID.
                            "valueTimestamp": "2020-02-20 00:00:00"  # Optional. The UTC
                              timestamp of the goal value check-in that this note belongs to. The time
                              portion of the timestamp is zero.
                        }
                    ],
                    "scorecardId": "str",  # Optional. The scorecard ID.
                    "status": 0,  # Optional. The ID of the goal status  .. list-table::
                      :header-rows: 1     * - ID      - Description    * - 0      - Not started    * -
                      1      - On track    * - 2      - At risk    * - 3      - Behind    * - 4      -
                      Overdue    * - 5      - Completed.
                    "target": 0.0,  # Optional. The goal target value.
                    "targetDisplayString": "str",  # Optional. The textual representation of the
                      goal target.
                    "timestamp": "2020-02-20 00:00:00",  # Optional. The UTC timestamp of the
                      goal value check-in. The time portion of the timestamp is zero.
                    "trend": 0,  # Optional. The goal value trend.
                    "value": 0.0,  # Optional. The goal current value.
                    "valueDisplayString": "str"  # Optional. The textual representation of the
                      current goal value.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(goal_value, (IOBase, bytes)):
            _content = goal_value
        else:
            _json = goal_value

        _request = build_goal_values_preview_patch_by_id_request(
            group_id=group_id,
            scorecard_id=scorecard_id,
            goal_id=goal_id,
            timestamp=timestamp,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def preview_delete_by_id(  # pylint: disable=inconsistent-return-statements
        self, group_id: str, scorecard_id: str, goal_id: str, timestamp: datetime.date, **kwargs: Any
    ) -> None:
        """Deletes a goal value check-in by a UTC day timestamp.

        Required Scope
        --------------

        Dataset.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The unique identifier of the workspace. Required.
        :type group_id: str
        :param scorecard_id: The unique identifier of the scorecard. Required.
        :type scorecard_id: str
        :param goal_id: The unique identifier of the goal. Required.
        :type goal_id: str
        :param timestamp: The timestamp for the value of the goal. Required.
        :type timestamp: ~datetime.date
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_goal_values_preview_delete_by_id_request(
            group_id=group_id,
            scorecard_id=scorecard_id,
            goal_id=goal_id,
            timestamp=timestamp,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class GoalNotesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~power_bi_client.aio.PowerBIClient`'s
        :attr:`goal_notes` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    async def preview_post(
        self,
        group_id: str,
        scorecard_id: str,
        goal_id: str,
        timestamp: datetime.date,
        goal_note: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Adds a new note to a goal value check-in.

        Required Scope
        --------------

        Dataset.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The unique identifier of the workspace. Required.
        :type group_id: str
        :param scorecard_id: The unique identifier of the scorecard. Required.
        :type scorecard_id: str
        :param goal_id: The unique identifier of the goal. Required.
        :type goal_id: str
        :param timestamp: The timestamp for the value of the goal. Required.
        :type timestamp: ~datetime.date
        :param goal_note: The goal check-in note. Required.
        :type goal_note: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                goal_note = {
                    "body": "str"  # The note text. Required.
                }

                # response body for status code(s): 200
                response == {
                    "body": "str",  # Optional. The note text.
                    "content": "str",  # Optional. The content of this note in special format.
                    "createdTime": "2020-02-20 00:00:00",  # Optional. The UTC time at creation.
                    "goalId": "str",  # Optional. The goal ID.
                    "id": "str",  # Optional. The goal value check-in note ID.
                    "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The UTC time at last
                      modification.
                    "scorecardId": "str",  # Optional. The scorecard ID.
                    "valueTimestamp": "2020-02-20 00:00:00"  # Optional. The UTC timestamp of the
                      goal value check-in that this note belongs to. The time portion of the timestamp
                      is zero.
                }
        """

    @overload
    async def preview_post(
        self,
        group_id: str,
        scorecard_id: str,
        goal_id: str,
        timestamp: datetime.date,
        goal_note: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Adds a new note to a goal value check-in.

        Required Scope
        --------------

        Dataset.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The unique identifier of the workspace. Required.
        :type group_id: str
        :param scorecard_id: The unique identifier of the scorecard. Required.
        :type scorecard_id: str
        :param goal_id: The unique identifier of the goal. Required.
        :type goal_id: str
        :param timestamp: The timestamp for the value of the goal. Required.
        :type timestamp: ~datetime.date
        :param goal_note: The goal check-in note. Required.
        :type goal_note: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "body": "str",  # Optional. The note text.
                    "content": "str",  # Optional. The content of this note in special format.
                    "createdTime": "2020-02-20 00:00:00",  # Optional. The UTC time at creation.
                    "goalId": "str",  # Optional. The goal ID.
                    "id": "str",  # Optional. The goal value check-in note ID.
                    "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The UTC time at last
                      modification.
                    "scorecardId": "str",  # Optional. The scorecard ID.
                    "valueTimestamp": "2020-02-20 00:00:00"  # Optional. The UTC timestamp of the
                      goal value check-in that this note belongs to. The time portion of the timestamp
                      is zero.
                }
        """

    @distributed_trace_async
    async def preview_post(
        self,
        group_id: str,
        scorecard_id: str,
        goal_id: str,
        timestamp: datetime.date,
        goal_note: Union[JSON, IO],
        **kwargs: Any
    ) -> JSON:
        """Adds a new note to a goal value check-in.

        Required Scope
        --------------

        Dataset.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The unique identifier of the workspace. Required.
        :type group_id: str
        :param scorecard_id: The unique identifier of the scorecard. Required.
        :type scorecard_id: str
        :param goal_id: The unique identifier of the goal. Required.
        :type goal_id: str
        :param timestamp: The timestamp for the value of the goal. Required.
        :type timestamp: ~datetime.date
        :param goal_note: The goal check-in note. Is either a JSON type or a IO type. Required.
        :type goal_note: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                goal_note = {
                    "body": "str"  # The note text. Required.
                }

                # response body for status code(s): 200
                response == {
                    "body": "str",  # Optional. The note text.
                    "content": "str",  # Optional. The content of this note in special format.
                    "createdTime": "2020-02-20 00:00:00",  # Optional. The UTC time at creation.
                    "goalId": "str",  # Optional. The goal ID.
                    "id": "str",  # Optional. The goal value check-in note ID.
                    "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The UTC time at last
                      modification.
                    "scorecardId": "str",  # Optional. The scorecard ID.
                    "valueTimestamp": "2020-02-20 00:00:00"  # Optional. The UTC timestamp of the
                      goal value check-in that this note belongs to. The time portion of the timestamp
                      is zero.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(goal_note, (IOBase, bytes)):
            _content = goal_note
        else:
            _json = goal_note

        _request = build_goal_notes_preview_post_request(
            group_id=group_id,
            scorecard_id=scorecard_id,
            goal_id=goal_id,
            timestamp=timestamp,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    async def preview_patch_by_id(
        self,
        group_id: str,
        scorecard_id: str,
        goal_id: str,
        timestamp: datetime.date,
        note_id: str,
        goal_note: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Updates a goal value check-in note by ID.

        Required Scope
        --------------

        Dataset.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The unique identifier of the workspace. Required.
        :type group_id: str
        :param scorecard_id: The unique identifier of the scorecard. Required.
        :type scorecard_id: str
        :param goal_id: The unique identifier of the goal. Required.
        :type goal_id: str
        :param timestamp: The timestamp for the value of the goal. Required.
        :type timestamp: ~datetime.date
        :param note_id: The unique identifier of the goal check-in note. Required.
        :type note_id: str
        :param goal_note: The note content to be updated. Required.
        :type goal_note: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                goal_note = {
                    "body": "str"  # The note text. Required.
                }

                # response body for status code(s): 200
                response == {
                    "body": "str",  # Optional. The note text.
                    "content": "str",  # Optional. The content of this note in special format.
                    "createdTime": "2020-02-20 00:00:00",  # Optional. The UTC time at creation.
                    "goalId": "str",  # Optional. The goal ID.
                    "id": "str",  # Optional. The goal value check-in note ID.
                    "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The UTC time at last
                      modification.
                    "scorecardId": "str",  # Optional. The scorecard ID.
                    "valueTimestamp": "2020-02-20 00:00:00"  # Optional. The UTC timestamp of the
                      goal value check-in that this note belongs to. The time portion of the timestamp
                      is zero.
                }
        """

    @overload
    async def preview_patch_by_id(
        self,
        group_id: str,
        scorecard_id: str,
        goal_id: str,
        timestamp: datetime.date,
        note_id: str,
        goal_note: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Updates a goal value check-in note by ID.

        Required Scope
        --------------

        Dataset.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The unique identifier of the workspace. Required.
        :type group_id: str
        :param scorecard_id: The unique identifier of the scorecard. Required.
        :type scorecard_id: str
        :param goal_id: The unique identifier of the goal. Required.
        :type goal_id: str
        :param timestamp: The timestamp for the value of the goal. Required.
        :type timestamp: ~datetime.date
        :param note_id: The unique identifier of the goal check-in note. Required.
        :type note_id: str
        :param goal_note: The note content to be updated. Required.
        :type goal_note: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "body": "str",  # Optional. The note text.
                    "content": "str",  # Optional. The content of this note in special format.
                    "createdTime": "2020-02-20 00:00:00",  # Optional. The UTC time at creation.
                    "goalId": "str",  # Optional. The goal ID.
                    "id": "str",  # Optional. The goal value check-in note ID.
                    "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The UTC time at last
                      modification.
                    "scorecardId": "str",  # Optional. The scorecard ID.
                    "valueTimestamp": "2020-02-20 00:00:00"  # Optional. The UTC timestamp of the
                      goal value check-in that this note belongs to. The time portion of the timestamp
                      is zero.
                }
        """

    @distributed_trace_async
    async def preview_patch_by_id(
        self,
        group_id: str,
        scorecard_id: str,
        goal_id: str,
        timestamp: datetime.date,
        note_id: str,
        goal_note: Union[JSON, IO],
        **kwargs: Any
    ) -> JSON:
        """Updates a goal value check-in note by ID.

        Required Scope
        --------------

        Dataset.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The unique identifier of the workspace. Required.
        :type group_id: str
        :param scorecard_id: The unique identifier of the scorecard. Required.
        :type scorecard_id: str
        :param goal_id: The unique identifier of the goal. Required.
        :type goal_id: str
        :param timestamp: The timestamp for the value of the goal. Required.
        :type timestamp: ~datetime.date
        :param note_id: The unique identifier of the goal check-in note. Required.
        :type note_id: str
        :param goal_note: The note content to be updated. Is either a JSON type or a IO type. Required.
        :type goal_note: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                goal_note = {
                    "body": "str"  # The note text. Required.
                }

                # response body for status code(s): 200
                response == {
                    "body": "str",  # Optional. The note text.
                    "content": "str",  # Optional. The content of this note in special format.
                    "createdTime": "2020-02-20 00:00:00",  # Optional. The UTC time at creation.
                    "goalId": "str",  # Optional. The goal ID.
                    "id": "str",  # Optional. The goal value check-in note ID.
                    "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. The UTC time at last
                      modification.
                    "scorecardId": "str",  # Optional. The scorecard ID.
                    "valueTimestamp": "2020-02-20 00:00:00"  # Optional. The UTC timestamp of the
                      goal value check-in that this note belongs to. The time portion of the timestamp
                      is zero.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(goal_note, (IOBase, bytes)):
            _content = goal_note
        else:
            _json = goal_note

        _request = build_goal_notes_preview_patch_by_id_request(
            group_id=group_id,
            scorecard_id=scorecard_id,
            goal_id=goal_id,
            timestamp=timestamp,
            note_id=note_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace_async
    async def preview_delete_by_id(  # pylint: disable=inconsistent-return-statements
        self, group_id: str, scorecard_id: str, goal_id: str, timestamp: datetime.date, note_id: str, **kwargs: Any
    ) -> None:
        """Deletes a goal value check-in note by ID.

        Required Scope
        --------------

        Dataset.ReadWrite.All
        :code:`<br>`:code:`<br>`.

        :param group_id: The unique identifier of the workspace. Required.
        :type group_id: str
        :param scorecard_id: The unique identifier of the scorecard. Required.
        :type scorecard_id: str
        :param goal_id: The unique identifier of the goal. Required.
        :type goal_id: str
        :param timestamp: The timestamp for the value of the goal. Required.
        :type timestamp: ~datetime.date
        :param note_id: The unique identifier of the goal check-in note. Required.
        :type note_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_goal_notes_preview_delete_by_id_request(
            group_id=group_id,
            scorecard_id=scorecard_id,
            goal_id=goal_id,
            timestamp=timestamp,
            note_id=note_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore
